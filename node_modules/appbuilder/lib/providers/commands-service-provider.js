"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const initCommandLib = require("../commands/project/init-project");
const projectCommandLib = require("../commands/project/create-project");
const samplesLib = require("../commands/samples");
const constants_1 = require("../common/constants");
class CommandsServiceProvider {
    constructor($injector, $screenBuilderService) {
        this.$injector = $injector;
        this.$screenBuilderService = $screenBuilderService;
        this.mapCommandNameToFramework = {
            hybrid: constants_1.TARGET_FRAMEWORK_IDENTIFIERS.Cordova,
            native: constants_1.TARGET_FRAMEWORK_IDENTIFIERS.NativeScript
        };
        this.commands = [
            {
                commandConstructor: projectCommandLib.CreateProjectCommand,
                baseCommandName: "create",
                filePath: "./commands/project/create-project"
            },
            {
                commandConstructor: initCommandLib.InitProjectCommand,
                baseCommandName: "init",
                filePath: "./commands/project/init-project"
            },
            {
                commandConstructor: samplesLib.PrintSamplesCommand,
                baseCommandName: "sample",
                filePath: "./commands/samples"
            }
        ];
    }
    get dynamicCommandsPrefix() {
        return this.$screenBuilderService.commandsPrefix;
    }
    getDynamicCommands() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.$screenBuilderService.allSupportedCommands(this.$injector.resolve("project").getProjectDir(), this.$screenBuilderService.generatorFullName);
        });
    }
    generateDynamicCommands() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.$screenBuilderService.generateAllCommands(this.$injector.resolve("project").getProjectDir(), this.$screenBuilderService.generatorFullName);
        });
    }
    registerDynamicSubCommands() {
        _.each(this.commands, command => {
            this.registerDynamicSubCommand(command);
        });
    }
    registerDynamicSubCommand(command) {
        let subCommands = _.keys(this.mapCommandNameToFramework);
        _.each(subCommands, subCommand => {
            let resolver = this.$injector.resolve(command.commandConstructor, { frameworkIdentifier: this.mapCommandNameToFramework[subCommand] });
            let name = `${command.baseCommandName}|${subCommand}`;
            this.$injector.requireCommand(name, command.filePath);
            this.$injector.registerCommand(name, resolver);
        });
    }
}
$injector.register("commandsServiceProvider", CommandsServiceProvider);
