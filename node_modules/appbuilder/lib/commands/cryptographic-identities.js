"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const util = require("util");
const helpers = require("../helpers");
const path = require("path");
const moment = require("moment");
const validators = require("../validators/cryptographic-identity-validators");
const iosValidators = require("../validators/ios-deployment-validator");
const os = require("os");
const commandParams = require("../common/command-params");
class CryptographicIdentityConstants {
}
CryptographicIdentityConstants.PKCS12_EXTENSION = "p12";
CryptographicIdentityConstants.X509_EXTENSION = "cer";
CryptographicIdentityConstants.PKCS12CERTIFICATE = "Pkcs12";
CryptographicIdentityConstants.X509CERTIFICATE = "X509Certificate";
CryptographicIdentityConstants.APPLE_INC = "Apple Inc.";
CryptographicIdentityConstants.MAX_ALLOWED_PASSWORD_ATTEMPTS = 3;
class CryptographicIdentityStoreService {
    constructor($server, $x509) {
        this.$server = $server;
        this.$x509 = $x509;
    }
    getAllProvisions() {
        return __awaiter(this, void 0, void 0, function* () {
            let data = yield this.$server.mobileprovisions.getProvisions();
            return _.map(data, (identityData) => identityData);
        });
    }
    getAllIdentities() {
        return __awaiter(this, void 0, void 0, function* () {
            let data = yield this.$server.identityStore.getIdentities();
            return _.map(data, (identityData) => {
                let identity = identityData;
                let certificateOrganization = this.$x509.load(identity.Certificate).issuerData['O'];
                identity.isiOS = certificateOrganization === CryptographicIdentityConstants.APPLE_INC;
                return identity;
            });
        });
    }
}
exports.CryptographicIdentityStoreService = CryptographicIdentityStoreService;
$injector.register("cryptographicIdentityStoreService", CryptographicIdentityStoreService);
class IdentityManager {
    constructor($cryptographicIdentityStoreService, $selfSignedIdentityValidator, $logger, $errors, $x509, $injector, $options) {
        this.$cryptographicIdentityStoreService = $cryptographicIdentityStoreService;
        this.$selfSignedIdentityValidator = $selfSignedIdentityValidator;
        this.$logger = $logger;
        this.$errors = $errors;
        this.$x509 = $x509;
        this.$injector = $injector;
        this.$options = $options;
    }
    listCertificates() {
        return __awaiter(this, void 0, void 0, function* () {
            let identities = yield this.$cryptographicIdentityStoreService.getAllIdentities();
            identities = _.sortBy(identities, (identity) => identity.Alias);
            _.forEach(identities, (identity, index) => {
                let cert = this.$x509.load(identity.Certificate);
                this.$logger.out("%s: '%s', expires on %s, issued by %s", (index + 1).toString(), identity.Alias, cert.expiresOn.toDateString(), cert.issuerData["CN"]);
            });
            if (!identities.length) {
                this.$logger.info("No certificates found. To add a certificate, run `certificate import` " +
                    "to import an existing certificate or `certificate create-self-signed` to create a new one.");
            }
        });
    }
    printProvisionData(provision, provisionIndex) {
        this.$logger.out("%s: '%s', type: %s, App ID: '%s.%s'", (provisionIndex + 1).toString(), provision.Name, provision.ProvisionType, provision.ApplicationIdentifierPrefix, provision.ApplicationIdentifier);
        if (this.$options.verbose) {
            let devices = provision.ProvisionedDevices;
            if (devices && devices.length) {
                this.$logger.out("  Provisioned device identifiers:");
                devices.sort();
                _.forEach(devices, (device, deviceIndex) => {
                    this.$logger.out("    " + devices[deviceIndex]);
                });
            }
            else {
                this.$logger.out("  No provisioned devices.");
            }
        }
    }
    listProvisions(provisionStr) {
        return __awaiter(this, void 0, void 0, function* () {
            if (provisionStr) {
                let provision = yield this.findProvision(provisionStr);
                this.printProvisionData(provision, 0);
                return;
            }
            let provisions = yield this.$cryptographicIdentityStoreService.getAllProvisions();
            provisions = _.sortBy(provisions, (provision) => provision.Name);
            _.forEach(provisions, (provision, provisionIndex) => {
                this.printProvisionData(provision, provisionIndex);
            });
            if (!provisions.length) {
                this.$logger.info("No provisioning profiles found. To add a provisioning profile, run `provision import`.");
            }
        });
    }
    findCertificate(identityStr) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$logger.debug("Looking for certificate '%s'", identityStr);
            let identities = yield this.$cryptographicIdentityStoreService.getAllIdentities();
            let result = helpers.findByNameOrIndex(identityStr, identities, (ident) => ident.Alias);
            if (!result) {
                this.$errors.fail("Could not find certificate named '%s' or was not given " +
                    "a valid index. List registered certificates with 'certificate' command.", identityStr);
            }
            else {
                return result;
            }
        });
    }
    findProvision(provisionStr) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$logger.debug("Looking for provision '%s'", provisionStr);
            let provisions = yield this.$cryptographicIdentityStoreService.getAllProvisions();
            let result = helpers.findByNameOrIndex(provisionStr, provisions, (provision) => provision.Name);
            if (!result) {
                this.$errors.fail("Could not find provision named '%s' or was not given a valid index. List registered provisions with 'provision' command.", provisionStr);
            }
            return result;
        });
    }
    autoselectProvision(appIdentifier, provisionTypes, deviceIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let provisions = yield this.$cryptographicIdentityStoreService.getAllProvisions();
            let identities = yield this.$cryptographicIdentityStoreService.getAllIdentities();
            provisions = _.filter(provisions, (prov) => _.includes(provisionTypes, prov.ProvisionType));
            if (provisions.length === 0) {
                this.$errors.fail("No provision of type %s found.", helpers.formatListOfNames(provisionTypes));
            }
            let validator = this.$injector.resolve(iosValidators.IOSDeploymentValidator, { deviceIdentifier: deviceIdentifier, appIdentifier: appIdentifier });
            let passedProvisions = [];
            let failedProvisions = [];
            _.each(provisions, (prov) => {
                let validationResult = validator.validateProvision(prov);
                let hasCompatibleCertificate = false;
                let error = validationResult.error;
                if (validationResult.isSuccessful) {
                    hasCompatibleCertificate = _.some(identities, (identity) => validator.validateCertificate(identity, prov).isSuccessful);
                    if (!hasCompatibleCertificate) {
                        error = `Unable to find applicable certificate for provision ${prov.Name}.`;
                    }
                }
                if (validationResult.isSuccessful && hasCompatibleCertificate) {
                    passedProvisions.push(prov);
                }
                else {
                    failedProvisions.push({ provision: prov, error: error });
                }
            });
            let provision = _(provisionTypes)
                .map((type) => _.find(passedProvisions, (prov) => prov.ProvisionType === type))
                .find((prov) => Boolean(prov));
            if (provision) {
                return provision;
            }
            else {
                let composedError = util.format("Cannot find applicable provisioning profiles. %s", os.EOL);
                let iterator = (result, data) => {
                    let currentError = util.format('Cannot use provision "%s" because the following error occurred: %s %s', data.provision.Name, data.error, os.EOL);
                    return result + currentError;
                };
                composedError = _.reduce(failedProvisions, iterator, composedError);
                this.$errors.fail(composedError);
            }
            return null;
        });
    }
    autoselectCertificate(provisionData) {
        return __awaiter(this, void 0, void 0, function* () {
            let identities = yield this.$cryptographicIdentityStoreService.getAllIdentities();
            let validator = this.$injector.resolve(iosValidators.IOSDeploymentValidator, { deviceIdentifier: null, appIdentifier: null });
            let identity = _.find(identities, (ident) => validator.validateCertificate(ident, provisionData).isSuccessful);
            if (identity) {
                return identity;
            }
            else {
                this.$errors.fail("No certificate compatible with provision '%s' found.", provisionData.Name);
                return null;
            }
        });
    }
    isCertificateCompatibleWithProvision(certificate, provision) {
        let formattedCertificate = helpers.stringReplaceAll(certificate.Certificate, /[\r\n]/, "");
        return _.some(provision.Certificates, (c) => formattedCertificate.indexOf(c) >= 0);
    }
    findReleaseCertificate() {
        return __awaiter(this, void 0, void 0, function* () {
            let identities = yield this.$cryptographicIdentityStoreService.getAllIdentities();
            return _.find(identities, (identity) => this.$selfSignedIdentityValidator.validateCertificate(true, identity.Certificate));
        });
    }
}
exports.IdentityManager = IdentityManager;
$injector.register("identityManager", IdentityManager);
class IdentityGenerationDataFactory {
    static create(identityModel) {
        let identityGenerationData = {
            StartDate: new Date(identityModel.StartDate),
            Attributes: {},
            EndDate: new Date(identityModel.EndDate),
            SubjectNameValues: IdentityGenerationDataFactory.getDistinguishedNameValues(identityModel.Name, identityModel.Email, identityModel.Country)
        };
        return identityGenerationData;
    }
    static getDistinguishedNameValues(name, email, countryCode) {
        let distinguishedNameValues = Object.create(null);
        distinguishedNameValues[IdentityGenerationDataFactory.derObjectIdentifierNames.CN] = name;
        distinguishedNameValues[IdentityGenerationDataFactory.derObjectIdentifierNames.EmailAddress] = email;
        distinguishedNameValues[IdentityGenerationDataFactory.derObjectIdentifierNames.C] = countryCode;
        return distinguishedNameValues;
    }
}
IdentityGenerationDataFactory.derObjectIdentifierNames = {
    C: "2.5.4.6",
    CN: "2.5.4.3",
    EmailAddress: "1.2.840.113549.1.9.1"
};
class IdentityInformationGatherer {
    constructor($selfSignedIdentityValidator, $userDataStore, $prompter, $httpClient, $logger) {
        this.$selfSignedIdentityValidator = $selfSignedIdentityValidator;
        this.$userDataStore = $userDataStore;
        this.$prompter = $prompter;
        this.$httpClient = $httpClient;
        this.$logger = $logger;
    }
    gatherIdentityInformation(model) {
        return __awaiter(this, void 0, void 0, function* () {
            let myCountry = model.Country;
            if (!myCountry) {
                this.$logger.trace("Find default country with call to http://freegeoip.net/json/");
                myCountry = yield this.getDefaultCountry();
            }
            let user = yield this.$userDataStore.getUser();
            let schema = [];
            if (!model.Name) {
                schema.push({
                    type: "input",
                    name: "Name",
                    message: "Name",
                    default: () => user.name
                });
            }
            if (!model.Email) {
                schema.push({
                    type: "input",
                    name: "Email",
                    message: "Email",
                    default: () => user.email,
                    validate: (value) => {
                        let validationResult = this.$selfSignedIdentityValidator.validateProperty({ Email: value }, "Email");
                        return validationResult.isSuccessful ? true : validationResult.error;
                    }
                });
            }
            if (!model.Country) {
                schema.push({
                    type: "input",
                    name: "Country",
                    message: "Country",
                    default: () => myCountry,
                    validate: (value) => {
                        let validationResult = this.$selfSignedIdentityValidator.validateProperty({ Country: value }, "Country");
                        let message = [validationResult.error, "Valid countries are:"];
                        message.push(helpers.formatListForDisplayInMultipleColumns(helpers.getCountries()));
                        return validationResult.isSuccessful ? true : message.join("\n");
                    }
                });
            }
            return schema.length ? yield this.$prompter.get(schema) : {};
        });
    }
    getDefaultCountry() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let locationResponse = yield this.$httpClient.httpRequest("http://freegeoip.net/json/");
                let location = JSON.parse(locationResponse.body);
                return location.country_name;
            }
            catch (err) {
                return "";
            }
        });
    }
}
$injector.register("identityInformationGatherer", IdentityInformationGatherer);
class CreateSelfSignedIdentity {
    constructor($server, $identityInformationGatherer, $selfSignedIdentityValidator, $prompter, $logger, $errors, $injector) {
        this.$server = $server;
        this.$identityInformationGatherer = $identityInformationGatherer;
        this.$selfSignedIdentityValidator = $selfSignedIdentityValidator;
        this.$prompter = $prompter;
        this.$logger = $logger;
        this.$errors = $errors;
        this.$injector = $injector;
        this.allowedParameters = [new commandParams.StringCommandParameter(this.$injector), new commandParams.StringCommandParameter(this.$injector),
            new commandParams.StringCommandParameter(this.$injector), new commandParams.StringCommandParameter(this.$injector),
            new commandParams.StringCommandParameter(this.$injector), new commandParams.StringCommandParameter(this.$injector)];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let type = args[3];
            if (type && type.toLowerCase() !== "generic" && type.toLowerCase() !== "googleplay") {
                this.$errors.fail("Certificate type must be either 'Generic' or 'GooglePlay'");
            }
            let identityInfo = {
                Name: args[0],
                Email: args[1],
                Country: args[2]
            };
            this.model = identityInfo;
            identityInfo = yield this.$identityInformationGatherer.gatherIdentityInformation(identityInfo);
            this.model.ForGooglePlayPublishing = args[3] ? (args[3].toLowerCase() === "googleplay" ? "y" : "n") : undefined;
            this.model.StartDate = args[4];
            this.model.EndDate = args[5];
            let promptSchema = this.getPromptSchema(this.model);
            if (promptSchema.length > 0) {
                this.model = yield this.$prompter.get(promptSchema);
                _.extend(this.model, identityInfo);
            }
            let endDate = this.model.EndDate;
            if (!endDate) {
                endDate = yield this.$prompter.get([{
                        message: "Valid until (yyyy-mm-dd)",
                        type: "input",
                        name: "EndDate",
                        default: () => this.getDefaultEndDate(this.isForGooglePlay()),
                        validate: (value) => {
                            let validationResult = this.$selfSignedIdentityValidator.
                                validateProperty({
                                ForGooglePlayPublishing: this.isForGooglePlay().toString(),
                                StartDate: this.model["StartDate"] || this.getHistoryValue("StartDate"),
                                EndDate: value
                            }, "EndDate");
                            return validationResult.isSuccessful ? true : validationResult.error;
                        }
                    }]);
                _.extend(this.model, endDate);
            }
            let identityGenerationData = IdentityGenerationDataFactory.create(this.model);
            let result = yield this.$server.identityStore.generateSelfSignedIdentity(identityGenerationData);
            this.$logger.info("Successfully created certificate '%s'.", result.Alias);
        });
    }
    getPromptSchema(defaults) {
        let promptSchema = [];
        if (!defaults.ForGooglePlayPublishing) {
            promptSchema.push({
                message: "Is for Google Play publishing?",
                type: "confirm",
                name: "ForGooglePlayPublishing",
                default: () => false
            });
        }
        if (!defaults.StartDate) {
            promptSchema.push({
                message: "Valid from (yyyy-mm-dd)",
                type: "input",
                name: "StartDate",
                default: () => moment(new Date()).format(validators.SelfSignedIdentityValidator.DATE_FORMAT),
                validate: (value) => {
                    let validationResult = this.$selfSignedIdentityValidator.validateProperty({ StartDate: value }, "StartDate");
                    return validationResult.isSuccessful ? true : validationResult.error;
                }
            });
        }
        return promptSchema;
    }
    isForGooglePlay() {
        return this.getHistoryValue("ForGooglePlayPublishing");
    }
    getHistoryValue(name) {
        return this.model[name];
    }
    getDefaultEndDate(forGooglePlayPublishing) {
        if (forGooglePlayPublishing) {
            return moment(validators.SelfSignedIdentityValidator.GOOGLE_PLAY_IDENTITY_MIN_EXPIRATION_DATE)
                .format(validators.SelfSignedIdentityValidator.DATE_FORMAT);
        }
        return moment().add("years", 1).format(validators.SelfSignedIdentityValidator.DATE_FORMAT);
    }
}
exports.CreateSelfSignedIdentity = CreateSelfSignedIdentity;
$injector.registerCommand("certificate|create-self-signed", CreateSelfSignedIdentity);
class ListCertificatesCommand {
    constructor($identityManager) {
        this.$identityManager = $identityManager;
        this.allowedParameters = [];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$identityManager.listCertificates();
        });
    }
}
exports.ListCertificatesCommand = ListCertificatesCommand;
$injector.registerCommand("certificate|*list", ListCertificatesCommand);
class RemoveCryptographicIdentity {
    constructor($server, $prompter, $options, $identityManager, $stringParameterBuilder) {
        this.$server = $server;
        this.$prompter = $prompter;
        this.$options = $options;
        this.$identityManager = $identityManager;
        this.$stringParameterBuilder = $stringParameterBuilder;
        this.allowedParameters = [this.$stringParameterBuilder.createMandatoryParameter("Specify certificate name or index.")];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let nameOrIndex = args[0];
            let identity = yield this.$identityManager.findCertificate(nameOrIndex);
            if (this.$options.force || (yield this.$prompter.confirm(util.format("Are you sure you want to delete certificate '%s'?", identity.Alias), () => false))) {
                yield this.$server.identityStore.removeIdentity(identity.Alias);
            }
        });
    }
}
exports.RemoveCryptographicIdentity = RemoveCryptographicIdentity;
$injector.registerCommand("certificate|remove", RemoveCryptographicIdentity);
class ExportCryptographicIdentity {
    constructor($server, $identityManager, $prompter, $fs, $logger, $errors, $stringParameterBuilder, $injector, $options) {
        this.$server = $server;
        this.$identityManager = $identityManager;
        this.$prompter = $prompter;
        this.$fs = $fs;
        this.$logger = $logger;
        this.$errors = $errors;
        this.$stringParameterBuilder = $stringParameterBuilder;
        this.$injector = $injector;
        this.$options = $options;
        this.allowedParameters = [this.$stringParameterBuilder.createMandatoryParameter("Specify certificate name or index."),
            new commandParams.StringCommandParameter(this.$injector)];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let nameOrIndex = args[0];
            let password = args[1];
            let identity = yield this.$identityManager.findCertificate(nameOrIndex);
            let name = identity.Alias;
            let sanitizedName = helpers.stringReplaceAll(name, /[^\w|\d|\s|\-|_|\(|\)|]/, "");
            if (sanitizedName.length === 0) {
                sanitizedName = "exported_certificate";
                this.$logger.warn("Certificate name contains only invalid characters: Defaulting to %s!", sanitizedName);
            }
            else {
                sanitizedName = (sanitizedName + "_certificate").trim();
            }
            let targetFileName = path.join(this.getPath(), util.format("%s.%s", sanitizedName, CryptographicIdentityConstants.PKCS12_EXTENSION));
            if (this.$fs.exists(targetFileName)) {
                this.$errors.fail("The target file '%s' already exists.", targetFileName);
            }
            if (!password) {
                password = yield this.$prompter.getPassword("Exported file password");
            }
            let targetFile = this.$fs.createWriteStream(targetFileName);
            this.$logger.info("Exporting certificate to file '%s'.", targetFileName);
            yield this.$server.identityStore.getIdentity(name, password, targetFile);
        });
    }
    getPath() {
        let path = this.$options.path;
        delete this.$options.path;
        if (!path) {
            path = process.cwd();
        }
        else if (!this.$fs.exists(path)) {
            this.$errors.fail("The path '%s' does not exist.", path);
        }
        return path;
    }
}
exports.ExportCryptographicIdentity = ExportCryptographicIdentity;
$injector.registerCommand("certificate|export", ExportCryptographicIdentity);
class ImportCryptographicIdentity {
    constructor($server, $fs, $prompter, $logger, $errors, $stringParameterBuilder, $injector) {
        this.$server = $server;
        this.$fs = $fs;
        this.$prompter = $prompter;
        this.$logger = $logger;
        this.$errors = $errors;
        this.$stringParameterBuilder = $stringParameterBuilder;
        this.$injector = $injector;
        this.allowedParameters = [this.$stringParameterBuilder.createMandatoryParameter("No certificate file specified."),
            new commandParams.StringCommandParameter(this.$injector)];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let certificateFile = args[0], password = args[1], extension = path.extname(certificateFile).toLowerCase();
            if (extension !== ".p12" && extension !== ".cer") {
                this.$errors.fail("To add a cryptographic identity to the list, import a P12 file " +
                    "that contains an existing cryptographic identity or a CER file that contains the " +
                    "certificate generated from a certificate signing request.");
            }
            let importType = extension === ".p12" ? CryptographicIdentityConstants.PKCS12CERTIFICATE : CryptographicIdentityConstants.X509CERTIFICATE;
            if (!this.$fs.exists(certificateFile)) {
                this.$errors.fail("The file '%s' does not exist.", certificateFile);
            }
            let result = importType === CryptographicIdentityConstants.PKCS12CERTIFICATE ?
                yield this.importCertificateWithPassword(importType, password, certificateFile) :
                yield this.importCertificateWithoutPassword(importType, certificateFile);
            _.each(result, identity => {
                this.$logger.info("Imported certificate '%s'.", identity.Alias);
            });
        });
    }
    importCertificateWithPassword(importType, password, certificateFile) {
        return __awaiter(this, void 0, void 0, function* () {
            let result, targetFile, noErrorOccurred, isPasswordRequired = !password;
            for (let i = 0; i < CryptographicIdentityConstants.MAX_ALLOWED_PASSWORD_ATTEMPTS; ++i) {
                noErrorOccurred = true;
                targetFile = this.$fs.createReadStream(certificateFile);
                if (isPasswordRequired) {
                    password = yield this.$prompter.getPassword("Certificate file password", { allowEmpty: true });
                }
                try {
                    result = yield this.$server.identityStore.importIdentity(importType, password, targetFile);
                }
                catch (err) {
                    noErrorOccurred = false;
                    isPasswordRequired = true;
                    this.$logger.error(err.message + os.EOL + "Verify that you have provided the correct file and password and try again.");
                }
                if (noErrorOccurred) {
                    break;
                }
            }
            if (!noErrorOccurred) {
                this.$errors.failWithoutHelp("You have reached the maximum number of authentication attempts for this operation.");
            }
            return result;
        });
    }
    importCertificateWithoutPassword(importType, certificateFile) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let targetFile = this.$fs.createReadStream(certificateFile);
                return yield this.$server.identityStore.importIdentity(importType, '', targetFile);
            }
            catch (error) {
                this.$errors.failWithoutHelp(error.message);
            }
        });
    }
}
exports.ImportCryptographicIdentity = ImportCryptographicIdentity;
$injector.registerCommand("certificate|import", ImportCryptographicIdentity);
class CreateCertificateSigningRequest {
    constructor($server, $injector, $identityInformationGatherer) {
        this.$server = $server;
        this.$injector = $injector;
        this.$identityInformationGatherer = $identityInformationGatherer;
        this.allowedParameters = [new commandParams.StringCommandParameter(this.$injector),
            new commandParams.StringCommandParameter(this.$injector),
            new commandParams.StringCommandParameter(this.$injector)];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = {
                Name: args[0],
                Email: args[1],
                Country: args[2]
            };
            model = yield this.$identityInformationGatherer.gatherIdentityInformation(model);
            let subjectNameValues = IdentityGenerationDataFactory.getDistinguishedNameValues(model.Name, model.Email, model.Country);
            let certificateData = yield this.$server.identityStore.generateCertificationRequest(subjectNameValues);
            let downloader = this.$injector.resolve(DownloadCertificateSigningRequestCommand);
            yield downloader.downloadCertificate(certificateData.UniqueName);
        });
    }
}
$injector.registerCommand("certificate-request|create", CreateCertificateSigningRequest);
class ListCertificateSigningRequestsCommand {
    constructor($logger, $server) {
        this.$logger = $logger;
        this.$server = $server;
        this.allowedParameters = [];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let requests = yield this.$server.identityStore.getCertificateRequests();
            requests = _.sortBy(requests, (req) => req.UniqueName);
            _.forEach(requests, (req, i, list) => {
                this.$logger.out("%s: %s", (i + 1).toString(), req.Subject);
            });
            if (!requests.length) {
                this.$logger.info("No certificate signing requests.");
            }
        });
    }
}
$injector.registerCommand("certificate-request|*list", ListCertificateSigningRequestsCommand);
function parseCertificateIndex(indexStr, $errors, $server) {
    return __awaiter(this, void 0, void 0, function* () {
        let requests = yield $server.identityStore.getCertificateRequests();
        requests = _.sortBy(requests, (req) => req.UniqueName);
        let index = parseInt(indexStr, 10) - 1;
        if (index < 0 || index >= requests.length) {
            $errors.fail("No certificate with number '%s' exists", indexStr);
        }
        let req = requests[index];
        return req;
    });
}
class RemoveCertificateSigningRequestCommand {
    constructor($logger, $injector, $prompter, $server, $stringParameterBuilder) {
        this.$logger = $logger;
        this.$injector = $injector;
        this.$prompter = $prompter;
        this.$server = $server;
        this.$stringParameterBuilder = $stringParameterBuilder;
        this.allowedParameters = [this.$stringParameterBuilder.createMandatoryParameter("Specify certificate signing request index to delete.")];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let indexStr = args[0];
            let req = yield this.$injector.resolve(parseCertificateIndex, { indexStr: indexStr });
            if (yield this.$prompter.confirm(util.format("Are you sure that you want to delete certificate request '%s'?", req.Subject))) {
                yield this.$server.identityStore.removeCertificateRequest(req.UniqueName);
                this.$logger.info("Removed certificate request '%s'", req.Subject);
            }
        });
    }
}
$injector.registerCommand("certificate-request|remove", RemoveCertificateSigningRequestCommand);
class DownloadCertificateSigningRequestCommand {
    constructor($logger, $injector, $errors, $fs, $server, $stringParameterBuilder, $options) {
        this.$logger = $logger;
        this.$injector = $injector;
        this.$errors = $errors;
        this.$fs = $fs;
        this.$server = $server;
        this.$stringParameterBuilder = $stringParameterBuilder;
        this.$options = $options;
        this.allowedParameters = [this.$stringParameterBuilder.createMandatoryParameter("Specify certificate signing request index to delete.")];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let indexStr = args[0];
            if (!indexStr) {
                this.$errors.fail("Specify certificate signing request index to download.");
            }
            let req = yield this.$injector.resolve(parseCertificateIndex, { indexStr: indexStr });
            yield this.downloadCertificate(req.UniqueName);
        });
    }
    downloadCertificate(uniqueName) {
        return __awaiter(this, void 0, void 0, function* () {
            let targetFileName = this.$options.saveTo;
            if (targetFileName) {
                if (this.$fs.exists(targetFileName)) {
                    this.$errors.fail("The output file already exists.");
                }
            }
            else {
                targetFileName = this.$fs.getUniqueFileName("certificate_request.csr");
            }
            let targetFile = this.$fs.createWriteStream(targetFileName);
            this.$logger.info("Writing certificate signing request to %s", path.resolve(targetFileName));
            yield this.$server.identityStore.getCertificateRequest(uniqueName, targetFile);
        });
    }
}
$injector.registerCommand("certificate-request|download", DownloadCertificateSigningRequestCommand);
class FileNameCommandParameter {
    constructor($errors, $fs) {
        this.$errors = $errors;
        this.$fs = $fs;
        this.mandatory = true;
    }
    validate(validationValue) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileName = validationValue;
            if (!fileName) {
                this.$errors.fail("No file specified.");
            }
            if (!this.$fs.exists(fileName)) {
                this.$errors.fail({ formatStr: "File '%s' does not exist.", suppressCommandHelp: true }, fileName);
            }
            return true;
        });
    }
}
class ListProvisionsCommand {
    constructor($identityManager, $stringParameter) {
        this.$identityManager = $identityManager;
        this.$stringParameter = $stringParameter;
        this.allowedParameters = [this.$stringParameter];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$identityManager.listProvisions(args[0]);
        });
    }
}
exports.ListProvisionsCommand = ListProvisionsCommand;
$injector.registerCommand("provision|*list", ListProvisionsCommand);
class ImportProvisionCommand {
    constructor($fs, $logger, $errors, $server, $commandsService) {
        this.$fs = $fs;
        this.$logger = $logger;
        this.$errors = $errors;
        this.$server = $server;
        this.$commandsService = $commandsService;
        this.allowedParameters = [new FileNameCommandParameter(this.$errors, this.$fs)];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileName = args[0];
            if (!fileName) {
                this.$errors.fail("No file specified.");
            }
            if (!this.$fs.exists(fileName)) {
                this.$errors.fail({ formatStr: "File '%s' does not exist.", suppressCommandHelp: true }, fileName);
            }
            let provisionFile = this.$fs.createReadStream(fileName);
            let provisionData = yield this.$server.mobileprovisions.importProvision(provisionFile);
            this.$logger.info("Successfully imported provision '%s'.", provisionData.Name);
            yield this.$commandsService.tryExecuteCommand("provision", []);
        });
    }
}
$injector.registerCommand("provision|import", ImportProvisionCommand);
class ProvisionIdCommandParameter {
    constructor($identityManager) {
        this.$identityManager = $identityManager;
        this.mandatory = true;
    }
    validate(validationValue) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$identityManager.findProvision(validationValue);
            return true;
        });
    }
}
class RemoveProvisionCommand {
    constructor($identityManager, $logger, $server, $commandsService) {
        this.$identityManager = $identityManager;
        this.$logger = $logger;
        this.$server = $server;
        this.$commandsService = $commandsService;
        this.allowedParameters = [new ProvisionIdCommandParameter(this.$identityManager)];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let provisionData = yield this.$identityManager.findProvision(args[0]);
            yield this.$server.mobileprovisions.removeProvision(provisionData.Identifier);
            this.$logger.info("Removed provisioning profile '%s'.", provisionData.Name);
            yield this.$commandsService.tryExecuteCommand("provision", []);
        });
    }
}
$injector.registerCommand("provision|remove", RemoveProvisionCommand);
