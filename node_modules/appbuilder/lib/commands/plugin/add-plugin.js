"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const pluginsDataLib = require("./../../plugins-data");
class AddPluginCommand {
    constructor($pluginsService, $injector, $options) {
        this.$pluginsService = $pluginsService;
        this.$injector = $injector;
        this.$options = $options;
        this.allowedParameters = [];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.$options.available) {
                let installedPlugins = yield this.$pluginsService.getInstalledPlugins();
                let plugins = _.reject(yield this.$pluginsService.getAvailablePlugins(), (plugin) => {
                    if (plugin.type === pluginsDataLib.PluginType.MarketplacePlugin) {
                        let marketPlacePlugin = plugin;
                        let installedPlugin = _.find(installedPlugins, (p) => p.data.Name === plugin.data.Name && p.data.Version === plugin.data.Version);
                        if (installedPlugin) {
                            if (marketPlacePlugin.pluginVersionsData.Versions.length > 1) {
                                marketPlacePlugin.pluginVersionsData.Versions = _.reject(marketPlacePlugin.pluginVersionsData.Versions, versionData => versionData.Version === installedPlugin.data.Version);
                                let defaultVersion = marketPlacePlugin.pluginVersionsData.DefaultVersion;
                                if (defaultVersion !== installedPlugin.data.Version) {
                                    marketPlacePlugin.data = _.find(marketPlacePlugin.pluginVersionsData.Versions, versionData => versionData.Version === defaultVersion);
                                    marketPlacePlugin.pluginVersionsData.DefaultVersion = marketPlacePlugin.data.Version;
                                }
                                return false;
                            }
                            return true;
                        }
                    }
                    return _.some(installedPlugins, (installedPlugin) => installedPlugin.data.Name === plugin.data.Name);
                });
                yield this.$pluginsService.printPlugins(yield this.$pluginsService.filterPlugins(plugins));
            }
            else {
                yield this.$pluginsService.addPlugin(args[0]);
            }
        });
    }
    canExecute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.$options.available) {
                return true;
            }
            let pluginName = args[0];
            let pluginCommandParameter = this.$injector.resolve(PluginCommandParameter);
            yield pluginCommandParameter.validate(pluginName);
            return true;
        });
    }
}
exports.AddPluginCommand = AddPluginCommand;
$injector.registerCommand("plugin|add", AddPluginCommand);
class PluginCommandParameter {
    constructor($errors) {
        this.$errors = $errors;
        this.mandatory = true;
    }
    validate(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!pluginName) {
                this.$errors.fail("No plugin name specified");
            }
            return true;
        });
    }
}
