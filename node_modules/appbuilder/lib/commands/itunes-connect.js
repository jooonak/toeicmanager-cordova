"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const constants = require("../common/constants");
const commandParams = require("../common/command-params");
let Table = require("cli-table");
function getAppleId($prompter) {
    return __awaiter(this, void 0, void 0, function* () {
        let appleIdSchema = {
            message: "Apple ID",
            type: "input",
            name: "appleId",
            validate: (value) => {
                return !value ? "Apple ID must be non-empty." : true;
            }
        };
        let result = yield $prompter.get([appleIdSchema]);
        return result["appleId"];
    });
}
class ListApplicationsReadyForUploadCommand {
    constructor($logger, $prompter, $loginManager, $injector, $appStoreService) {
        this.$logger = $logger;
        this.$prompter = $prompter;
        this.$loginManager = $loginManager;
        this.$injector = $injector;
        this.$appStoreService = $appStoreService;
        this.allowedParameters = [new commandParams.StringCommandParameter(this.$injector), new commandParams.StringCommandParameter(this.$injector)];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$loginManager.ensureLoggedIn();
            let userName = args[0];
            let password = args[1];
            if (!userName) {
                userName = yield getAppleId(this.$prompter);
            }
            if (!password) {
                password = yield this.$prompter.getPassword("Apple ID password");
            }
            let apps = yield this.$appStoreService.getApplicationsReadyForUpload(userName, password);
            if (!apps.length) {
                this.$logger.out("No applications are ready for upload.");
                return;
            }
            let table = new Table({
                head: ["Application", "Version", "Bundle ID"],
                chars: { 'mid': '', 'left-mid': '', 'mid-mid': '', 'right-mid': '' }
            });
            _.each(apps, (app) => {
                table.push([app.Application, app["Version Number"], app.ReservedBundleIdentifier]);
            });
            this.$logger.out(table.toString());
        });
    }
}
exports.ListApplicationsReadyForUploadCommand = ListApplicationsReadyForUploadCommand;
$injector.registerCommand("appstore|list", ListApplicationsReadyForUploadCommand);
class UploadApplicationCommand {
    constructor($logger, $errors, $prompter, $project, $identityManager, $stringParameterBuilder, $loginManager, $injector, $options, $appStoreService) {
        this.$logger = $logger;
        this.$errors = $errors;
        this.$prompter = $prompter;
        this.$project = $project;
        this.$identityManager = $identityManager;
        this.$stringParameterBuilder = $stringParameterBuilder;
        this.$loginManager = $loginManager;
        this.$injector = $injector;
        this.$options = $options;
        this.$appStoreService = $appStoreService;
        this.allowedParameters = [this.$stringParameterBuilder.createMandatoryParameter("No application specified. Specify an application that is ready for upload in iTunes Connect."),
            new commandParams.StringCommandParameter(this.$injector), new commandParams.StringCommandParameter(this.$injector)];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.$project.capabilities.uploadToAppstore) {
                this.$errors.failWithoutHelp("You cannot upload %s projects to AppStore.", this.$project.projectData.Framework);
            }
            yield this.$loginManager.ensureLoggedIn();
            let application = args[0];
            let userName = args[1];
            let password = args[2];
            if (!application) {
                this.$errors.fail("No application specified. Specify an application that is ready for upload in iTunes Connect.");
            }
            if (!userName) {
                userName = yield getAppleId(this.$prompter);
            }
            if (this.$options.provision) {
                this.$logger.info("Checking provision.");
                let provision = yield this.$identityManager.findProvision(this.$options.provision);
                if (provision.ProvisionType !== constants.ProvisionType.AppStore) {
                    this.$errors.fail("Provision '%s' is of type '%s'. It must be of type AppStore in order to publish your app.", provision.Name, provision.ProvisionType);
                }
            }
            if (!password) {
                password = yield this.$prompter.getPassword("Apple ID password");
            }
            yield this.$appStoreService.upload(userName, password, application);
        });
    }
}
exports.UploadApplicationCommand = UploadApplicationCommand;
$injector.registerCommand("appstore|upload", UploadApplicationCommand);
