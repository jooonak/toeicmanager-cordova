"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const os = require("os");
class DebugCommand {
    constructor($logger, $errors, $hostCapabilities, $loginManager, $serverExtensionsService, $sharedUserSettingsService, $sharedUserSettingsFileService, $processInfo, $project, $winDebuggerService, $hostInfo, $darwinDebuggerService) {
        this.$logger = $logger;
        this.$errors = $errors;
        this.$hostCapabilities = $hostCapabilities;
        this.$loginManager = $loginManager;
        this.$serverExtensionsService = $serverExtensionsService;
        this.$sharedUserSettingsService = $sharedUserSettingsService;
        this.$sharedUserSettingsFileService = $sharedUserSettingsFileService;
        this.$processInfo = $processInfo;
        this.$project = $project;
        this.$winDebuggerService = $winDebuggerService;
        this.$hostInfo = $hostInfo;
        this.$darwinDebuggerService = $darwinDebuggerService;
        this.allowedParameters = [];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$loginManager.ensureLoggedIn();
            yield this.$project.ensureProject();
            yield this.runDebugger();
        });
    }
    canExecute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.$hostCapabilities.capabilities[process.platform].debugToolsSupported) {
                this.$errors.fail("In this version of the Telerik AppBuilder CLI, you cannot run the debug tools on %s. The debug tools for %s will become available in a future release of the Telerik AppBuilder CLI.", process.platform, process.platform);
            }
            return this.$hostInfo.isDarwin ? true : yield this.$winDebuggerService.canRunApplication();
        });
    }
    runDebugger() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.$hostInfo.isWindows) {
                this.$logger.info("Starting debugger...");
                let debuggerPackageName = this.$winDebuggerService.packageName;
                this.debuggerPath = this.$serverExtensionsService.getExtensionPath(debuggerPackageName);
                yield this.$serverExtensionsService.prepareExtension(debuggerPackageName, this.ensureDebuggerIsNotRunning.bind(this));
                yield this.$sharedUserSettingsService.loadUserSettingsFile();
                let debuggerParams = [
                    "--user-settings", this.$sharedUserSettingsFileService.userSettingsFilePath,
                    yield "--app-ids", this.$project.getAppIdentifierForPlatform(this.platform)
                ];
                this.$winDebuggerService.runApplication(this.debuggerPath, debuggerParams);
            }
        });
    }
    ensureDebuggerIsNotRunning() {
        return __awaiter(this, void 0, void 0, function* () {
            let isRunning = yield this.$processInfo.isRunning(this.$winDebuggerService.executableName);
            if (isRunning) {
                this.$errors.failWithoutHelp("AppBuilder Debugger is currently running and cannot be updated." + os.EOL +
                    "Close it and run $ appbuilder debug again.");
            }
        });
    }
}
exports.DebugCommand = DebugCommand;
class DebugAndroidCommand extends DebugCommand {
    constructor($projectConstants, $logger, $errors, $hostCapabilities, $loginManager, $serverExtensionsService, $sharedUserSettingsService, $sharedUserSettingsFileService, $processInfo, $project, $winDebuggerService, $hostInfo, $darwinDebuggerService) {
        super($logger, $errors, $hostCapabilities, $loginManager, $serverExtensionsService, $sharedUserSettingsService, $sharedUserSettingsFileService, $processInfo, $project, $winDebuggerService, $hostInfo, $darwinDebuggerService);
        this.$projectConstants = $projectConstants;
        this.platform = this.$projectConstants.ANDROID_PLATFORM_NAME;
    }
    runDebugger() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("runDebugger").call(this);
            if (!this.$hostInfo.isWindows) {
                yield this.$darwinDebuggerService.debugAndroidApplication(yield this.$project.getAppIdentifierForPlatform(this.platform), this.$project.projectData.Framework);
            }
        });
    }
}
exports.DebugAndroidCommand = DebugAndroidCommand;
$injector.registerCommand("debug|android", DebugAndroidCommand);
class DebugIosCommand extends DebugCommand {
    constructor($logger, $errors, $hostCapabilities, $loginManager, $serverExtensionsService, $sharedUserSettingsService, $sharedUserSettingsFileService, $processInfo, $project, $winDebuggerService, $hostInfo, $darwinDebuggerService) {
        super($logger, $errors, $hostCapabilities, $loginManager, $serverExtensionsService, $sharedUserSettingsService, $sharedUserSettingsFileService, $processInfo, $project, $winDebuggerService, $hostInfo, $darwinDebuggerService);
    }
    runDebugger() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("runDebugger").call(this);
            if (!this.$hostInfo.isWindows) {
                this.$darwinDebuggerService.debugIosApplication(this.$project.projectData.AppIdentifier);
            }
        });
    }
}
exports.DebugIosCommand = DebugIosCommand;
$injector.registerCommand("debug|ios", DebugIosCommand);
