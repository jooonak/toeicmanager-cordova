"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const commonHelpers = require("../common/helpers");
const os_1 = require("os");
const path_1 = require("path");
class SolutionIdCommandParameter {
    constructor($remoteProjectService) {
        this.$remoteProjectService = $remoteProjectService;
        this.mandatory = false;
    }
    validate(validationValue) {
        return __awaiter(this, void 0, void 0, function* () {
            if (validationValue) {
                const { solutionData } = yield this.$remoteProjectService.getSolutionData(validationValue);
                return !!solutionData;
            }
            return false;
        });
    }
}
class CloudListProjectsCommand {
    constructor($logger, $remoteProjectService, $prompter, $options) {
        this.$logger = $logger;
        this.$remoteProjectService = $remoteProjectService;
        this.$prompter = $prompter;
        this.$options = $options;
        this.allowedParameters = [new SolutionIdCommandParameter(this.$remoteProjectService)];
    }
    printList(names, appName) {
        let isProject = !!appName;
        let headers = ["#", `${isProject ? 'Project' : 'App'} name`];
        let data = names.map((name, index) => [(++index).toString(), name]);
        let table = commonHelpers.createTable(headers, data);
        if (isProject) {
            this.$logger.out(`Projects for ${appName} app:`);
        }
        this.$logger.out(table.toString());
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let apps = yield this.$remoteProjectService.getAvailableAppsAndSolutions();
            let slnName = args[0];
            if (!slnName) {
                let appDisplayNames = apps.map(app => app.colorizedDisplayName);
                if (this.$options.all || !commonHelpers.isInteractive() || appDisplayNames.length === 1) {
                    this.printList(appDisplayNames);
                    return;
                }
                else {
                    slnName = yield this.$prompter.promptForChoice("Select solution for which to list projects:", appDisplayNames);
                }
            }
            let projects = (yield this.$remoteProjectService.getProjectsForSolution(slnName)).map(proj => proj.Name);
            this.printList(projects, slnName);
        });
    }
}
exports.CloudListProjectsCommand = CloudListProjectsCommand;
$injector.registerCommand("cloud|*list", CloudListProjectsCommand);
class CloudExportProjectsCommand {
    constructor($errors, $remoteProjectService, $cloudProjectsService, $project) {
        this.$errors = $errors;
        this.$remoteProjectService = $remoteProjectService;
        this.$cloudProjectsService = $cloudProjectsService;
        this.$project = $project;
        this._isCloudToLocalExport = true;
        this.allowedParameters = [];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const solutionProjectInfo = yield this.$cloudProjectsService.getSolutionProjectInfo({
                projectName: args[1],
                solutionName: args[0],
                enableExportWholeSolution: true
            });
            if (solutionProjectInfo.projectName) {
                yield this.$remoteProjectService.exportProject(solutionProjectInfo.solutionName, solutionProjectInfo.projectName);
            }
            else {
                yield this.$remoteProjectService.exportSolution(solutionProjectInfo.solutionName);
            }
        });
    }
    canExecute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let solutionNames = (yield this.$remoteProjectService.getAvailableAppsAndSolutions()).map(sln => sln.colorizedDisplayName);
            if (!solutionNames || !solutionNames.length) {
                this.$errors.failWithoutHelp("You do not have any projects in the cloud.");
            }
            if (this._isCloudToLocalExport && this.$project.projectData) {
                this.$errors.failWithoutHelp("Cannot create project in this location because the specified directory is part of an existing project. Switch to or specify another location and try again.");
            }
            if (args && args.length) {
                if (args.length > 2) {
                    this.$errors.fail("This command accepts maximum two parameters - solution name and project name.");
                }
                if (!this._isCloudToLocalExport && !commonHelpers.isInteractive() && (!args[0] || !args[1])) {
                    this.$errors.fail("Running this command in non-interactive mode requires both parameters - solution name and project name.");
                }
                let slnName = args[0];
                if (args[1]) {
                    yield this.$remoteProjectService.getProjectName(slnName, args[1]);
                }
                else {
                    let projectNames = (yield this.$remoteProjectService.getProjectsForSolution(slnName)).map(sln => sln.Name);
                    if (!projectNames.length) {
                        this.$errors.failWithoutHelp(`Solution ${slnName} does not have any projects.`);
                    }
                }
            }
            else if (!commonHelpers.isInteractive()) {
                this.$errors.fail("When console is not interactive, you have to provide at least one argument.");
            }
            return true;
        });
    }
}
exports.CloudExportProjectsCommand = CloudExportProjectsCommand;
$injector.registerCommand("cloud|export", CloudExportProjectsCommand);
class ExportCommand extends CloudExportProjectsCommand {
    constructor($project, $errors, $remoteProjectService, $cloudProjectsService, $server, $logger, $httpClient, $fs, $progressIndicator, $options) {
        super($errors, $remoteProjectService, $cloudProjectsService, $project);
        this.$errors = $errors;
        this.$remoteProjectService = $remoteProjectService;
        this.$cloudProjectsService = $cloudProjectsService;
        this.$server = $server;
        this.$logger = $logger;
        this.$httpClient = $httpClient;
        this.$fs = $fs;
        this.$progressIndicator = $progressIndicator;
        this.$options = $options;
        this.allowedParameters = [];
        this._isCloudToLocalExport = false;
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const solutionProjectInfo = yield this.$cloudProjectsService.getSolutionProjectInfo({
                projectName: args[1],
                solutionName: args[0],
                forceChooseProject: true
            });
            const properties = {
                Framework: solutionProjectInfo.framework,
                AcceptResults: "Url;LocalPath"
            };
            this.$logger.info("Exporting project...");
            let downloadPath = path_1.resolve(this.$options.path || ".");
            const downloadPathExists = this.$fs.exists(downloadPath);
            let downloadPathIsDirectory = true;
            if (downloadPathExists) {
                downloadPathIsDirectory = this.$fs.getFsStats(downloadPath).isDirectory();
                if (!downloadPathIsDirectory) {
                    this.$errors.failWithoutHelp(`Cannot download result package in ${downloadPath} as it already exists.`);
                }
            }
            const exportPromise = this.$server.appsBuild.exportProject(solutionProjectInfo.id, solutionProjectInfo.projectName, { Properties: properties, Targets: [] });
            const response = yield this.$progressIndicator.showProgressIndicator(exportPromise, 2000);
            if (response.Errors.length) {
                this.$errors.failWithoutHelp(`Export errors:${os_1.EOL}${response.Errors.map(e => e.Message).join(os_1.EOL)}`);
            }
            else {
                const buildItem = response.ResultsByTarget["Build"].Items[0];
                const downloadUrl = buildItem.FullPath;
                if (!downloadPathExists || downloadPathIsDirectory) {
                    if (path_1.extname(downloadPath)) {
                        this.$fs.ensureDirectoryExists(path_1.dirname(downloadPath));
                    }
                    else {
                        this.$fs.ensureDirectoryExists(downloadPath);
                        let resultFileName = buildItem.Filename;
                        if (path_1.extname(resultFileName) === "") {
                            resultFileName += ".zip";
                        }
                        downloadPath = path_1.join(downloadPath, resultFileName);
                    }
                }
                this.$logger.info(`Downloading ${buildItem.Filename} to ${downloadPath}...`);
                const targetFile = this.$fs.createWriteStream(downloadPath);
                try {
                    yield this.$httpClient.httpRequest({
                        url: downloadUrl,
                        pipeTo: targetFile
                    });
                }
                catch (ex) {
                    this.$logger.trace("Downloading failed. Exception: ", ex);
                    this.$fs.deleteFile(targetFile);
                }
            }
        });
    }
}
exports.ExportCommand = ExportCommand;
$injector.registerCommand("export", ExportCommand);
