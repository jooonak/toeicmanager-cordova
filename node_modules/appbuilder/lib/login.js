"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const url = require("url");
const helpers = require("./helpers");
const querystring = require("querystring");
const cookielib = require("cookie");
class UserDataStore {
    constructor($fs, $config, $logger, $options, $injector) {
        this.$fs = $fs;
        this.$config = $config;
        this.$logger = $logger;
        this.$options = $options;
        this.$injector = $injector;
    }
    hasCookie() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.getCookies();
                return true;
            }
            catch (err) {
                return false;
            }
        });
    }
    getCookies() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.readAndCache(this.getCookieFilePath(), () => this.cookies, (value) => this.cookies = JSON.parse(value));
        });
    }
    getUser() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.readAndCache(this.getUserStateFilePath(), () => this.user, (value) => this.user = JSON.parse(value));
        });
    }
    setCookies(cookies) {
        this.cookies = cookies;
        if (this.cookies) {
            return this.$fs.writeFile(this.getCookieFilePath(), JSON.stringify(this.cookies));
        }
        else {
            return this.$fs.deleteFile(this.getCookieFilePath());
        }
    }
    parseAndSetCookies(setCookieHeader, cookies) {
        cookies = cookies || {};
        _.each(setCookieHeader, (cookieStr) => {
            let parsed = cookielib.parse(cookieStr);
            _.each(Object.keys(parsed), (key) => {
                this.$logger.debug("Stored cookie %s=%s", key, parsed[key]);
                cookies[key] = parsed[key];
            });
        });
        return this.setCookies(cookies);
    }
    setUser(user) {
        return __awaiter(this, void 0, void 0, function* () {
            this.user = user;
            if (user) {
                this.$fs.writeJson(this.getUserStateFilePath(), user);
                yield this.trackTenantInformation(user);
            }
            else {
                this.$fs.deleteFile(this.getUserStateFilePath());
            }
        });
    }
    clearLoginData() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setCookies(null);
            yield this.setUser(null);
        });
    }
    checkCookieExists(sourceFile, getter) {
        return __awaiter(this, void 0, void 0, function* () {
            return (getter() || this.$fs.exists(sourceFile));
        });
    }
    readAndCache(sourceFile, getter, setter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!getter()) {
                if (!(yield this.checkCookieExists(sourceFile, getter))) {
                    throw new Error("Not logged in.");
                }
                let contents = this.$fs.readText(sourceFile);
                try {
                    setter(contents);
                }
                catch (err) {
                    this.$logger.debug("Error while reading user data file '%s':\n%s\n\nContents:\n%s", sourceFile, err.toString(), contents);
                    yield this.clearLoginData();
                    throw new Error("Not logged in.");
                }
            }
            return getter();
        });
    }
    getCookieFilePath() {
        return path.join(this.$options.profileDir, this.$config.AB_SERVER + ".cookie");
    }
    getUserStateFilePath() {
        return path.join(this.$options.profileDir, this.$config.AB_SERVER + ".user");
    }
    trackTenantInformation(userData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (userData && userData.tenant) {
                let tenantEdition = userData.tenant.editionType || "no-edition";
                let $analyticsService = this.$injector.resolve("analyticsService");
                yield $analyticsService.track("UserTenant", tenantEdition);
            }
        });
    }
}
exports.UserDataStore = UserDataStore;
$injector.register("userDataStore", UserDataStore);
class LoginManager {
    constructor($logger, $config, $fs, $userDataStore, $opener, $server, $commandsService, $sharedUserSettingsFileService, $httpServer, $httpClient, $options) {
        this.$logger = $logger;
        this.$config = $config;
        this.$fs = $fs;
        this.$userDataStore = $userDataStore;
        this.$opener = $opener;
        this.$server = $server;
        this.$commandsService = $commandsService;
        this.$sharedUserSettingsFileService = $sharedUserSettingsFileService;
        this.$httpServer = $httpServer;
        this.$httpClient = $httpClient;
        this.$options = $options;
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            this.$logger.info("Logging out...");
            yield this.localLogout();
            let logoutUrl = `${this.$config.AB_SERVER_PROTO}://${this.$config.AB_SERVER}/appbuilder/Mist/Logout`;
            this.$logger.debug("Logout URL is '%s'", logoutUrl);
            this.$opener.open(logoutUrl);
            this.$logger.info("Logout completed.");
        });
    }
    localLogout() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$userDataStore.clearLoginData();
            this.$sharedUserSettingsFileService.deleteUserSettingsFile();
        });
    }
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.localLogout();
            yield this.doLogin();
        });
    }
    isLoggedIn() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.$userDataStore.hasCookie();
        });
    }
    ensureLoggedIn() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.isLoggedIn())) {
                yield this.doLogin();
            }
        });
    }
    doLogin() {
        return __awaiter(this, void 0, void 0, function* () {
            this.$fs.createDirectory(this.$options.profileDir);
            yield this.loginInBrowser();
            this.$logger.info("Login completed.");
            yield this.$commandsService.tryExecuteCommand("user", []);
        });
    }
    serveLoginFile(relPath) {
        return this.$httpServer.serveFile(path.join(__dirname, "../resources/login", relPath));
    }
    loginInBrowser() {
        return __awaiter(this, void 0, void 0, function* () {
            let timeoutID = undefined;
            let authCompleteResolveAction;
            let isResolved = false;
            this.$logger.info("Launching login page in browser.");
            let loginUrl;
            let localhostServer = this.$httpServer.createServer({
                routes: {
                    "/": (request, response) => {
                        this.$logger.debug("Login complete: " + request.url);
                        let parsedUrl = url.parse(request.url, true);
                        let cookieData = parsedUrl.query.cookies;
                        if (cookieData) {
                            this.serveLoginFile("end.html")(request, response);
                            localhostServer.close();
                            isResolved = true;
                            authCompleteResolveAction(cookieData);
                        }
                        else {
                            this.$httpServer.redirect(response, loginUrl);
                        }
                    }
                }
            });
            localhostServer.listen(0);
            yield this.$fs.futureFromEvent(localhostServer, "listening");
            let authComplete = new Promise((resolve, reject) => {
                authCompleteResolveAction = resolve;
                let port = localhostServer.address().port;
                loginUrl = `${this.$config.AB_SERVER_PROTO}://${this.$config.AB_SERVER}/appbuilder/Mist/ClientLogin?port=${port}&client_name=AppBuilderCLI`;
                this.$logger.debug("Login URL is '%s'", loginUrl);
                this.$opener.open(loginUrl);
                if (!helpers.isInteractive()) {
                    let timeout = this.$options.hasOwnProperty("timeout")
                        ? +this.$options.timeout
                        : LoginManager.DEFAULT_NONINTERACTIVE_LOGIN_TIMEOUT_MS;
                    if (timeout > 0) {
                        timeoutID = setTimeout(() => {
                            if (!isResolved) {
                                this.$logger.debug("Aborting login procedure due to inactivity.");
                                process.exit();
                            }
                        }, timeout);
                    }
                }
            });
            let cookieData = yield authComplete;
            if (timeoutID !== undefined) {
                clearTimeout(timeoutID);
            }
            let cookies = JSON.parse(cookieData);
            this.$userDataStore.setCookies(cookies);
            let userData = yield this.$server.authentication.getLoggedInUser();
            yield this.$userDataStore.setUser(userData);
            return userData;
        });
    }
    telerikLogin(user, password) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.$httpClient.httpRequest({
                method: "POST",
                url: `${this.$config.AB_SERVER_PROTO}://${this.$config.AB_SERVER}/appbuilder/Mist/Authentication/Login`,
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                body: querystring.stringify({ userName: user, password: password })
            });
            let cookies = response.headers["set-cookie"];
            if (cookies) {
                this.$userDataStore.parseAndSetCookies(cookies);
                let userData = yield this.$server.authentication.getLoggedInUser();
                yield this.$userDataStore.setUser(userData);
            }
        });
    }
}
LoginManager.DEFAULT_NONINTERACTIVE_LOGIN_TIMEOUT_MS = 15 * 60 * 1000;
exports.LoginManager = LoginManager;
$injector.register("loginManager", LoginManager);
class TelerikLoginCommand {
    constructor($loginManager, $stringParameterBuilder) {
        this.$loginManager = $loginManager;
        this.$stringParameterBuilder = $stringParameterBuilder;
        this.allowedParameters = [
            this.$stringParameterBuilder.createMandatoryParameter("Missing user name or password."),
            this.$stringParameterBuilder.createMandatoryParameter("Missing user name or password.")
        ];
        this.disableAnalytics = true;
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$loginManager.telerikLogin(args[0], args[1]);
        });
    }
}
exports.TelerikLoginCommand = TelerikLoginCommand;
$injector.registerCommand("dev-telerik-login", TelerikLoginCommand);
