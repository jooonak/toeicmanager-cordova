"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const util = require("util");
const querystring = require("querystring");
const path = require("path");
const os_1 = require("os");
const plist = require("plist");
const iOSDeploymentValidatorLib = require("../validators/ios-deployment-validator");
const constants = require("../common/constants");
const minimatch = require("minimatch");
class BuildService {
    constructor($config, $clipboardService, $staticConfig, $logger, $errors, $server, $project, $fs, $injector, $identityManager, $loginManager, $opener, $qr, $projectMigrationService, $jsonSchemaValidator, $mobileHelper, $progressIndicator, $options, $deviceAppDataFactory, $devicePlatformsConstants, $projectConstants, $httpClient) {
        this.$config = $config;
        this.$clipboardService = $clipboardService;
        this.$staticConfig = $staticConfig;
        this.$logger = $logger;
        this.$errors = $errors;
        this.$server = $server;
        this.$project = $project;
        this.$fs = $fs;
        this.$injector = $injector;
        this.$identityManager = $identityManager;
        this.$loginManager = $loginManager;
        this.$opener = $opener;
        this.$qr = $qr;
        this.$projectMigrationService = $projectMigrationService;
        this.$jsonSchemaValidator = $jsonSchemaValidator;
        this.$mobileHelper = $mobileHelper;
        this.$progressIndicator = $progressIndicator;
        this.$options = $options;
        this.$deviceAppDataFactory = $deviceAppDataFactory;
        this.$devicePlatformsConstants = $devicePlatformsConstants;
        this.$projectConstants = $projectConstants;
        this.$httpClient = $httpClient;
    }
    getDownloadUrl(urlKind, liveSyncToken, packageDef, projectConfiguration) {
        return __awaiter(this, void 0, void 0, function* () {
            urlKind = urlKind.toLowerCase();
            if (urlKind !== "manifest" && urlKind !== "package") {
                throw new Error("urlKind must be either 'manifest' or 'package'");
            }
            let fullDownloadPath;
            if (packageDef.format === BuildService.ACCEPT_RESULT_URL && urlKind === "package") {
                fullDownloadPath = packageDef.url;
            }
            else {
                fullDownloadPath = util.format("%s://%s/appbuilder/Mist/MobilePackage/%s?packagePath=%s&token=%s&projectConfiguration=%s", this.$config.AB_SERVER_PROTO, this.$config.AB_SERVER, urlKind, querystring.escape(querystring.escape(packageDef.relativePath)), querystring.escape(querystring.escape(liveSyncToken)), projectConfiguration);
            }
            this.$logger.debug("Minifying LiveSync URL '%s'", fullDownloadPath);
            let url = yield this.$server.cordova.getLiveSyncUrl(fullDownloadPath);
            if (urlKind === "manifest") {
                url = "itms-services://?action=download-manifest&amp;url=" + querystring.escape(url);
            }
            this.$logger.debug("Device install URL '%s'", url);
            return url;
        });
    }
    buildProject(solutionName, projectName, solutionSpace, buildProperties) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$logger.info("Building project %s/%s (%s)", solutionName, projectName, solutionSpace);
            this.$logger.printInfoMessageOnSameLine("Building...");
            yield this.$server.projects.setProjectProperty(solutionName, projectName, buildProperties.Configuration, { AppIdentifier: buildProperties.AppIdentifier });
            let liveSyncToken = yield this.$server.cordova.getLiveSyncToken(solutionName, projectName);
            buildProperties.LiveSyncToken = liveSyncToken;
            let buildProjectPromise = this.$server.build.buildProject(solutionName, projectName, { Properties: buildProperties, Targets: [] });
            let body = yield this.$progressIndicator.showProgressIndicator(buildProjectPromise, 2000);
            let buildResults = body.ResultsByTarget["Build"].Items.map((buildResult) => {
                let fullPath = buildResult.FullPath.replace(/\\/g, "/");
                let solutionPath = util.format("%s/%s", projectName, fullPath);
                let fileExtension = buildResult.Extension;
                let indexOfQueryString = fileExtension.indexOf("?");
                if (indexOfQueryString >= 0) {
                    fileExtension = fileExtension.substring(0, indexOfQueryString);
                }
                let fullFileName = `${buildResult.Filename}${fileExtension}`;
                return {
                    platform: buildResult.Platform,
                    solution: solutionName,
                    solutionPath: solutionPath,
                    relativePath: buildResult.FullPath,
                    disposition: buildResult.Disposition,
                    format: buildResult.Format,
                    url: buildResult.FullPath,
                    fileName: fullFileName,
                    key: buildResult.Key,
                    value: buildResult.Value,
                    architecture: buildResult.Architecture
                };
            });
            return {
                buildResults: buildResults,
                output: body.Output,
                errors: body.Errors.map(error => error.Message)
            };
        });
    }
    requestCloudBuild(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            settings.platform = this.$mobileHelper.normalizePlatformName(settings.platform);
            let projectData = this.$project.projectInformation.configurationSpecificData[settings.projectConfiguration.toLowerCase()] || this.$project.projectData;
            let buildProperties = {
                ProjectConfiguration: settings.projectConfiguration,
                BuildConfiguration: settings.buildConfiguration,
                Platform: settings.platform,
                AppIdentifier: projectData.AppIdentifier,
                ProjectName: projectData.ProjectName,
                Author: projectData.Author,
                Description: projectData.Description,
                FrameworkVersion: projectData.FrameworkVersion,
                BundleVersion: projectData.BundleVersion,
                DeviceOrientations: projectData.DeviceOrientations,
                BuildForiOSSimulator: settings.buildForiOSSimulator || false,
                AcceptResults: `${BuildService.ACCEPT_RESULT_URL};${BuildService.ACCEPT_RESULT_LOCAL_PATH}`
            };
            this.$project.adjustBuildProperties(buildProperties);
            if (settings.platform === "Android") {
                buildProperties.AndroidPermissions = projectData.AndroidPermissions;
                buildProperties.AndroidVersionCode = projectData.AndroidVersionCode;
                buildProperties.AndroidHardwareAcceleration = projectData.AndroidHardwareAcceleration;
                let certificateData;
                if (this.$options.certificate) {
                    certificateData = yield this.$identityManager.findCertificate(this.$options.certificate);
                }
                else if (settings.buildForTAM) {
                    this.$logger.warn("You have not specified certificate to code sign this app. We'll use default debug certificate. " +
                        "Use --certificate option to specify your own certificate. You can check available certificates with '$ appbuilder certificate' command.");
                }
                else if (settings.buildConfiguration === constants.Configurations.Release) {
                    certificateData = yield this.$identityManager.findReleaseCertificate();
                    if (!certificateData) {
                        this.$logger.warn("Cannot find an applicable Google Play certificate to " +
                            "code sign this app. You will not be able to publish this app to " +
                            "Google Play. To create a Google Play certificate, run\n" +
                            "    $ appbuilder certificate create-self-signed");
                    }
                }
                if (certificateData) {
                    if (certificateData.isiOS) {
                        this.$errors.failWithoutHelp("The certificate you have chosen is ineligible for the Android platform.");
                    }
                    buildProperties.AndroidCodesigningIdentity = certificateData.Alias;
                    this.$logger.info("Using certificate '%s'", certificateData.Alias);
                }
                else {
                    buildProperties.AndroidCodesigningIdentity = "";
                }
                let result = yield this.beginBuild(buildProperties);
                return result;
            }
            else if (settings.platform === "iOS") {
                let appIdentifier = projectData.AppIdentifier;
                let configFileContent = this.$project.getConfigFileContent("ios-info");
                if (configFileContent) {
                    let parsed = plist.parse(configFileContent);
                    let cfBundleIdentifier = parsed.CFBundleIdentifier;
                    if (cfBundleIdentifier && cfBundleIdentifier !== BuildService.APPIDENTIFIER_PLACE_HOLDER) {
                        appIdentifier = cfBundleIdentifier;
                    }
                }
                buildProperties.iOSDisplayName = projectData.DisplayName;
                buildProperties.iOSDeviceFamily = projectData.iOSDeviceFamily;
                buildProperties.iOSStatusBarStyle = projectData.iOSStatusBarStyle;
                buildProperties.iOSBackgroundMode = projectData.iOSBackgroundMode;
                let completeAutoselect = (!this.$options.provision && !this.$options.certificate);
                let provisionData;
                if (this.$options.provision) {
                    provisionData = yield this.$identityManager.findProvision(this.$options.provision);
                    if (settings.buildForTAM && provisionData.ProvisionType === constants.ProvisionType.AppStore) {
                        this.$errors.failWithoutHelp("You cannot use AppStore provision for upload in AppManager. Please use Development, AdHoc or Enterprise provision." +
                            "You can check availalbe provisioning profiles by using '$ appbuilder provision' command.");
                    }
                }
                else if (!settings.buildForiOSSimulator) {
                    let deviceIdentifier = settings.device ? settings.device.deviceInfo.identifier : undefined;
                    try {
                        provisionData = yield this.$identityManager.autoselectProvision(appIdentifier, settings.provisionTypes || [constants.ProvisionType.AdHoc], deviceIdentifier);
                    }
                    catch (error) {
                        if (!this.$options.download) {
                            this.$logger.warn("Cannot generate QR code because an applicable AdHoc provisioning profile is not available.");
                            let additionalInfo = error.message.split(os_1.EOL)[1];
                            if (additionalInfo) {
                                this.$logger.warn(additionalInfo);
                            }
                            this.$logger.warn("Attempting to use Development provisioning profile instead.");
                        }
                        provisionData = yield this.$identityManager.autoselectProvision(appIdentifier, [constants.ProvisionType.Development], deviceIdentifier);
                    }
                    this.$options.provision = provisionData.Name;
                }
                this.$logger.info("Using mobile provision '%s'", provisionData ? provisionData.Name : "[No provision]");
                let certificateData;
                if (this.$options.certificate) {
                    certificateData = yield this.$identityManager.findCertificate(this.$options.certificate);
                }
                else if (!settings.buildForiOSSimulator) {
                    certificateData = yield this.$identityManager.autoselectCertificate(provisionData);
                    this.$options.certificate = certificateData.Alias;
                }
                this.$logger.info("Using certificate '%s'", certificateData ? certificateData.Alias : "[No certificate]");
                if (!completeAutoselect) {
                    let iOSDeploymentValidator = this.$injector.resolve(iOSDeploymentValidatorLib.IOSDeploymentValidator, {
                        appIdentifier: appIdentifier,
                        deviceIdentifier: settings.device ? settings.device.deviceInfo.identifier : null
                    });
                    iOSDeploymentValidator.throwIfInvalid(yield { provisionOption: this.$options.provision, certificateOption: this.$options.certificate });
                }
                if (provisionData) {
                    buildProperties.MobileProvisionIdentifier = provisionData.Identifier;
                }
                if (certificateData) {
                    buildProperties.iOSCodesigningIdentity = certificateData.Alias;
                }
                let buildResult = yield this.beginBuild(buildProperties);
                if (provisionData) {
                    buildResult.provisionType = provisionData.ProvisionType;
                }
                return buildResult;
            }
            else if (settings.platform === "WP8") {
                let buildCompanyHubApp = !settings.downloadFiles;
                if (this.$project.projectData.WPSdk === "8.1" && ((this.$options.release && settings.downloadFiles) || settings.buildForTAM)) {
                    this.$logger.warn("Verify that you have configured your project for publishing in the Windows Phone Store. For more information see: %s", settings.buildForTAM ? "http://docs.telerik.com/platform/appbuilder/publishing-your-app/publish-appmanager#prerequisites" :
                        "http://docs.telerik.com/platform/appbuilder/publishing-your-app/distribute-production/publish-wp8#prerequisites");
                }
                if (buildCompanyHubApp) {
                    buildProperties.WP8CompanyHubApp = true;
                    if (settings.showWp8SigningMessage === undefined) {
                        this.$logger.info("The app file will be signed as a Telerik Company Hub app so that it can be" +
                            " deployed using a QR code. Use the --download switch if you want to cable deploy" +
                            " or publish the built app package.");
                    }
                }
                return yield this.beginBuild(buildProperties);
            }
            else {
                this.$logger.fatal("Unknown platform '%s'.", settings.platform);
                return null;
            }
        });
    }
    beginBuild(buildProperties) {
        return __awaiter(this, void 0, void 0, function* () {
            Object.keys(buildProperties).forEach((prop) => {
                if (buildProperties[prop] === undefined) {
                    this.$logger.warn(`Build property '${prop}' is undefined. The property is optional, but you can set it by running '${this.$staticConfig.CLIENT_NAME.toLowerCase()} prop set ${prop} <value>'.`);
                }
                if (_.isArray(buildProperties[prop])) {
                    buildProperties[prop] = buildProperties[prop].join(";");
                }
            });
            let result = yield this.buildProject(this.$project.projectData.ProjectName, this.$project.projectData.ProjectName, this.$staticConfig.SOLUTION_SPACE_NAME, buildProperties);
            if (result.output) {
                let buildLogFilePath = path.join(this.$project.getTempDir(), "build.log");
                this.$fs.writeFile(buildLogFilePath, result.output);
                this.$logger.info("Build log written to '%s'", buildLogFilePath);
            }
            this.$logger.debug(result.buildResults);
            if (result.errors.length) {
                this.$logger.error("Build errors: %s", util.inspect(result.errors));
            }
            return {
                buildProperties: buildProperties,
                packageDefs: result.buildResults
            };
        });
    }
    showQRCodes(packageDefs) {
        if (!packageDefs.length) {
            return;
        }
        let templateFiles = this.$fs.enumerateFilesInDirectorySync(path.join(__dirname, "../../resources/qr"));
        let targetFiles = _.map(templateFiles, (file) => path.join(this.$project.getTempDir(), path.basename(file)));
        _(_.zip(templateFiles, targetFiles)).each(zipped => {
            let srcFile = zipped[0];
            let targetFile = zipped[1];
            this.$logger.debug("Copying '%s' to '%s'", srcFile, targetFile);
            this.$fs.copyFile(srcFile, targetFile);
        });
        let scanFile = _.find(targetFiles, (file) => path.basename(file) === "scan.html");
        let htmlTemplateContents = this.$fs.readText(scanFile);
        htmlTemplateContents = htmlTemplateContents.replace(/\$ApplicationName\$/g, this.$project.projectData.ProjectName)
            .replace(/\$Packages\$/g, JSON.stringify(packageDefs));
        this.$fs.writeFile(scanFile, htmlTemplateContents);
        this.$logger.debug("Updated scan.html");
        this.$opener.open(scanFile);
    }
    build(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$project.ensureProject();
            this.$jsonSchemaValidator.validate(this.$project.projectData);
            this.$jsonSchemaValidator.validateWithBuildSchema(this.$project.projectData, settings.platform);
            settings.projectConfiguration = settings.projectConfiguration || this.$project.getProjectConfiguration();
            settings.buildConfiguration = settings.buildConfiguration || this.$project.getBuildConfiguration();
            this.$logger.info("Building project for platform '%s', project configuration '%s', build configuration '%s'", settings.platform, settings.projectConfiguration, settings.buildConfiguration);
            this.$project.ensureAllPlatformAssets();
            yield this.$projectMigrationService.migrateTypeScriptProject();
            yield this.$project.importProject();
            let buildResult = yield this.requestCloudBuild(settings);
            let packageDefs = buildResult.packageDefs;
            if ((buildResult.provisionType === constants.ProvisionType.Development || buildResult.provisionType === constants.ProvisionType.AppStore) && !settings.downloadFiles && !settings.buildForTAM) {
                this.$logger.info("Package built with '%s' provision type. Downloading package, instead of generating QR code.", buildResult.provisionType);
                this.$logger.info("Deploy manually to your device using iTunes.");
                settings.showQrCodes = false;
                settings.downloadFiles = true;
            }
            if (!packageDefs.length) {
                this.$errors.fail("Build failed. For more information read the build log.");
            }
            if (settings.showQrCodes) {
                let urlKind = buildResult.provisionType === constants.ProvisionType.AdHoc ? "manifest" : "package";
                let liveSyncToken = buildResult.buildProperties.LiveSyncToken;
                let appPackages = _.filter(packageDefs, (def) => !def.disposition || def.disposition === "BuildResult");
                let packageDownloadViewModels = yield Promise.all(_.map(appPackages, (def) => __awaiter(this, void 0, void 0, function* () {
                    let downloadUrl = yield this.getDownloadUrl(urlKind, liveSyncToken, def, settings.projectConfiguration);
                    let packageUrl = (urlKind !== "package")
                        ? yield this.getDownloadUrl("package", liveSyncToken, def, settings.projectConfiguration)
                        : downloadUrl;
                    this.$logger.debug("Download URL is '%s'", packageUrl);
                    return {
                        qrUrl: downloadUrl,
                        qrImageData: yield this.getQrImageData(downloadUrl),
                        packageUrls: [{
                                packageUrl: packageUrl,
                                downloadText: "Download"
                            }],
                        instruction: util.format("Scan the QR code below to install %s to %s", def.solution, def.platform),
                    };
                })));
                if (settings.platform === "WP8") {
                    let aetUrl = util.format("%s://%s/%s", this.$config.AB_SERVER_PROTO, this.$config.AB_SERVER, BuildService.WinPhoneAetPath);
                    let aetDef = {
                        qrUrl: aetUrl,
                        qrImageData: yield this.getQrImageData(aetUrl),
                        packageUrls: [{ packageUrl: aetUrl, downloadText: "Download application enrollment token" }],
                        instruction: util.format("Scan the QR code below to install the Telerik Company Hub App application enrollment token (AET)")
                    };
                    packageDownloadViewModels.push(aetDef);
                }
                this.showQRCodes(packageDownloadViewModels);
            }
            if (settings.downloadFiles) {
                yield Promise.all(_.map(packageDefs, (pkg) => __awaiter(this, void 0, void 0, function* () {
                    let targetFileName;
                    if (pkg.disposition === this.$projectConstants.ADDITIONAL_FILE_DISPOSITION) {
                        targetFileName = path.join(this.$project.getProjectDir(), this.$projectConstants.ADDITIONAL_FILES_DIRECTORY, pkg.fileName);
                    }
                    else if (pkg.disposition === this.$projectConstants.BUILD_RESULT_DISPOSITION) {
                        targetFileName = settings.downloadedFilePath
                            || path.join(this.$project.getProjectDir(), pkg.fileName);
                    }
                    else {
                        return;
                    }
                    this.$logger.info("Downloading file '%s/%s' into '%s'", pkg.solution, pkg.fileName, targetFileName);
                    let targetFile = this.$fs.createWriteStream(targetFileName);
                    if (pkg.format === BuildService.ACCEPT_RESULT_URL) {
                        yield this.$httpClient.httpRequest({
                            url: pkg.url,
                            pipeTo: targetFile
                        });
                    }
                    else {
                        yield this.$server.filesystem.getContent(pkg.solution, pkg.solutionPath, targetFile);
                    }
                    this.$logger.info("Download completed: %s", targetFileName);
                    pkg.localFile = targetFileName;
                })));
            }
            return packageDefs;
        });
    }
    buildForDeploy(platform, downloadedFilePath, buildForiOSSimulator, device) {
        return __awaiter(this, void 0, void 0, function* () {
            platform = this.$mobileHelper.validatePlatformName(platform);
            yield this.$project.ensureProject();
            let buildResult = yield this.build({
                platform: platform,
                downloadFiles: true,
                downloadedFilePath: downloadedFilePath,
                buildForiOSSimulator: buildForiOSSimulator,
                device: device
            });
            let packageName = _.filter(buildResult, (def) => !def.disposition || def.disposition === "BuildResult")[0].localFile;
            let metadata = _.filter(buildResult, (def) => def.disposition === "BuildResultMetadata" && def.key === "AppIdentifier")[0];
            let appIdentifier = metadata ? metadata.value : this.$project.projectData.AppIdentifier;
            return {
                packageName,
                appIdentifier
            };
        });
    }
    buildForiOSSimulator(downloadedFilePath, device) {
        return __awaiter(this, void 0, void 0, function* () {
            let packageFile = (yield this.buildForDeploy(this.$devicePlatformsConstants.iOS, downloadedFilePath, true, device)).packageName;
            let tempDir = this.$project.getTempDir("emulatorFiles");
            yield this.$fs.unzip(packageFile, tempDir);
            let appFilePath = path.join(tempDir, this.$fs.readDirectory(tempDir).filter(minimatch.filter("*.app"))[0]);
            return appFilePath;
        });
    }
    executeBuild(platform, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$project.ensureProject();
            if (!this.$project.capabilities.build) {
                this.$errors.failWithoutHelp("This command is not applicable to %s projects ", this.$project.projectData.Framework);
            }
            yield this.executeBuildCore(platform, opts);
        });
    }
    executeBuildCore(platform, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            platform = this.$mobileHelper.validatePlatformName(platform);
            if (this.$options.saveTo) {
                this.$options.download = true;
            }
            if (this.$options.download && this.$options.companion) {
                this.$errors.fail("Cannot specify both --download (or --save-to) and --companion options.");
            }
            yield this.$loginManager.ensureLoggedIn();
            this.$project.checkSdkVersions(platform);
            if (this.$options.companion) {
                yield this.deployToIon(platform);
            }
            else {
                if (!this.$mobileHelper.getPlatformCapabilities(platform).wirelessDeploy && !this.$options.download) {
                    this.$logger.info("Wireless deploying is not supported for platform %s. The package will be downloaded after build.", platform);
                    this.$options.download = true;
                }
                yield this.build({
                    platform: platform,
                    showQrCodes: !this.$options.download,
                    downloadFiles: this.$options.download,
                    downloadedFilePath: this.$options.saveTo,
                    buildForiOSSimulator: opts && opts.buildForiOSSimulator
                });
            }
        });
    }
    deployToIon(platform) {
        return __awaiter(this, void 0, void 0, function* () {
            platform = this.$mobileHelper.validatePlatformName(platform);
            if (!this.$mobileHelper.getPlatformCapabilities(platform).companion) {
                this.$errors.fail("The companion app is not available on %s.", platform);
            }
            this.$logger.info("Deploying to AppBuilder companion app.");
            yield this.$project.importProject();
            let appIdentifier = yield this.$deviceAppDataFactory.create(this.$project.getAppIdentifierForPlatform(platform), platform, null);
            let liveSyncToken = yield this.$server.cordova.getLiveSyncToken(this.$project.projectData.ProjectName, this.$project.projectData.ProjectName);
            let hostPart = util.format("%s://%s/appbuilder", this.$config.AB_SERVER_PROTO, this.$config.AB_SERVER);
            let fullDownloadPath = util.format(appIdentifier.liveSyncFormat, appIdentifier.encodeLiveSyncHostUri(hostPart), querystring.escape(liveSyncToken), querystring.escape(this.$project.projectData.ProjectName), this.$project.getProjectConfiguration());
            this.$logger.debug("Using LiveSync URL for Ion: %s", fullDownloadPath);
            this.showQRCodes([{
                    instruction: util.format("Scan the QR code below to load %s in the AppBuilder companion app for %s", this.$project.projectData.ProjectName, platform),
                    qrImageData: yield this.getQrImageData(fullDownloadPath)
                }]);
        });
    }
    getQrImageData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const qrImageData = yield this.$qr.generateDataUri(data);
            if (!qrImageData) {
                yield this.$clipboardService.copy(data);
                this.$errors.failWithoutHelp(`Your project name is too long to generate QR Code for its link. The application url ${data.green} ${"is copied to your clipboard and you can use online QR Code generator to generate QR Code for you.".red}.`);
            }
            return qrImageData;
        });
    }
}
BuildService.WinPhoneAetPath = "appbuilder/install/WinPhoneAet";
BuildService.APPIDENTIFIER_PLACE_HOLDER = "$AppIdentifier$";
BuildService.ACCEPT_RESULT_URL = "Url";
BuildService.ACCEPT_RESULT_LOCAL_PATH = "LocalPath";
exports.BuildService = BuildService;
$injector.register("buildService", BuildService);
