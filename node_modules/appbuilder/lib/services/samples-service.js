"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const util = require("util");
const os_1 = require("os");
const temp = require("temp");
const constants_1 = require("../common/constants");
class Sample {
    constructor(name, displayName, description, zipUrl, githubUrl, type) {
        this.name = name;
        this.displayName = displayName;
        this.description = description;
        this.zipUrl = zipUrl;
        this.githubUrl = githubUrl;
        this.type = type;
    }
}
class SamplesService {
    constructor($logger, $errors, $fs, $httpClient, $staticConfig, $options, $typeScriptService, $injector) {
        this.$logger = $logger;
        this.$errors = $errors;
        this.$fs = $fs;
        this.$httpClient = $httpClient;
        this.$staticConfig = $staticConfig;
        this.$options = $options;
        this.$typeScriptService = $typeScriptService;
        this.$injector = $injector;
        this.sampleCategories = [
            { id: "demo-app", regEx: /(^|\s)demo($|\s)/i, name: "Demo Applications", order: 1, matchOrder: 2 },
            { id: "core-api", regEx: /(^|\s)core($|\s)/i, name: "Core APIs", order: 2, matchOrder: 3 },
            { id: "advanced", regEx: /\w?/, name: "Advanced APIs", order: 3, matchOrder: 4 }
        ];
    }
    get $analyticsService() {
        return this.$injector.resolve("analyticsService");
    }
    printSamplesInformation(framework) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$logger.info("You can choose a sample from the following: %s", os_1.EOL);
            if (framework) {
                yield this.printSamplesInformationForFramework(framework);
            }
            else {
                let targetFrameworkIdentifiers = _.values(constants_1.TARGET_FRAMEWORK_IDENTIFIERS);
                for (let frameworkIdentifier of targetFrameworkIdentifiers) {
                    yield this.printSamplesInformationForFramework(frameworkIdentifier);
                }
            }
        });
    }
    printSamplesInformationForFramework(framework) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$logger.info("%s samples:%s=========================%s", framework, os_1.EOL, os_1.EOL);
            this.$logger.info((yield this.getSamplesInformation(framework)) + os_1.EOL + os_1.EOL);
        });
    }
    cloneSample(sampleName) {
        return __awaiter(this, void 0, void 0, function* () {
            let cloneTo = this.$options.path || sampleName;
            if (this.$fs.exists(cloneTo) && this.$fs.readDirectory(cloneTo).length > 0) {
                this.$errors.fail("Cannot clone sample in the specified path. The directory %s is not empty. Specify an empty target directory and try again.", path.resolve(cloneTo));
            }
            let sampleNameLower = sampleName.toLowerCase();
            let sample = _.find(yield this.getSamples(), (_sample) => _sample.name.toLowerCase() === sampleNameLower);
            if (!sample) {
                this.$errors.fail("There is no sample named '%s'.", sampleName);
            }
            this.$logger.info("Cloning sample from GitHub...");
            let tempDir;
            try {
                temp.track();
                tempDir = temp.mkdirSync("appbuilderSamples");
                let sampleFilePath = path.join(tempDir, sampleName);
                let sampleFile = this.$fs.createWriteStream(sampleFilePath);
                let fileEnd = this.$fs.futureFromEvent(sampleFile, "finish");
                let accessToken = this.getGitHubAccessTokenQueryParameter("?");
                yield this.$httpClient.httpRequest({ url: `${sample.zipUrl}${accessToken}`, pipeTo: sampleFile });
                yield fileEnd;
                yield this.$fs.unzip(sampleFilePath, tempDir);
                let projectFile = _.first(this.$fs.enumerateFilesInDirectorySync(tempDir, (filepath, stat) => stat.isDirectory() || path.basename(filepath) === this.$staticConfig.PROJECT_FILE_NAME));
                let projectDir = path.dirname(projectFile);
                let files = this.$fs.enumerateFilesInDirectorySync(projectDir);
                _.each(files, file => {
                    let targetDir = path.join(cloneTo, file.replace(projectDir, ""));
                    this.$fs.copyFile(file, targetDir);
                });
            }
            finally {
                let featureValue = sample.name;
                if (this.$typeScriptService.isTypeScriptProject(tempDir)) {
                    featureValue = `${featureValue}-TS`;
                }
                yield this.$analyticsService.track("CreateProjectFromSample", featureValue);
                try {
                    this.$fs.deleteDirectory(tempDir);
                }
                catch (error) {
                    this.$logger.debug(error);
                }
            }
        });
    }
    getSamplesInformation(framework) {
        return __awaiter(this, void 0, void 0, function* () {
            let availableSamples;
            try {
                availableSamples = yield this.getSamples(framework);
            }
            catch (error) {
                return SamplesService.SAMPLES_PULL_FAILED_MESSAGE;
            }
            let sortedCategories = _.sortBy(this.sampleCategories, category => category.order);
            let categories = _.map(sortedCategories, category => {
                return {
                    name: category.name,
                    samples: _.filter(availableSamples, sample => sample.type === category.id)
                };
            });
            let outputLines = [];
            _.each(categories, category => {
                if (category.samples.length === 0) {
                    return;
                }
                outputLines.push(util.format("   %s:%s   ======================", category.name, os_1.EOL));
                _.each(category.samples, (sample) => {
                    let nameRow = util.format("      Sample: %s", sample.displayName);
                    let descriptionRow = util.format("      Description: %s", sample.description);
                    let gitClone = util.format("      Github repository page: %s", sample.githubUrl);
                    let cloneCommand = util.format("      Clone command: $ appbuilder sample clone %s", sample.name);
                    outputLines.push([nameRow, descriptionRow, gitClone, cloneCommand].join(os_1.EOL));
                });
            });
            return outputLines.join(os_1.EOL + os_1.EOL);
        });
    }
    getRegExpForFramework(framework) {
        framework = framework || "";
        switch (framework.toLowerCase()) {
            case constants_1.TARGET_FRAMEWORK_IDENTIFIERS.NativeScript.toLowerCase():
                return SamplesService.GITHUB_NS_SAMPLES_REGEX;
            case constants_1.TARGET_FRAMEWORK_IDENTIFIERS.Cordova.toLowerCase():
                return SamplesService.GITHUB_CORDOVA_SAMPLES_REGEX;
            default:
                return SamplesService.GITHUB_REGEX;
        }
    }
    getSamples(framework) {
        return __awaiter(this, void 0, void 0, function* () {
            let regex = this.getRegExpForFramework(framework);
            let repos = _.filter(yield this.getIceniumRepositories(), (repo) => regex.test(repo.clone_url) && !repo[SamplesService.REMOTE_LOCK_STATE_PRIVATE]);
            let samples = _.map(repos, (repo) => {
                return new Sample(repo.name.replace(SamplesService.NAME_PREFIX_REMOVAL_REGEX, ""), repo.name.replace(SamplesService.NAME_FORMAT_REGEX, " ").trim(), repo.description, repo.url + "/zipball/" + repo.default_branch, repo.html_url, this.getTypeFromDescription(repo.description));
            });
            let sortedSamples = _.sortBy(samples, sample => sample.displayName);
            return sortedSamples;
        });
    }
    getPagedResult(gitHubEndpointUrl, page) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let requestUrl = gitHubEndpointUrl + "&page=" + page.toString();
                let accessToken = this.getGitHubAccessTokenQueryParameter("&");
                let result = JSON.parse((yield this.$httpClient.httpRequest(`${requestUrl}${accessToken}`)).body);
                return result;
            }
            catch (error) {
                this.$logger.debug(error);
                this.$errors.fail(SamplesService.SAMPLES_PULL_FAILED_MESSAGE);
            }
        });
    }
    getIceniumRepositories() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._repos) {
                let gitHubEndpointUrl = SamplesService.GITHUB_ICENIUM_LOCATION_ENDPOINT;
                this._repos = [];
                for (let page = 1;; ++page) {
                    let pagedResult = yield this.getPagedResult(gitHubEndpointUrl, page);
                    if (_.isEmpty(pagedResult)) {
                        break;
                    }
                    this._repos = this._repos.concat(pagedResult);
                }
            }
            return this._repos;
        });
    }
    getTypeFromDescription(description) {
        let sortedCategories = _.sortBy(this.sampleCategories, category => category.matchOrder);
        let matchedCategory = _.find(sortedCategories, category => category.regEx.test(description));
        return matchedCategory ? matchedCategory.id : null;
    }
    getGitHubAccessTokenQueryParameter(queryToken) {
        let accessToken = "";
        let tokenFile = this.$staticConfig.GITHUB_ACCESS_TOKEN_FILEPATH;
        try {
            let content = this.$fs.readFile(tokenFile);
            if (content) {
                accessToken = `${queryToken}access_token=${content}`;
            }
        }
        catch (err) {
            if (err.code !== "ENOENT") {
                this.$logger.trace(`Error happened while trying to open '${tokenFile}'. Error is: ${err}`);
            }
            else {
                this.$logger.trace(`File '${tokenFile}' does not exist. GitHub api calls will be executed without access_token.`);
            }
        }
        return accessToken;
    }
}
SamplesService.GITHUB_ICENIUM_LOCATION_ENDPOINT = "https://api.github.com/orgs/Icenium/repos?per_page=100";
SamplesService.GITHUB_REGEX = /https:\/\/github[.]com\/Icenium\/(?!deprecated-)(sample-|.*?-sample-)[\w\W]+[.]git$/i;
SamplesService.NAME_FORMAT_REGEX = /(nativescript-)?(sample-|-)/gi;
SamplesService.NAME_PREFIX_REMOVAL_REGEX = /sample-/i;
SamplesService.REMOTE_LOCK_STATE_PRIVATE = "private";
SamplesService.SAMPLES_PULL_FAILED_MESSAGE = "Failed to retrieve samples list. Please try again a little bit later.";
SamplesService.GITHUB_CORDOVA_SAMPLES_REGEX = new RegExp("https:\/\/github[.]com\/Icenium\/sample-[\\w\\W]+[.]git$", "i");
SamplesService.GITHUB_NS_SAMPLES_REGEX = new RegExp("https:\/\/github[.]com\/Icenium\/nativescript-sample-[\\w\\W]+[.]git$", "i");
exports.SamplesService = SamplesService;
$injector.register("samplesService", SamplesService);
