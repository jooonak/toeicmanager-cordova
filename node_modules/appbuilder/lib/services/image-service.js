"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const helpers = require("../common/helpers");
const decorators_1 = require("../common/decorators");
const path = require("path");
const temp = require("temp");
class ImageData {
    constructor(FileName, Height, Width) {
        this.FileName = FileName;
        this.Height = Height;
        this.Width = Width;
    }
}
class ImageDefinitionData {
    constructor(Platform, Icons, SplashScreens) {
        this.Platform = Platform;
        this.Icons = Icons;
        this.SplashScreens = SplashScreens;
    }
}
class ImageConstants {
}
ImageConstants.PNG_EXTENSION = '.png';
class ImageService {
    constructor($devicePlatformsConstants, $errors, $fs, $logger, $progressIndicator, $projectConstants, $project, $prompter, $staticConfig, $resources, $server) {
        this.$devicePlatformsConstants = $devicePlatformsConstants;
        this.$errors = $errors;
        this.$fs = $fs;
        this.$logger = $logger;
        this.$progressIndicator = $progressIndicator;
        this.$projectConstants = $projectConstants;
        this.$project = $project;
        this.$prompter = $prompter;
        this.$staticConfig = $staticConfig;
        this.$resources = $resources;
        this.$server = $server;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$project.ensureProject();
            if (!this.$project.capabilities.imageGeneration) {
                this.$errors.failWithoutHelp("This command is not applicable to %s projects ", this.$project.projectData.Framework);
            }
        });
    }
    printDefinitions() {
        let imageDefinitionsFilePath = path.join(this.$staticConfig.APP_RESOURCES_DIR_NAME, this.$projectConstants.IMAGE_DEFINITIONS_FILE_NAME), imageDefinitionsContents = this.$resources.readJson(imageDefinitionsFilePath), table = helpers.createTable(['Platform', 'Icon', 'Splash Screen'], []);
        _.each(imageDefinitionsContents, imageDefinition => {
            if (imageDefinition.Platform === 'WP8' && !this.$project.capabilities.wp8Supported) {
                return;
            }
            let maxLength = Math.max(imageDefinition.Icons.length, imageDefinition.SplashScreens.length);
            for (let i = 0; i < maxLength; ++i) {
                let platformName = i ? '' : imageDefinition.Platform;
                this.pushImageToTable(table, platformName, imageDefinition.Icons[i], imageDefinition.SplashScreens[i]);
            }
            table.push(['', '', '']);
        });
        this.$logger.out(table.toString());
    }
    promptForImageInformation(force) {
        return __awaiter(this, void 0, void 0, function* () {
            let imagePath = yield this.$prompter.getString('Enter image file path:'), imageOptions = ['Icons', 'Splash Screens'], chosenOption = yield this.$prompter.promptForChoice(`What type of resources do you want to create?`, imageOptions), imageType = 0;
            imagePath = helpers.trimSymbol(imagePath, '"');
            if (chosenOption === imageOptions[1]) {
                imageType = 1;
            }
            yield this.generateImages(imagePath, imageType, force);
        });
    }
    generateImages(initialImagePath, imageType, force) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateImage(initialImagePath);
            temp.track();
            let inputImageStream = this.$fs.createReadStream(initialImagePath), tempDir = temp.mkdirSync('ab-images-'), resultImageArchivePath = path.join(tempDir, 'images.zip'), resultImageArchiveStream = this.$fs.createWriteStream(resultImageArchivePath);
            this.replaceAll = force;
            this.$logger.printInfoMessageOnSameLine('Generating images');
            yield this.$progressIndicator.showProgressIndicator(this.$server.images.generateArchive(imageType, inputImageStream, resultImageArchiveStream), 2000);
            this.$logger.printInfoMessageOnSameLine('Extracting images');
            yield this.$progressIndicator.showProgressIndicator(this.$fs.unzip(resultImageArchivePath, tempDir), 2000);
            yield this.$fs.unzip(resultImageArchivePath, tempDir);
            let imageBasePath = path.join(tempDir, 'App_Resources'), images = this.$fs.enumerateFilesInDirectorySync(imageBasePath);
            yield Promise.all(_.map(images, (imagePath) => __awaiter(this, void 0, void 0, function* () {
                if (!this.$project.capabilities.wp8Supported && ~imagePath.indexOf(this.$devicePlatformsConstants.WP8)) {
                    return;
                }
                let projectImagePath = path.join(this.$project.appResourcesPath(), imagePath.substring(imageBasePath.length));
                yield this.copyImageToProject(imagePath, projectImagePath);
            })));
        });
    }
    copyImageToProject(imagePath, projectImagePath) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$fs.ensureDirectoryExists(path.dirname(projectImagePath));
            if (this.replaceAll || !this.$fs.exists(projectImagePath)) {
                return this.$fs.copyFile(imagePath, projectImagePath);
            }
            let replaceOptions = ['Yes for all', 'Yes', 'No', 'No for all'], chosenOption = yield this.$prompter.promptForChoice(`${projectImagePath} already exists, do you want to replace it?`, replaceOptions);
            switch (chosenOption) {
                case replaceOptions[0]:
                    this.replaceAll = true;
                    return this.$fs.copyFile(imagePath, projectImagePath);
                case replaceOptions[1]:
                    return this.$fs.copyFile(imagePath, projectImagePath);
                case replaceOptions[3]:
                    this.$errors.failWithoutHelp('Operation canceled.');
            }
        });
    }
    pushImageToTable(table, platform, icon, splashScreen) {
        let iconPath = this.getImagePath(icon), iconDimensions = this.getImageDimensions(icon), splashScreenPath = this.getImagePath(splashScreen), splashScreenDimensions = this.getImageDimensions(splashScreen);
        table.push([platform, iconPath, splashScreenPath]);
        table.push(['', iconDimensions, splashScreenDimensions]);
        table.push(['', '', '']);
    }
    validateImage(imagePath) {
        if (!imagePath) {
            this.$errors.failWithoutHelp('You must provid–µ a valid image path.');
        }
        if (!this.$fs.exists(imagePath)) {
            this.$errors.failWithoutHelp(`The specified file ${imagePath} does not exist.`);
        }
        if (path.extname(imagePath) !== ImageConstants.PNG_EXTENSION) {
            this.$errors.failWithoutHelp('You must specify a PNG image source.');
        }
    }
    getImageDimensions(image) {
        return image ? `Dimensions: ${image.Width}x${image.Height}` : '';
    }
    getImagePath(image) {
        return image ? `Path: ${image.FileName}` : '';
    }
}
__decorate([
    decorators_1.cache()
], ImageService.prototype, "init", null);
__decorate([
    decorators_1.invokeInit()
], ImageService.prototype, "promptForImageInformation", null);
__decorate([
    decorators_1.invokeInit()
], ImageService.prototype, "generateImages", null);
$injector.register("imageService", ImageService);
