"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
class DarwinDebuggerService {
    constructor($devicesService, $androidEmulatorServices, $androidProcessService, $clipboardService, $opener, $errors, $logger, $prompter) {
        this.$devicesService = $devicesService;
        this.$androidEmulatorServices = $androidEmulatorServices;
        this.$androidProcessService = $androidProcessService;
        this.$clipboardService = $clipboardService;
        this.$opener = $opener;
        this.$errors = $errors;
        this.$logger = $logger;
        this.$prompter = $prompter;
    }
    debugIosApplication(applicationId) {
        let pathToDebuggingGuideHtml = path.join(__dirname, "..", "..", "..", "resources", "debugging", "ios-debug-guide.html");
        this.$opener.open(`${pathToDebuggingGuideHtml}`, "Safari");
    }
    debugAndroidApplication(applicationId, framework) {
        return __awaiter(this, void 0, void 0, function* () {
            let deviceIdentifier;
            yield this.$devicesService.detectCurrentlyAttachedDevices();
            let connectedDevices = this.$devicesService.getDevicesForPlatform("android");
            if (connectedDevices.length > 1) {
                let devicesNames = connectedDevices.map((device) => device.deviceInfo.displayName);
                let selectedDeviceName = yield this.$prompter.promptForChoice("You have more than one Android devices connected to your computer. Please choose which one to use", devicesNames);
                deviceIdentifier = connectedDevices.filter((device) => device.deviceInfo.displayName === selectedDeviceName)[0].deviceInfo.identifier;
            }
            else if (connectedDevices.length === 1) {
                deviceIdentifier = connectedDevices[0].deviceInfo.identifier;
            }
            else {
                deviceIdentifier = yield this.$androidEmulatorServices.startEmulator();
            }
            let applicationsAvailableForDebugging = yield this.$androidProcessService.getDebuggableApps(deviceIdentifier);
            let applicationNotStartedErrorMessage = `Application with identifier ${applicationId} is not started on device ${deviceIdentifier}. Please open the application on the device to debug it.`;
            if (!_.find(applicationsAvailableForDebugging, app => app.appIdentifier === applicationId)) {
                this.$errors.failWithoutHelp(applicationNotStartedErrorMessage);
            }
            let tcpPort;
            try {
                tcpPort = yield this.$androidProcessService.mapAbstractToTcpPort(deviceIdentifier, applicationId, framework);
            }
            catch (err) {
                this.$errors.failWithoutHelp("Your device has no open ports. Please close programs that are using device's ports to listen on them and try again.");
            }
            let inspectorAddress = `chrome://inspect:${tcpPort}`;
            yield this.$clipboardService.copy(inspectorAddress);
            this.$logger.out(`Your application is available for debugging on port: ${tcpPort}.`);
            this.$logger.out(`Open Google Chrome and in the address bar enter ${inspectorAddress}. You can just paste it, it is already copied to your clipboard.`);
        });
    }
}
exports.DarwinDebuggerService = DarwinDebuggerService;
$injector.register("darwinDebuggerService", DarwinDebuggerService);
