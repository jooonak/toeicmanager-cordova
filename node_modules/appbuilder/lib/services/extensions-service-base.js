"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const helpers = require("../helpers");
class ExtensionsServiceBase {
    constructor(cacheDir, $fs, $httpClient, $logger, $options) {
        this.cacheDir = cacheDir;
        this.$fs = $fs;
        this.$httpClient = $httpClient;
        this.$logger = $logger;
        this.$options = $options;
        this.extensionVersions = {};
        if (this.$fs.exists(this.versionsFile)) {
            this.extensionVersions = this.$fs.readJson(this.versionsFile) || {};
        }
    }
    getExtensionVersion(packageName) {
        if (!this.extensionVersions) {
            return null;
        }
        return this.extensionVersions[packageName];
    }
    getExtensionPath(packageName) {
        return path.join(this.cacheDir, packageName);
    }
    prepareExtensionBase(extensionData, initialCachedVersion, actions) {
        return __awaiter(this, void 0, void 0, function* () {
            actions = actions || {};
            if (this.$fs.exists(this.versionsFile)) {
                this.extensionVersions = this.$fs.readJson(this.versionsFile) || {};
            }
            let packageName = extensionData.packageName;
            let extensionVersion = extensionData.version;
            let extensionPath = extensionData.pathToSave || this.getExtensionPath(extensionData.packageName);
            let cachedVersion = initialCachedVersion;
            this.$logger.debug("Server version: %s", extensionVersion);
            if (this.extensionVersions[packageName]) {
                cachedVersion = this.extensionVersions[packageName];
                this.$logger.debug("Cached version is: %s", cachedVersion);
            }
            if (this.shouldUpdatePackage(cachedVersion, extensionVersion)) {
                this.$logger.printInfoMessageOnSameLine(`Updating ${packageName} package...`);
                let zipFileName = path.join(this.cacheDir, packageName + ".zip");
                if (actions.beforeDownloadAction) {
                    yield actions.beforeDownloadAction();
                }
                this.$fs.deleteDirectory(extensionPath);
                this.$fs.createDirectory(extensionPath);
                this.$logger.trace("Extension path for %s: %s", packageName, extensionPath);
                try {
                    yield this.downloadPackage(extensionData.downloadUri, zipFileName);
                    yield this.$fs.unzip(zipFileName, extensionPath);
                    this.$fs.deleteFile(zipFileName);
                    this.extensionVersions[packageName] = extensionVersion;
                    if (actions.afterDownloadAction) {
                        yield actions.afterDownloadAction();
                    }
                    this.saveVersionsFile();
                }
                catch (err) {
                    this.$fs.deleteFile(zipFileName);
                    this.$fs.deleteDirectory(extensionPath);
                    throw err;
                }
                this.$logger.trace("Finished updating %s package.", packageName);
            }
        });
    }
    shouldUpdatePackage(cachedVersion, extensionVersion) {
        return helpers.versionCompare(cachedVersion, extensionVersion) !== 0;
    }
    get versionsFile() {
        return path.join(this.$options.profileDir, "Cache", "extension-versions.json");
    }
    saveVersionsFile() {
        return this.$fs.writeJson(this.versionsFile, this.extensionVersions);
    }
    downloadPackage(downloadUri, zipFileName) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$logger.debug("Downloading package from %s", downloadUri);
            let zipFile = this.$fs.createWriteStream(zipFileName);
            let request = this.$httpClient.httpRequest({
                url: downloadUri,
                pipeTo: zipFile,
                headers: { Accept: "application/octet-stream, application/x-silverlight-app" }
            });
            return request;
        });
    }
}
exports.ExtensionsServiceBase = ExtensionsServiceBase;
