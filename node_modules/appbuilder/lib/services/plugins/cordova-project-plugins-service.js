"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const util = require("util");
const helpers = require("../../common/helpers");
const constants_1 = require("../../common/constants");
const semver = require("semver");
const path = require("path");
const xmlMapping = require("xml-mapping");
const os_1 = require("os");
const plugins_data_1 = require("../../plugins-data");
const plugins_service_base_1 = require("./plugins-service-base");
class CordovaProjectPluginsService extends plugins_service_base_1.PluginsServiceBase {
    constructor($cordovaPluginsService, $loginManager, $marketplacePluginsService, $resources, $errors, $logger, $prompter, $fs, $project, $projectConstants, $childProcess, $httpClient, $options, $npmService, $hostInfo, $npmPluginsService) {
        super($errors, $logger, $prompter, $fs, $project, $projectConstants, $childProcess, $httpClient, $options, $npmService, $npmPluginsService);
        this.$cordovaPluginsService = $cordovaPluginsService;
        this.$loginManager = $loginManager;
        this.$marketplacePluginsService = $marketplacePluginsService;
        this.$resources = $resources;
        this.pluginsForbiddenConfigurations = {
            "com.telerik.LivePatch": this.$projectConstants.DEBUG_CONFIGURATION_NAME
        };
    }
    get specifiedConfigurations() {
        return _(this.$project.configurations.length > 1 ? [] : this.$project.configurations)
            .concat(this.$project.getConfigurationsSpecifiedByUser())
            .uniq()
            .value();
    }
    getIdentifierToPlugin() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._identifierToPlugin) {
                yield this.loadPluginsData();
            }
            return this._identifierToPlugin;
        });
    }
    getInstalledPlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            let corePlugins = [];
            if (this.specifiedConfigurations.length) {
                const installedPluginsForConfigurationPromises = this.specifiedConfigurations.map((configuration) => __awaiter(this, void 0, void 0, function* () { return yield this.getInstalledPluginsForConfiguration(configuration); }));
                corePlugins = _.flatten(yield Promise.all(installedPluginsForConfigurationPromises));
            }
            else {
                corePlugins = yield this.getInstalledPluginsForConfiguration();
            }
            return corePlugins.concat(this.getLocalPlugins());
        });
    }
    getAvailablePlugins(pluginsCount) {
        return __awaiter(this, void 0, void 0, function* () {
            let plugins = _.values(yield this.getIdentifierToPlugin());
            if (this.$project.projectData) {
                plugins = _.filter(plugins, pl => this.isPluginSupported(pl, this.$project.projectData.FrameworkVersion));
            }
            return plugins.concat(this.getLocalPlugins());
        });
    }
    addPlugin(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!pluginName) {
                this.$errors.fail("No plugin name specified");
            }
            let pluginBasicInfo = yield this.getPluginBasicInformation(pluginName);
            pluginName = pluginBasicInfo.name;
            let version = pluginBasicInfo.version;
            let pluginNameToLowerCase = pluginName.toLowerCase();
            let plInstances;
            try {
                plInstances = yield this.getPluginInstancesByName(pluginName);
            }
            catch (err) {
                this.$logger.info(`The plugin '${pluginName}' was not found in our list of verified Cordova plugins. We will try to find it in npm and it will be fetched instead of added.`);
                yield this.fetch(pluginName);
                return;
            }
            if (!plInstances || !plInstances.length) {
                this.$errors.failWithoutHelp("Invalid plugin name: %s", pluginName);
            }
            let installedPluginsForConfiguration = yield this.getInstalledPluginsForConfiguration();
            let installedPluginInstances = installedPluginsForConfiguration
                .filter(pl => pl.data.Name.toLowerCase() === pluginNameToLowerCase || pl.data.Identifier.toLowerCase() === pluginNameToLowerCase);
            let pluginIdFromName = (yield this.getPluginIdFromName(pluginName)).toLowerCase();
            if (!installedPluginInstances.length && pluginIdFromName) {
                this.$logger.trace(`Unable to find installed plugin with specified name: '${pluginName}'. Trying to find if this is an old name of installed plugin.`);
                installedPluginInstances = installedPluginsForConfiguration.filter(pl => pl.data.Identifier.toLowerCase() === pluginIdFromName);
            }
            if (installedPluginInstances && installedPluginInstances.length > 0) {
                let installedPluginsType = _.chain(installedPluginInstances).groupBy((pl) => pl.type).keys().value();
                if (installedPluginsType.length > 1) {
                    let mpPlugin = _.find(installedPluginInstances, pl => pl.type === plugins_data_1.PluginType.MarketplacePlugin);
                    if (mpPlugin) {
                        return yield this.modifyInstalledMarketplacePlugin(mpPlugin.data.Identifier, version);
                    }
                    else {
                        this.$errors.failWithoutHelp("There are several plugins with name '%s' and they have different types: '%s'", pluginName, installedPluginsType.join(", "));
                    }
                }
                else if (installedPluginsType.length === 1) {
                    if (installedPluginsType[0].toString() === plugins_data_1.PluginType.MarketplacePlugin.toString()) {
                        return yield this.modifyInstalledMarketplacePlugin(installedPluginInstances[0].data.Identifier, version);
                    }
                    else {
                        let installedPlugin = this.getInstalledPluginByName(pluginName);
                        if (installedPlugin) {
                            this.$logger.info("Plugin '%s' is already installed", pluginName);
                            return;
                        }
                    }
                }
            }
            let pluginToAdd = yield this.getBestMatchingPlugin(pluginName, version);
            if (pluginToAdd.type === plugins_data_1.PluginType.MarketplacePlugin) {
                version = yield this.selectPluginVersion(version, pluginToAdd);
                if (!this.isPluginSupported(pluginToAdd, this.$project.projectData.FrameworkVersion, version)) {
                    this.$errors.failWithoutHelp(`Plugin ${pluginName} is not available for framework version '${this.$project.projectData.FrameworkVersion}'.`);
                }
            }
            let configurations = this.specifiedConfigurations.length ? this.specifiedConfigurations : this.$project.getAllConfigurationsNames();
            if (_(this.pluginsForbiddenConfigurations).keys().find(key => key === pluginToAdd.data.Identifier)) {
                let forbiddenConfig = this.pluginsForbiddenConfigurations[pluginToAdd.data.Identifier];
                if (configurations.length === 1 && _.includes(this.specifiedConfigurations, forbiddenConfig)) {
                    this.$errors.failWithoutHelp(`You cannot enable plugin ${pluginName} in ${forbiddenConfig} configuration.`);
                }
                configurations = _.without(configurations, forbiddenConfig);
            }
            yield this.configurePlugin(pluginName, version, configurations);
        });
    }
    removePlugin(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!pluginName) {
                this.$errors.fail("No plugin name specified.");
            }
            let installedPlugins = yield this.getInstalledPluginByName(pluginName);
            let plugin = installedPlugins[0];
            if (!plugin) {
                if (this.isPluginFetched(pluginName)) {
                    let shouldDeleteFetchedPlugin = true;
                    if (helpers.isInteractive()) {
                        shouldDeleteFetchedPlugin = yield this.$prompter.confirm(`The plugin ${pluginName} will be deleted from the plugins folder. Are you sure you want to remove it?`, () => true);
                    }
                    if (shouldDeleteFetchedPlugin) {
                        this.$fs.deleteDirectory(path.join(this.$project.projectDir, this.getPluginsDirName(), pluginName));
                        this.$logger.out(`Plugin ${pluginName} was successfully removed.`);
                    }
                    else {
                        this.$logger.out(`Plugin ${pluginName} was not removed.`);
                    }
                    return;
                }
                else {
                    this.$errors.failWithoutHelp("Could not find plugin with name %s.", pluginName);
                }
            }
            let obsoletedBy = yield this.getObsoletedByPluginIdentifier(plugin.data.Identifier);
            let obsoletingKey = yield this.getObsoletingPluginIdentifier(plugin.data.Identifier);
            let identifierToPlugin = yield this.getIdentifierToPlugin();
            if (this.$project.hasBuildConfigurations) {
                let configurations = this.specifiedConfigurations.length ? this.specifiedConfigurations : this.$project.getAllConfigurationsNames();
                _.each(configurations, (configuration) => {
                    this.removePluginCore(pluginName, plugin, configuration);
                    if (obsoletedBy) {
                        this.removePluginCore(obsoletedBy, identifierToPlugin[`${obsoletedBy}@${plugin.data.Version}`], configuration);
                    }
                    if (obsoletingKey) {
                        this.removePluginCore(obsoletingKey, identifierToPlugin[obsoletingKey], configuration);
                    }
                });
            }
            else {
                this.removePluginCore(pluginName, plugin);
                if (obsoletedBy) {
                    this.removePluginCore(obsoletedBy, identifierToPlugin[`${obsoletedBy}@${plugin.data.Version}`]);
                }
                if (obsoletingKey) {
                    this.removePluginCore(obsoletingKey, identifierToPlugin[obsoletingKey]);
                }
            }
        });
    }
    printPlugins(plugins) {
        return __awaiter(this, void 0, void 0, function* () {
            let pluginsToPrint = plugins;
            if (this.$options.available) {
                let marketplacePlugins = _.filter(plugins, (pl) => pl.type === plugins_data_1.PluginType.MarketplacePlugin);
                pluginsToPrint = _.filter(plugins, pl => pl.type === plugins_data_1.PluginType.CorePlugin || pl.type === plugins_data_1.PluginType.AdvancedPlugin);
                let groups = _.groupBy(marketplacePlugins, (plugin) => plugin.data.Identifier);
                _.each(groups, (group) => {
                    let defaultData = _.find(group, (gr) => {
                        let pvd = gr.pluginVersionsData;
                        return pvd && gr.data.Version === pvd.DefaultVersion;
                    });
                    if (defaultData) {
                        pluginsToPrint.push(defaultData);
                    }
                });
            }
            this.printPluginsCore(pluginsToPrint);
        });
    }
    isPluginInstalled(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            let installedPluginInstances = yield this.getInstalledPluginByName(pluginName);
            return (installedPluginInstances && installedPluginInstances.length > 0) || this.isPluginFetched(pluginName);
        });
    }
    configurePlugin(pluginName, version, configurations) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.$project.hasBuildConfigurations) {
                let configs = configurations || (this.specifiedConfigurations.length ? this.specifiedConfigurations : this.$project.getAllConfigurationsNames());
                for (let configuration of configs) {
                    yield this.configurePluginCore(pluginName, configuration, version);
                }
            }
            else {
                yield this.configurePluginCore(pluginName, version);
            }
        });
    }
    getPluginBasicInformation(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            let dependencyInfo = this.$npmService.getDependencyInformation(pluginName);
            return Promise.resolve({
                name: dependencyInfo.name,
                version: dependencyInfo.version
            });
        });
    }
    getPluginVersions(plugin) {
        let pluginVersionsData = plugin.pluginVersionsData;
        return _.map(pluginVersionsData.Versions, p => {
            let pluginVersion = {
                name: p.Version,
                value: p.Version,
                cordovaVersionRange: p.SupportedVersion
            };
            return pluginVersion;
        });
    }
    filterPlugins(plugins) {
        return __awaiter(this, void 0, void 0, function* () {
            let obsoletedIntegratedPlugins = _.keys(this.getObsoletedIntegratedPlugins()).map(pluginId => pluginId.toLowerCase());
            return _.filter(plugins, pl => !_.some(obsoletedIntegratedPlugins, obsoletedId => obsoletedId === pl.data.Identifier.toLowerCase() && pl.type !== plugins_data_1.PluginType.MarketplacePlugin));
        });
    }
    shouldCopyToPluginsDirectory(pathToPlugin) {
        return super.shouldCopyToPluginsDirectory(pathToPlugin) || pathToPlugin.indexOf(path.join(this.$project.projectDir, constants_1.NODE_MODULES_DIR_NAME)) >= 0;
    }
    getPluginsDirName() {
        return "plugins";
    }
    composeSearchQuery(keywords) {
        keywords.push("ecosystem:cordova");
        return keywords;
    }
    installLocalPluginCore(pathToPlugin, pluginOpts) {
        return __awaiter(this, void 0, void 0, function* () {
            let pluginXml = this.getPluginXmlContent(pathToPlugin);
            return yield this.getLocalPluginBasicInformation(pluginXml);
        });
    }
    fetchPluginBasicInformationCore(pathToInstalledPlugin, version, pluginData, options) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            pluginData.addPluginToConfigFile = false;
            let pluginBasicInfo = yield _super("installLocalPlugin").call(this, pathToInstalledPlugin, pluginData, options);
            let configurations = this.specifiedConfigurations.length ? this.specifiedConfigurations : this.$project.getAllConfigurationsNames();
            for (let configuration of configurations) {
                yield this.setPluginVariables(pluginBasicInfo.name, pluginBasicInfo.variables, configuration);
            }
            this.$project.saveProject(this.$project.projectDir, this.$project.getAllConfigurationsNames());
            return pluginBasicInfo;
        });
    }
    validatePluginInformation(pathToPlugin) {
        let pluginXml = this.getPluginXmlContent(pathToPlugin);
        if (!pluginXml) {
            this.$errors.failWithoutHelp(`${path.basename(pathToPlugin)} is not a valid Cordova plugin.`);
        }
    }
    loadPluginsData() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$project.ensureCordovaProject();
            yield this.$loginManager.ensureLoggedIn();
            this._identifierToPlugin = Object.create(null);
            yield this.createPluginsData(this.$cordovaPluginsService);
            yield this.createPluginsData(this.$marketplacePluginsService);
        });
    }
    getInstalledPluginsForConfiguration(config) {
        return __awaiter(this, void 0, void 0, function* () {
            let corePlugins = [];
            if (config) {
                corePlugins = this.$project.getProperty(CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME, config);
            }
            else {
                corePlugins = _(this.$project.getAllConfigurationsNames())
                    .map((configurationName) => this.$project.getProperty(CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME, configurationName))
                    .flatten()
                    .filter((pluginName) => !!pluginName)
                    .uniq()
                    .value();
            }
            return Promise.all(_.map(corePlugins, (pluginIdentifier) => __awaiter(this, void 0, void 0, function* () {
                let data = pluginIdentifier.split("@"), name = data[0], version = data[1];
                let plugin = yield this.getBestMatchingPlugin(name, version);
                if (!plugin) {
                    let failMessage = config ?
                        `You have enabled an invalid plugin: ${pluginIdentifier} for the ${config} build configuration. Check your .${config}.abproject file in the project root and correct or remove the invalid plugin entry.` :
                        `You have enabled an invalid plugin: ${pluginIdentifier}. Check your ${_.map(this.$project.getAllConfigurationsNames(), (configuration) => `.${configuration}.abproject`).join(", ")} files in the project root and correct or remove the invalid plugin entry.`;
                    this.$errors.failWithoutHelp(failMessage);
                }
                return plugin;
            })));
        });
    }
    getBestMatchingPlugin(name, version) {
        return __awaiter(this, void 0, void 0, function* () {
            let plugins = yield this.getPluginInstancesByName(name, version);
            return _.find(plugins, pl => pl.type === plugins_data_1.PluginType.MarketplacePlugin) || plugins[0];
        });
    }
    isPluginSupported(plugin, frameworkVersion, pluginVersion) {
        if (!this.isMarketplacePlugin(plugin)) {
            return true;
        }
        pluginVersion = pluginVersion || plugin.data.Version;
        let pluginVersions = this.getPluginVersions(plugin);
        let version = _.find(pluginVersions, v => v.value === pluginVersion);
        return version && semver.satisfies(frameworkVersion, version.cordovaVersionRange);
    }
    getInstalledPluginByName(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            pluginName = pluginName.toLowerCase();
            let installedPlugins = yield this.getInstalledPlugins();
            let installedPluginInstances = _.filter(installedPlugins, (plugin) => plugin.data.Name.toLowerCase() === pluginName || plugin.data.Identifier.toLowerCase() === pluginName);
            let pluginIdFromName = (yield this.getPluginIdFromName(pluginName)).toLowerCase();
            if (!installedPluginInstances.length && pluginIdFromName) {
                this.$logger.trace(`Unable to find installed plugin with specified name: '${pluginName}'. Trying to find if this is an old name of installed plugin.`);
                installedPluginInstances = installedPlugins.filter(pl => pl.data.Identifier.toLowerCase() === pluginIdFromName);
            }
            if (!installedPluginInstances.length) {
                this.$logger.trace("Check if the name is obsoleted one and the old plugin is no longer available, but the new one can be used.");
                let obsoletedBy = yield this.getObsoletedByPluginIdentifier(pluginName);
                if (obsoletedBy) {
                    installedPluginInstances = _.filter(installedPlugins, (plugin) => plugin.data.Identifier.toLowerCase() === obsoletedBy.toLowerCase());
                }
            }
            return installedPluginInstances;
        });
    }
    configurePluginCore(pluginName, configuration, version) {
        return __awaiter(this, void 0, void 0, function* () {
            let plugin = yield this.getBestMatchingPlugin(pluginName, version);
            let pluginData = plugin.data;
            yield this.setPluginVariables(pluginData.Identifier, pluginData.Variables, configuration);
            let newCorePlugins = this.$project.getProperty(CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME, configuration) || [];
            newCorePlugins = _.without.apply(null, [newCorePlugins].concat((yield this.getPluginInstancesByName(plugin.data.Identifier)).map(plug => plug.toProjectDataRecord())));
            let obsoletedBy = yield this.getObsoletedByPluginIdentifier(plugin.data.Identifier), obsoletingKey = yield this.getObsoletingPluginIdentifier(plugin.data.Identifier);
            if (obsoletedBy) {
                newCorePlugins = _.without.apply(null, [newCorePlugins].concat((yield this.getPluginInstancesByName(obsoletedBy)).map(plug => plug.toProjectDataRecord())));
            }
            if (obsoletingKey) {
                newCorePlugins = _.without.apply(null, [newCorePlugins].concat((yield this.getPluginInstancesByName(obsoletingKey)).map(plug => plug.toProjectDataRecord())));
            }
            newCorePlugins.push(plugin.toProjectDataRecord(version));
            let versionString = this.isMarketplacePlugin(plugin) ? ` with version ${version || plugin.data.Version}` : "", successMessageForConfigSuffix = ` for ${configuration} configuration${versionString}`, successMessage = `Plugin ${pluginName} was successfully added${configuration ? successMessageForConfigSuffix : versionString}.`;
            if (configuration) {
                yield this.$project.updateProjectProperty("set", CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME, newCorePlugins, [configuration]);
            }
            else {
                yield this.$project.updateProjectProperty("set", CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME, newCorePlugins);
            }
            this.$project.saveProject(this.$project.projectDir, this.$project.getAllConfigurationsNames());
            this.$logger.out(successMessage);
        });
    }
    removePluginCore(pluginName, plugin, configuration) {
        let pluginData = plugin.data;
        let cordovaPluginVariables = this.$project.getProperty(CordovaProjectPluginsService.CORDOVA_PLUGIN_VARIABLES_PROPERTY_NAME, configuration);
        if (cordovaPluginVariables && _.keys(cordovaPluginVariables[pluginData.Identifier]).length > 0) {
            _.each(pluginData.Variables, (variableName) => {
                delete cordovaPluginVariables[pluginData.Identifier][variableName];
            });
        }
        if (cordovaPluginVariables && _.keys(cordovaPluginVariables[pluginData.Identifier]).length === 0) {
            delete cordovaPluginVariables[pluginData.Identifier];
        }
        let oldCorePlugins = this.$project.getProperty(CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME, configuration);
        let newCorePlugins = _.without(oldCorePlugins, plugin.toProjectDataRecord());
        if (newCorePlugins.length !== oldCorePlugins.length) {
            this.$project.setProperty(CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME, newCorePlugins, configuration);
            if (configuration) {
                this.$project.saveProject(this.$project.getProjectDir(), [configuration]);
                this.$logger.out("Plugin %s was successfully removed for %s configuration.", pluginName, configuration);
            }
            else {
                this.$project.saveProject();
                this.$logger.out("Plugin %s was successfully removed.", pluginName);
            }
        }
    }
    createPluginsData(pluginsService) {
        return __awaiter(this, void 0, void 0, function* () {
            let plugins = yield pluginsService.getAvailablePlugins();
            yield Promise.all(_.map(plugins, (plugin) => __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield pluginsService.createPluginData(plugin);
                    _.each(data, pluginData => {
                        if (pluginData && pluginData.data) {
                            let projectDataRecord = pluginData.toProjectDataRecord();
                            let configurations = this.$project.configurationSpecificData;
                            _.each(configurations, (configData, configuration) => {
                                if (configData) {
                                    let corePlugins = configData[CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME];
                                    if (corePlugins && (_.includes(corePlugins, projectDataRecord) || _.includes(corePlugins, pluginData.data.Identifier))) {
                                        pluginData.configurations.push(configuration);
                                    }
                                }
                            });
                            this._identifierToPlugin[projectDataRecord] = pluginData;
                        }
                        else {
                            this.$logger.warn("Unable to fetch data for plugin %s.", plugin.Identifier);
                        }
                    });
                }
                catch (e) {
                    this.$logger.warn("Unable to fetch data for %s plugin. Please, try again in a few minutes.", plugin.title);
                    this.$logger.trace(e);
                }
            })));
        });
    }
    gatherVariableInformation(pluginIdentifier, variableName, configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            let schema = {
                name: variableName,
                type: "input",
                message: configuration ? util.format("Set value for variable %s in %s configuration", variableName, configuration) : util.format("Set value for variable %s", variableName)
            };
            let cordovaPluginVariables = this.$project.getProperty(CordovaProjectPluginsService.CORDOVA_PLUGIN_VARIABLES_PROPERTY_NAME, configuration) || {};
            let pluginVariables = cordovaPluginVariables[pluginIdentifier];
            if (pluginVariables && pluginVariables[variableName]) {
                schema["default"] = () => pluginVariables[variableName];
            }
            return this.getPluginVariableFromVarOption(variableName, configuration) || (yield this.$prompter.get([schema]));
        });
    }
    getPluginInstancesByName(pluginName, version) {
        return __awaiter(this, void 0, void 0, function* () {
            let plugins = yield this.getAvailablePlugins();
            let toLowerCasePluginName = pluginName.toLowerCase();
            let filterAction = (name) => {
                let lowercasedValue = name.toLowerCase();
                return _.filter(plugins, (_plugin) => {
                    let condition = _plugin.data.Name.toLowerCase() === lowercasedValue || _plugin.data.Identifier.toLowerCase() === lowercasedValue;
                    if (version) {
                        condition = condition && _plugin.data.Version === version;
                    }
                    return condition;
                });
            };
            let matchingPlugins = filterAction(toLowerCasePluginName);
            let realIdentifier;
            if (!matchingPlugins || !matchingPlugins.length) {
                realIdentifier = pluginName;
            }
            realIdentifier = realIdentifier || matchingPlugins[0].data.Identifier;
            let obsoletedBy = yield this.getObsoletedByPluginIdentifier(realIdentifier);
            if (obsoletedBy) {
                let obsoletedByPlugins = filterAction(obsoletedBy);
                matchingPlugins = matchingPlugins.concat(obsoletedByPlugins);
            }
            if (!matchingPlugins || !matchingPlugins.length) {
                this.$errors.fail("Invalid plugin name: %s", pluginName);
            }
            return matchingPlugins;
        });
    }
    promptForVersion(pluginName, versions) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield versions.length) > 1 ? this.promptForVersionCore(pluginName, versions) : versions[0].value;
        });
    }
    promptForVersionCore(pluginName, versions) {
        return __awaiter(this, void 0, void 0, function* () {
            let version;
            if (helpers.isInteractive()) {
                version = yield this.$prompter.promptForChoice("Which plugin version do you want to use?", versions);
            }
            else {
                this.$errors.failWithoutHelp(`You must specify valid version in order to update your plugin when terminal is not interactive.`);
            }
            return version;
        });
    }
    printPluginsCore(plugins) {
        let groups = _.groupBy(plugins, (plugin) => plugin.type);
        let outputLines = [];
        _.each(Object.keys(groups), (group) => {
            outputLines.push(util.format("%s:%s======================", CordovaProjectPluginsService.HEADERS[+group], os_1.EOL));
            let sortedPlugins = _.sortBy(groups[group], (plugin) => plugin.data.Name);
            _.each(sortedPlugins, (plugin) => {
                outputLines.push(plugin.pluginInformation.join(os_1.EOL));
            });
        });
        this.$logger.out(outputLines.join(os_1.EOL + os_1.EOL));
    }
    modifyInstalledMarketplacePlugin(pluginName, version) {
        return __awaiter(this, void 0, void 0, function* () {
            pluginName = pluginName.toLowerCase();
            let isConsoleInteractive = helpers.isInteractive();
            let allInstalledPlugins = yield this.getInstalledPluginsForConfiguration();
            let installedPluginInstances = _(allInstalledPlugins)
                .filter((plugin) => plugin.data.Name.toLowerCase() === pluginName || plugin.data.Identifier.toLowerCase() === pluginName)
                .uniqBy((plugin) => plugin.data.Version)
                .value();
            let selectedVersion;
            if (installedPluginInstances.length > 1) {
                this.$logger.warn(`Plugin '${pluginName}' is enabled with different versions in your project configurations. You must use the same version in all configurations.`);
            }
            _.each(installedPluginInstances, (pl) => {
                let configString = pl.configurations.length > 1 ? `'${pl.configurations.join(", ")}' configurations` : `'${pl.configurations[0]}' configuration`;
                this.$logger.info(`Plugin '${pluginName}' is enabled in ${configString} with version '${pl.data.Version}'.`);
            });
            let installedPlugin = installedPluginInstances[0];
            if (!this.specifiedConfigurations.length) {
                selectedVersion = yield this.selectPluginVersion(version, installedPlugin);
                yield this.configurePlugin(pluginName, selectedVersion, this.$project.getAllConfigurationsNames());
                return;
            }
            let configurationsToRemove = _.difference(installedPlugin.configurations, this.specifiedConfigurations);
            let configurationsToEdit = _(installedPluginInstances)
                .map((pluginInstance) => pluginInstance.configurations)
                .flatten()
                .concat(this.specifiedConfigurations)
                .uniq()
                .value();
            let removeItemChoice = `Remove plugin from [${configurationsToRemove.join(", ")}] configuration and add it to [${this.specifiedConfigurations.join(", ")}] configuration only.`;
            let modifyAllConfigs = `Enable plugin in [${configurationsToEdit.join(", ")}] configurations with same version.`;
            let cancelOperation = "Cancel operation.";
            let choices = [modifyAllConfigs, cancelOperation];
            if (configurationsToRemove.length) {
                choices.unshift(removeItemChoice);
            }
            if (!configurationsToRemove.length && installedPlugin.configurations.length === this.specifiedConfigurations.length) {
                if (installedPluginInstances.length > 1 && !helpers.isInteractive()) {
                    this.$errors.failWithoutHelp(`Plugin ${pluginName} is enabled in multiple configurations and you are trying to enable it in one only. You cannot do this in non-interactive terminal.`);
                }
                selectedVersion = yield this.selectPluginVersion(version, installedPlugin, { excludeCurrentVersion: true });
                for (let selectedConfiguration of configurationsToEdit) {
                    yield this.configurePluginCore(pluginName, selectedConfiguration, selectedVersion);
                }
                return;
            }
            if (isConsoleInteractive) {
                let selectedItem = yield this.$prompter.promptForChoice("Select action", choices);
                switch (selectedItem) {
                    case removeItemChoice:
                        selectedVersion = yield this.selectPluginVersion(version, installedPlugin);
                        _.each(configurationsToRemove, (configurationToRemove) => this.removePluginCore(pluginName, installedPlugin, configurationToRemove));
                        for (let selectedConfiguration of this.specifiedConfigurations) {
                            yield this.configurePluginCore(pluginName, selectedConfiguration, selectedVersion);
                        }
                        break;
                    case modifyAllConfigs:
                        selectedVersion = yield this.selectPluginVersion(version, installedPlugin);
                        yield this.configurePlugin(pluginName, selectedVersion, configurationsToEdit);
                        break;
                    default:
                        this.$errors.failWithoutHelp("The operation will not be completed.");
                }
            }
            else {
                this.$errors.failWithoutHelp(`Plugin ${pluginName} is enabled in multiple configurations and you are trying to enable it in one only. You cannot do this in non-interactive terminal.`);
            }
        });
    }
    selectPluginVersion(version, plugin, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let pluginName = plugin.data.Name;
            let versions = this.getPluginVersions(plugin);
            if (version) {
                if (!_.some(versions, v => v.value === version)) {
                    this.$errors.failWithoutHelp("Invalid version %s. The valid versions are: %s.", version, versions.map(v => v.value).join(", "));
                }
            }
            else if (this.$options.latest) {
                version = _.first(versions).value;
            }
            else if (this.$options.default) {
                version = this.getDefaultPluginVersion(plugin);
            }
            else {
                if (options && options.excludeCurrentVersion) {
                    let currentVersionIndex = _.findIndex(versions, (v) => v.value === plugin.data.Version);
                    versions.splice(currentVersionIndex, 1);
                }
                version = yield this.promptForVersion(pluginName, versions);
            }
            return version;
        });
    }
    getPluginIdFromName(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            let pluginNameToLowerCase = pluginName.toLowerCase();
            let matchingPluginIds = _(yield this.getAvailablePlugins())
                .filter(pl => pl.data.Name.toLowerCase() === pluginNameToLowerCase)
                .map(pl => pl.data.Identifier)
                .uniq()
                .value();
            if (matchingPluginIds.length === 1) {
                return matchingPluginIds[0];
            }
            return "";
        });
    }
    isMarketplacePlugin(plugin) {
        return plugin && plugin.type.toString().toLowerCase() === plugins_data_1.PluginType.MarketplacePlugin.toString().toLowerCase();
    }
    getPluginVariableFromVarOption(variableName, configuration) {
        let varOption = this.$options.var;
        configuration = configuration && configuration.toLowerCase();
        let lowerCasedVariableName = variableName.toLowerCase();
        if (varOption) {
            let configVariableValue;
            let generalVariableValue;
            if (variableName.indexOf(".") !== -1) {
                varOption = this.simplifyYargsObject(varOption, configuration);
            }
            _.each(varOption, (propValue, propKey) => {
                if (propKey.toLowerCase() === configuration) {
                    _.each(propValue, (configPropValue, configPropKey) => {
                        if (configPropKey.toLowerCase() === lowerCasedVariableName) {
                            configVariableValue = configPropValue;
                            return false;
                        }
                    });
                }
                else if (propKey.toLowerCase() === lowerCasedVariableName) {
                    generalVariableValue = propValue;
                }
            });
            let value = configVariableValue || generalVariableValue;
            if (value) {
                let obj = Object.create(null);
                obj[variableName] = value.toString();
                return obj;
            }
        }
        return undefined;
    }
    simplifyYargsObject(obj, configuration) {
        if (obj && typeof (obj) === "object") {
            let convertedObject = Object.create({});
            _.each(obj, (propValue, propKey) => {
                if (typeof (propValue) !== "object") {
                    convertedObject[propKey] = propValue;
                    return false;
                }
                let innerObj = this.simplifyYargsObject(propValue, configuration);
                if (propKey.toLowerCase() === configuration.toLowerCase()) {
                    convertedObject[propKey] = innerObj;
                }
                else {
                    _.each(innerObj, (innerPropValue, innerPropKey) => {
                        convertedObject[`${propKey}.${innerPropKey}`] = innerPropValue;
                    });
                }
            });
            return convertedObject;
        }
        return obj;
    }
    getObsoletedIntegratedPlugins() {
        if (!this._obsoletedIntegratedPlugins) {
            let cordovaJsonContent = this.$fs.readJson(path.join(this.$resources.resolvePath("Cordova"), "cordova.json"));
            this._obsoletedIntegratedPlugins = cordovaJsonContent && cordovaJsonContent.obsoletedIntegratedPlugins;
        }
        return this._obsoletedIntegratedPlugins;
    }
    getObsoletedByPluginIdentifier(pluginIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let obsoletedByInfo = _.find(this.getObsoletedIntegratedPlugins(), (obsoletedPluginInfo, key) => key.toLowerCase() === pluginIdentifier.toLowerCase()) || Object.create(null);
            return obsoletedByInfo.obsoletedBy;
        });
    }
    getObsoletingPluginIdentifier(pluginIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let obsoletingKey;
            _.each(this.getObsoletedIntegratedPlugins(), (obsoletedPluginInfo, key) => {
                if (obsoletedPluginInfo.obsoletedBy.toLowerCase() === pluginIdentifier.toLowerCase()) {
                    obsoletingKey = key;
                    return false;
                }
            });
            return obsoletingKey;
        });
    }
    getLocalPlugins() {
        if (!this._localPlugins) {
            let pluginsDir = path.join(this.$project.projectDir, "plugins");
            if (!this.$fs.exists(pluginsDir)) {
                return [];
            }
            this._localPlugins = _(this.$fs.readDirectory(pluginsDir))
                .map((pluginName) => {
                let pathToPlugin = path.join(pluginsDir, pluginName);
                if (this.$fs.getFsStats(pathToPlugin).isFile()) {
                    return null;
                }
                let pluginXml = this.getPluginXmlContent(pathToPlugin);
                let basicPluginInfo = this.getLocalPluginBasicInformation(pluginXml);
                let plugin = pluginXml.plugin;
                let platforms = _.isArray(plugin.platform) ? _.map(plugin.platform, (p) => p.name) : _.filter([plugin.platform && plugin.platform.name]);
                let identifier = plugin.id;
                let url = "";
                if (_.has(plugin, "repo")) {
                    url = plugin.repo.$t;
                }
                if (!url && _.has(plugin, "url")) {
                    url = plugin.url.$t;
                }
                let data = {
                    Name: basicPluginInfo.name,
                    Description: basicPluginInfo.description,
                    Assets: null,
                    AndroidRequiredPermissions: null,
                    Authors: [basicPluginInfo.author],
                    Url: url,
                    Identifier: identifier,
                    Version: basicPluginInfo.version,
                    Variables: basicPluginInfo.variables,
                    Publisher: { Name: basicPluginInfo.author, Url: url },
                    DownloadsCount: 0,
                    SupportedVersion: basicPluginInfo.version,
                    Platforms: platforms
                };
                return new plugins_data_1.CordovaPluginData(data, plugins_data_1.PluginType.LocalPlugin, this.$project, this.$projectConstants);
            })
                .filter((plugin) => !!plugin)
                .value();
        }
        return this._localPlugins;
    }
    getLocalPluginBasicInformation(pluginXml) {
        let basicPluginInformation = {
            name: pluginXml.plugin.name ? pluginXml.plugin.name.$t : "",
            description: pluginXml.plugin.description ? pluginXml.plugin.description.$t : "",
            version: pluginXml.plugin.version
        };
        let pluginVariables = [];
        if (pluginXml.plugin.preference) {
            if (_.isArray(pluginXml.plugin.preference)) {
                _.each(pluginXml.plugin.preference, (preference) => {
                    pluginVariables.push(preference);
                });
            }
            else {
                pluginVariables.push(pluginXml.plugin.preference);
            }
        }
        basicPluginInformation.variables = pluginVariables;
        return basicPluginInformation;
    }
    getPluginXmlContent(pathToPlugin) {
        let pathToPluginXml = path.join(pathToPlugin, "plugin.xml");
        if (!this.$fs.exists(pathToPluginXml)) {
            return null;
        }
        return xmlMapping.tojson(this.$fs.readText(pathToPluginXml));
    }
    setPluginVariables(pluginIdentifier, variables, configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            let originalPluginVariables = this.$project.getProperty(CordovaProjectPluginsService.CORDOVA_PLUGIN_VARIABLES_PROPERTY_NAME, configuration) || {};
            let cordovaPluginVariables = _.cloneDeep(originalPluginVariables);
            if (variables && variables.length > 0) {
                if (!cordovaPluginVariables[pluginIdentifier]) {
                    cordovaPluginVariables[pluginIdentifier] = {};
                }
                for (let variable of variables) {
                    let variableName = variable.name || variable;
                    let variableInformation = yield this.gatherVariableInformation(pluginIdentifier, variableName, configuration);
                    cordovaPluginVariables[pluginIdentifier][variableName] = variableInformation[variableName];
                }
                this.$project.setProperty(CordovaProjectPluginsService.CORDOVA_PLUGIN_VARIABLES_PROPERTY_NAME, cordovaPluginVariables, configuration);
            }
        });
    }
}
CordovaProjectPluginsService.CORE_PLUGINS_PROPERTY_NAME = "CorePlugins";
CordovaProjectPluginsService.CORDOVA_PLUGIN_VARIABLES_PROPERTY_NAME = "CordovaPluginVariables";
CordovaProjectPluginsService.HEADERS = ["Core Plugins", "Advanced Plugins", "Marketplace Plugins", "Local Plugins"];
exports.CordovaProjectPluginsService = CordovaProjectPluginsService;
$injector.register("cordovaProjectPluginsService", CordovaProjectPluginsService);
