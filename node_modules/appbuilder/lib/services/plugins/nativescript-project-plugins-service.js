"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const util = require("util");
const semver = require("semver");
const os_1 = require("os");
const helpers_1 = require("../../common/helpers");
const plugins_data_1 = require("../../plugins-data");
const helpers_2 = require("../../common/helpers");
const constants_1 = require("../../common/constants");
const plugins_service_base_1 = require("./plugins-service-base");
const temp = require("temp");
temp.track();
class NativeScriptProjectPluginsService extends plugins_service_base_1.PluginsServiceBase {
    constructor($nativeScriptResources, $typeScriptService, $pluginVariablesHelper, $projectMigrationService, $server, $errors, $logger, $prompter, $fs, $project, $projectConstants, $childProcess, $httpClient, $options, $npmService, $hostInfo, $npmPluginsService) {
        super($errors, $logger, $prompter, $fs, $project, $projectConstants, $childProcess, $httpClient, $options, $npmService, $npmPluginsService);
        this.$nativeScriptResources = $nativeScriptResources;
        this.$typeScriptService = $typeScriptService;
        this.$pluginVariablesHelper = $pluginVariablesHelper;
        this.$projectMigrationService = $projectMigrationService;
        this.$server = $server;
        this.featuredNpmPackages = [NativeScriptProjectPluginsService.NATIVESCRIPT_LIVEPATCH_PLUGIN_ID];
        let versions = this.$fs.readJson(this.$nativeScriptResources.nativeScriptMigrationFile).supportedVersions.map(version => version.version);
        let frameworkVersion = this.$project.projectData.FrameworkVersion;
        if (!_.includes(versions, frameworkVersion)) {
            this.$errors.failWithoutHelp(`Your project targets NativeScript version '${frameworkVersion}' which does not support plugins.`);
        }
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$projectMigrationService.migrateTypeScriptProject();
        });
    }
    getAvailablePlugins(pluginsCount) {
        return __awaiter(this, void 0, void 0, function* () {
            let count = pluginsCount || NativeScriptProjectPluginsService.DEFAULT_NUMBER_OF_NPM_PACKAGES;
            return _.concat(yield this.getUniqueMarketplacePlugins(), yield this.getTopNpmPackages(count), yield this.getTopNativeScriptNpmPackages(count), yield this.getFeaturedNpmPackages());
        });
    }
    getInstalledPlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            let pathToPackageJson = this.getPathToProjectPackageJson();
            if (this.$fs.exists(pathToPackageJson)) {
                let content = this.$fs.readJson(pathToPackageJson);
                if (content && content.dependencies) {
                    let pluginsToFilter = yield Promise.all(_.map(content.dependencies, (version, name) => __awaiter(this, void 0, void 0, function* () {
                        let marketplacePlugin = _.find(yield this.getMarketplacePlugins(), pl => pl.data.Name === name && pl.data.Version === version);
                        let plugin = marketplacePlugin ||
                            (yield this.getDataForNpmPackage(name, version)) ||
                            (yield this.getDataForLocalPlugin(name, version)) ||
                            (yield this.getDataFromGitHubUrl(name, version));
                        if (!plugin) {
                            this.$logger.warn(`Unable to find information about plugin '${name}' with version '${version}'.`);
                        }
                        return plugin;
                    })));
                    return _.filter(pluginsToFilter, i => !!i);
                }
            }
            return null;
        });
    }
    printPlugins(plugins) {
        return __awaiter(this, void 0, void 0, function* () {
            let groups = _.groupBy(plugins, (plugin) => plugin.type);
            let outputLines = [];
            _.each(Object.keys(groups), (group) => {
                outputLines.push(util.format("%s:%s======================", NativeScriptProjectPluginsService.HEADERS[+group], os_1.EOL));
                let sortedPlugins = _.sortBy(groups[group], (plugin) => plugin.data.Name);
                _.each(sortedPlugins, (plugin) => {
                    outputLines.push(plugin.pluginInformation.join(os_1.EOL));
                });
            });
            this.$logger.out(outputLines.join(os_1.EOL + os_1.EOL));
        });
    }
    addPlugin(pluginIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let pluginBasicInfo;
            if (yield this.isPluginInstalled(pluginIdentifier)) {
                this.$logger.printMarkdown(util.format("Plugin `%s` is already installed.", pluginIdentifier));
                return;
            }
            if (this.hasTgzExtension(pluginIdentifier)) {
                pluginBasicInfo = yield this.fetchPluginBasicInformation(path.resolve(pluginIdentifier), "add", null, { actualName: pluginIdentifier, isTgz: true, addPluginToConfigFile: false });
            }
            else if (yield this.checkIsValidLocalPlugin(pluginIdentifier)) {
                pluginBasicInfo = yield this.installLocalPlugin(pluginIdentifier, { actualName: pluginIdentifier, isTgz: false, addPluginToConfigFile: true });
            }
            else {
                pluginBasicInfo = yield this.setPluginInPackageJson(pluginIdentifier, { addPluginToPackageJson: true });
            }
            if (this.$typeScriptService.isTypeScriptProject(this.$project.projectDir)) {
                let installResult = yield this.$npmService.install(this.$project.projectDir, { installTypes: this.$options.types, name: pluginBasicInfo.name });
                if (installResult.error) {
                    this.$errors.failWithoutHelp(`Error while installing dependency: ${installResult.error.message}.`);
                }
            }
            this.$logger.printMarkdown(util.format("Successfully added plugin `%s`.", pluginBasicInfo.name));
        });
    }
    removePlugin(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            let pathToPackageJson = this.getPathToProjectPackageJson();
            let packageJsonContent = this.getProjectPackageJsonContent();
            let pluginBasicInfo = yield this.getPluginBasicInformation(pluginName);
            if (packageJsonContent.dependencies[pluginBasicInfo.name]) {
                let pathToPlugin = packageJsonContent.dependencies[pluginBasicInfo.name].toString().replace("file:", "");
                let fullPluginPath = path.join(this.$project.projectDir, pathToPlugin);
                if ((yield this.checkIsValidLocalPlugin(pathToPlugin)) || (this.hasTgzExtension(fullPluginPath) && this.isPluginPartOfTheProject(fullPluginPath))) {
                    this.$fs.deleteDirectory(fullPluginPath);
                }
                if (packageJsonContent.nativescript) {
                    delete packageJsonContent.nativescript[`${pluginBasicInfo.name}-variables`];
                }
                this.$fs.writeJson(pathToPackageJson, packageJsonContent);
                yield this.$npmService.uninstall(this.$project.projectDir, pluginBasicInfo.name);
                this.$logger.printMarkdown(util.format("Successfully removed plugin `%s`.", pluginBasicInfo.name));
            }
            else {
                this.$logger.printMarkdown(util.format("Plugin `%s` is not installed.", pluginBasicInfo.name));
            }
        });
    }
    configurePlugin(pluginName, version, configurations) {
        return __awaiter(this, void 0, void 0, function* () {
            let basicPluginInfo = yield this.getPluginBasicInformation(pluginName), packageJsonContent = this.getProjectPackageJsonContent(), dependencies = _.keys(packageJsonContent.dependencies);
            if (!_.some(dependencies, d => d === basicPluginInfo.name)) {
                this.$errors.failWithoutHelp(`Plugin ${pluginName} is not installed.`);
            }
            let pluginVersion = packageJsonContent.dependencies[basicPluginInfo.name].replace("file:", "");
            if (yield this.checkIsValidLocalPlugin(pluginVersion)) {
                yield this.installLocalPlugin(pluginVersion);
            }
            else {
                yield this.setPluginInPackageJson(pluginName);
            }
            this.$logger.printMarkdown(util.format("Successfully configured plugin `%s`.", basicPluginInfo.name));
        });
    }
    isPluginInstalled(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            let packageJsonContent = this.getProjectPackageJsonContent();
            let pluginBasicInfo = yield this.getPluginBasicInformation(pluginName);
            return packageJsonContent
                && !!packageJsonContent.dependencies && !!packageJsonContent.dependencies[pluginBasicInfo.name]
                && (!pluginBasicInfo.version || packageJsonContent.dependencies[pluginBasicInfo.name] === pluginBasicInfo.version) || this.isPluginFetched(pluginName);
        });
    }
    getPluginBasicInformation(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            let dependencyInfo = this.$npmService.getDependencyInformation(pluginName);
            return (yield this.getBasicPluginInfoFromMarketplace(dependencyInfo.name, dependencyInfo.version)) || { name: dependencyInfo.name, version: dependencyInfo.version };
        });
    }
    filterPlugins(plugins) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(plugins);
        });
    }
    getCopyLocalPluginData(pathToPlugin) {
        if (this.hasTgzExtension(pathToPlugin)) {
            return {
                sourceDirectory: pathToPlugin,
                destinationDirectory: path.join(this.$project.getProjectDir(), "plugins")
            };
        }
        else {
            return super.getCopyLocalPluginData(pathToPlugin);
        }
    }
    getPluginsDirName() {
        return constants_1.NODE_MODULES_DIR_NAME;
    }
    composeSearchQuery(keywords) {
        return keywords;
    }
    installLocalPluginCore(pathToPlugin, pluginData) {
        return __awaiter(this, void 0, void 0, function* () {
            let content = pluginData && pluginData.configFileContents || this.$fs.readJson(path.join(pathToPlugin, this.$projectConstants.PACKAGE_JSON_NAME));
            let name = content.name;
            let basicPluginInfo = {
                name: name,
                version: content.version,
                variables: content.nativescript && content.nativescript.variables
            };
            let pathToPackageJson = this.getPathToProjectPackageJson();
            let packageJsonContent = this.getProjectPackageJsonContent();
            if (pluginData && pluginData.addPluginToConfigFile) {
                packageJsonContent.dependencies[name] = "file:" + path.relative(this.$project.getProjectDir(), pathToPlugin);
            }
            if (name !== NativeScriptProjectPluginsService.NATIVESCRIPT_LIVEPATCH_PLUGIN_ID) {
                packageJsonContent = yield this.setPluginVariables(packageJsonContent, basicPluginInfo);
            }
            this.$fs.writeJson(pathToPackageJson, packageJsonContent);
            return basicPluginInfo;
        });
    }
    fetchPluginBasicInformationCore(pathToInstalledPlugin, version, pluginData, options) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (pluginData && pluginData.isTgz || this.$fs.exists(pluginData.actualName)) {
                pluginData.configFileContents = this.$fs.readJson(path.join(pathToInstalledPlugin, this.$projectConstants.PACKAGE_JSON_NAME));
            }
            pluginData.addPluginToConfigFile = true;
            return _super("installLocalPlugin").call(this, pluginData && pluginData.isTgz ? pluginData.actualName : pathToInstalledPlugin, pluginData, options);
        });
    }
    shouldCopyToPluginsDirectory(pathToPlugin) {
        return super.shouldCopyToPluginsDirectory(pathToPlugin) || pathToPlugin.indexOf(this.getPluginsDirName()) !== -1;
    }
    validatePluginInformation(pathToPlugin) {
        if (!this.$fs.exists(path.join(pathToPlugin, this.$projectConstants.PACKAGE_JSON_NAME))) {
            this.$errors.failWithoutHelp(`${path.basename(pathToPlugin)} is not a valid NativeScript plugin.`);
        }
    }
    getMarketplacePlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.marketplacePlugins || !this.marketplacePlugins.length) {
                try {
                    let plugins = yield this.$server.nativescript.getMarketplacePluginVersionsData();
                    this.marketplacePlugins = [];
                    _.each(plugins, plugin => {
                        let versions = _.map(plugin.Versions, (pluginVersionData) => new plugins_data_1.MarketplacePluginData(plugin, pluginVersionData, this.$project, this.$projectConstants));
                        this.marketplacePlugins = this.marketplacePlugins.concat(versions);
                    });
                }
                catch (err) {
                    this.$logger.trace("Unable to get NativeScript Marketplace plugins.");
                    this.$logger.trace(err);
                    this.marketplacePlugins = null;
                }
            }
            return this.marketplacePlugins;
        });
    }
    getUniqueMarketplacePlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            return _(yield this.getMarketplacePlugins())
                .groupBy(pl => pl.data.Name)
                .map((pluginGroup) => _(pluginGroup)
                .sortBy(gr => gr.data.Version)
                .last())
                .value();
        });
    }
    getPathToProjectPackageJson() {
        return path.join(this.$project.getProjectDir(), this.$projectConstants.PACKAGE_JSON_NAME);
    }
    getProjectPackageJsonContent() {
        let pathToPackageJson = this.getPathToProjectPackageJson();
        if (!this.$fs.exists(pathToPackageJson)) {
            this.$fs.copyFile(this.$nativeScriptResources.nativeScriptDefaultPackageJsonFile, pathToPackageJson);
        }
        return this.$fs.readJson(pathToPackageJson);
    }
    getTopNpmPackages(count) {
        return __awaiter(this, void 0, void 0, function* () {
            let plugins;
            try {
                let url = `${NativeScriptProjectPluginsService.NPM_SEARCH_URL}/query?fields=name,version,rating,homepage,description,repository,author&sort=rating+desc&start=0&size=${count}`;
                let result = (yield this.$httpClient.httpRequest(url)).body;
                if (result) {
                    let npmSearchResult = JSON.parse(result).results;
                    let pluginsToFilter = yield Promise.all(_.map(npmSearchResult, (pluginResult) => __awaiter(this, void 0, void 0, function* () {
                        if (pluginResult) {
                            let pluginInfo = {
                                Authors: pluginResult.author,
                                Name: this.getStringFromNpmSearchResult(pluginResult, "name"),
                                Identifier: this.getStringFromNpmSearchResult(pluginResult, "name"),
                                Version: this.getStringFromNpmSearchResult(pluginResult, "version"),
                                Url: this.getStringFromNpmSearchResult(pluginResult, "homepage"),
                                Platforms: [],
                                Description: this.getStringFromNpmSearchResult(pluginResult, "description"),
                                SupportedVersion: ""
                            };
                            pluginInfo.Variables = (yield this.getPluginVariablesInfoFromNpm(pluginInfo.Name, pluginInfo.Version)) || [];
                            return new NativeScriptPluginData(pluginInfo, PluginType.NpmPlugin, this.$project);
                        }
                        return null;
                    })));
                    plugins = _.filter(pluginsToFilter, pl => !!pl);
                }
            }
            catch (err) {
                this.$logger.trace("Unable to get top NPM packages.");
                this.$logger.trace(err);
            }
            return plugins;
        });
    }
    getStringFromNpmSearchResult(pluginResult, propertyName) {
        if (pluginResult && pluginResult[propertyName] && pluginResult[propertyName].length) {
            let item = _.first(pluginResult[propertyName]);
            if (item) {
                return item.toString();
            }
        }
        return "";
    }
    getFeaturedNpmPackages() {
        return __awaiter(this, void 0, void 0, function* () {
            let plugins = [];
            try {
                if (this.featuredNpmPackages && this.featuredNpmPackages.length) {
                    let pluginFutures = _.map(this.featuredNpmPackages, packageId => this.getDataForNpmPackage(packageId));
                    plugins = yield helpers_1.getFuturesResults(pluginFutures, pl => !!pl && !!pl.data);
                    _.each(plugins, featuredPackage => {
                        featuredPackage.type = PluginType.FeaturedPlugin;
                        if (featuredPackage.data.Identifier === NativeScriptProjectPluginsService.NATIVESCRIPT_LIVEPATCH_PLUGIN_ID) {
                            featuredPackage.data.Variables = [];
                            featuredPackage.data.Url = "";
                        }
                    });
                }
            }
            catch (err) {
                this.$logger.trace("Unable to get advanced NPM packages.");
                this.$logger.trace(err);
                plugins = null;
            }
            return plugins;
        });
    }
    getTopNativeScriptNpmPackages(count) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentPage = 0;
            let shouldBreak = false;
            let plugins = [];
            try {
                do {
                    let nativescriptUrl = `${NativeScriptProjectPluginsService.NPM_SEARCH_URL}/query?fields=name,version,rating&sort=rating+desc&q=keywords:nativescript+NativeScript&start=${currentPage * count}&size=${count}`;
                    let result = (yield this.$httpClient.httpRequest(nativescriptUrl)).body;
                    if (result) {
                        let npmSearchResults = JSON.parse(result).results;
                        shouldBreak = !npmSearchResults.length;
                        let pluginFutures = _.map(npmSearchResults, pluginResult => this.getDataForNpmPackage(this.getStringFromNpmSearchResult(pluginResult, "name"), this.getStringFromNpmSearchResult(pluginResult, "version")));
                        let allPlugins = yield helpers_1.getFuturesResults(pluginFutures, pl => !!pl && !!pl.data && !!pl.data.Platforms && pl.data.Platforms.length > 0);
                        plugins = plugins.concat(allPlugins.slice(0, count - plugins.length));
                    }
                    else {
                        shouldBreak = true;
                    }
                    currentPage++;
                } while (plugins.length < count && !shouldBreak);
            }
            catch (err) {
                this.$logger.trace("Unable to get top NativeScript NPM packages.");
                this.$logger.trace(err);
                plugins = null;
            }
            return plugins;
        });
    }
    getDataForNpmPackage(packageName, version) {
        return __awaiter(this, void 0, void 0, function* () {
            version = version || "latest";
            let result = yield this.$npmService.getPackageJsonFromNpmRegistry(packageName, version);
            if (result) {
                return yield this.constructNativeScriptPluginData(result);
            }
            return null;
        });
    }
    getDataForLocalPlugin(packageName, pathToPlugin) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!!pathToPlugin.match(/^file:/)) {
                pathToPlugin = pathToPlugin.replace("file:", "");
            }
            if (yield this.checkIsValidLocalPlugin(pathToPlugin)) {
                let fullPath = path.resolve(pathToPlugin);
                let packageJsonContent = this.$fs.readJson(path.join(fullPath, this.$projectConstants.PACKAGE_JSON_NAME));
                return yield this.constructNativeScriptPluginData(packageJsonContent);
            }
            return null;
        });
    }
    getDataFromGitHubUrl(packageName, url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!!url.match(/^(http|git)/)) {
                let pathToInstalledPackage = yield this.installPackageToTempDir(url);
                if (pathToInstalledPackage) {
                    let packageJsonContent = this.$fs.readJson(path.join(pathToInstalledPackage, this.$projectConstants.PACKAGE_JSON_NAME));
                    return yield this.constructNativeScriptPluginData(packageJsonContent);
                }
            }
            return null;
        });
    }
    constructNativeScriptPluginData(packageJsonContent) {
        return __awaiter(this, void 0, void 0, function* () {
            let platforms;
            let supportedVersion;
            let type = PluginType.NpmPlugin;
            if (packageJsonContent.nativescript && packageJsonContent.nativescript.platforms) {
                type = PluginType.NpmNativeScriptPlugin;
                platforms = _.keys(packageJsonContent.nativescript.platforms);
                supportedVersion = semver.maxSatisfying(_.values(packageJsonContent.nativescript.platforms), ">=0.0.0");
            }
            let data = {
                Authors: packageJsonContent.author ? [packageJsonContent.author.name || packageJsonContent.author] : null,
                Name: packageJsonContent.name,
                Identifier: packageJsonContent.name,
                Version: packageJsonContent.version,
                Url: (packageJsonContent.repository && packageJsonContent.repository.url) || packageJsonContent.homepage || '',
                Platforms: platforms,
                Description: packageJsonContent.description,
                SupportedVersion: supportedVersion,
                Variables: packageJsonContent.nativescript && packageJsonContent.nativescript.variables
            };
            return new NativeScriptPluginData(data, type, this.$project);
        });
    }
    checkIsValidLocalPlugin(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            let fullPath = path.resolve(pluginName);
            return this.$fs.exists(fullPath) && this.$fs.exists(path.join(fullPath, this.$projectConstants.PACKAGE_JSON_NAME));
        });
    }
    getBasicPluginInfoFromMarketplace(pluginName, version) {
        return __awaiter(this, void 0, void 0, function* () {
            let basicInfo;
            let allMarketplacePlugins = yield this.getMarketplacePlugins();
            let marketPlacePlugins = _.filter(allMarketplacePlugins, pl => pl.data.Identifier.toLowerCase() === pluginName.toLowerCase());
            if (marketPlacePlugins && marketPlacePlugins.length) {
                let selectedPlugin = this.selectMarketplacePlugin(marketPlacePlugins, version);
                if (selectedPlugin) {
                    basicInfo = {
                        name: selectedPlugin.data.Identifier,
                        version: selectedPlugin.data.Version
                    };
                    basicInfo.variables = yield this.getPluginVariablesInfoFromNpm(basicInfo.name, basicInfo.version);
                    if (!semver.satisfies(this.$project.projectData.FrameworkVersion, selectedPlugin.data.SupportedVersion)) {
                        this.$errors.failWithoutHelp(`Plugin ${pluginName} requires at least version ${selectedPlugin.data.SupportedVersion}, but your project targets ${this.$project.projectData.FrameworkVersion}.`);
                    }
                }
            }
            return basicInfo;
        });
    }
    selectMarketplacePlugin(marketPlacePlugins, version) {
        let plugin;
        if (this.$options.default && marketPlacePlugins.length) {
            version = this.getDefaultPluginVersion(marketPlacePlugins[0]);
        }
        if (!version || version === "latest") {
            version = _(marketPlacePlugins)
                .map((marketplacePlugin) => marketplacePlugin.data.Version)
                .sort((firstVersion, secondVersion) => semver.gt(firstVersion, secondVersion) ? -1 : 1)
                .first();
        }
        if (version && semver.valid(version)) {
            plugin = _.find(marketPlacePlugins, (marketPlacePlugin) => marketPlacePlugin.data.Version === version);
        }
        return plugin;
    }
    getBasicPluginInfoFromNpm(name, version) {
        return __awaiter(this, void 0, void 0, function* () {
            let basicInfo;
            let jsonInfo = yield this.$npmService.getPackageJsonFromNpmRegistry(name, version);
            if (jsonInfo) {
                basicInfo = {
                    name: jsonInfo.name,
                    version: jsonInfo.version,
                    variables: jsonInfo.nativescript && jsonInfo.nativescript.variables
                };
                if (jsonInfo.nativescript && jsonInfo.nativescript.platforms) {
                    const requiredVersions = _.values(jsonInfo.nativescript.platforms)
                        .filter(ver => !!semver.valid(ver));
                    const notSupportedValues = requiredVersions.filter(ver => semver.gt(ver, this.$project.projectData.FrameworkVersion));
                    if (requiredVersions.length && notSupportedValues.length === requiredVersions.length) {
                        this.$errors.failWithoutHelp(`Plugin ${name} requires newer version of NativeScript, your project targets ${this.$project.projectData.FrameworkVersion}.`);
                    }
                }
            }
            return basicInfo;
        });
    }
    getPluginVariablesInfoFromNpm(name, version) {
        return __awaiter(this, void 0, void 0, function* () {
            let jsonInfo = yield this.$npmService.getPackageJsonFromNpmRegistry(name, version);
            return jsonInfo && jsonInfo.nativescript && jsonInfo.nativescript.variables;
        });
    }
    getBasicPluginInfoFromUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            let basicInfo;
            if (!!url.match(/^(http|git)/)) {
                let pathToInstalledPackage = yield this.installPackageToTempDir(url);
                if (pathToInstalledPackage) {
                    let packageJson = this.$fs.readJson(path.join(pathToInstalledPackage, this.$projectConstants.PACKAGE_JSON_NAME));
                    basicInfo = {
                        name: packageJson.name,
                        version: url,
                        variables: packageJson.nativescript && packageJson.nativescript.variables
                    };
                }
            }
            return basicInfo;
        });
    }
    setPluginInPackageJson(pluginIdentifier, pluginOpts) {
        return __awaiter(this, void 0, void 0, function* () {
            let pathToPackageJson = this.getPathToProjectPackageJson(), packageJsonContent = this.getProjectPackageJsonContent(), pluginBasicInfo = yield this.getPluginBasicInformation(pluginIdentifier), name = pluginBasicInfo.name, selectedVersion = pluginBasicInfo.version || "latest", basicPlugin = (yield this.getBasicPluginInfoFromMarketplace(name, selectedVersion)) ||
                (yield this.getBasicPluginInfoFromNpm(name, selectedVersion)) ||
                (yield this.getBasicPluginInfoFromUrl(pluginIdentifier));
            if (!basicPlugin) {
                this.$errors.failWithoutHelp(`Unable to add plugin ${pluginIdentifier}. Make sure you've provided a valid name, path to local directory or git URL.`);
            }
            if (pluginOpts && pluginOpts.addPluginToPackageJson) {
                packageJsonContent.dependencies[basicPlugin.name] = basicPlugin.version;
            }
            if (basicPlugin.variables && pluginIdentifier !== NativeScriptProjectPluginsService.NATIVESCRIPT_LIVEPATCH_PLUGIN_ID) {
                packageJsonContent = yield this.setPluginVariables(packageJsonContent, basicPlugin);
            }
            this.$fs.writeJson(pathToPackageJson, packageJsonContent);
            return basicPlugin;
        });
    }
    setPluginVariables(packageJsonContent, basicPlugin) {
        return __awaiter(this, void 0, void 0, function* () {
            let variablesInformation = basicPlugin.variables;
            if (variablesInformation && _.keys(variablesInformation).length) {
                this.$logger.trace(`Plugin ${basicPlugin.name}@${basicPlugin.version} describes the following plugin variables:`);
                this.$logger.trace(variablesInformation);
                packageJsonContent.nativescript = packageJsonContent.nativescript || {};
                let pluginVariableNameInPackageJson = `${basicPlugin.name}-variables`;
                let currentVariablesValues = packageJsonContent.nativescript[pluginVariableNameInPackageJson] || {};
                let newObj = Object.create(null);
                for (let variableName in variablesInformation) {
                    let variableInfo = variablesInformation[variableName];
                    let currentValue = currentVariablesValues[variableName] || variableInfo.defaultValue;
                    newObj[variableName] = (yield this.gatherVariableInformation(variableName, currentValue))[variableName];
                }
                delete packageJsonContent.nativescript[pluginVariableNameInPackageJson];
                if (_.keys(newObj).length) {
                    packageJsonContent.nativescript[pluginVariableNameInPackageJson] = newObj;
                }
            }
            return packageJsonContent;
        });
    }
    gatherVariableInformation(variableName, defaultValue) {
        return __awaiter(this, void 0, void 0, function* () {
            let schema = {
                name: variableName,
                type: "input",
                message: `Set value for variable ${variableName}`,
                validate: (val) => !!val ? true : 'Please enter a value!'
            };
            if (defaultValue) {
                schema.default = () => defaultValue;
            }
            let fromVarOpion = this.$pluginVariablesHelper.getPluginVariableFromVarOption(variableName);
            if (!helpers_2.isInteractive() && !fromVarOpion) {
                if (defaultValue) {
                    this.$logger.trace(`Console is not interactive, so default value for ${variableName} will be used: ${defaultValue}.`);
                    let defaultObj = Object.create(null);
                    defaultObj[variableName] = defaultValue;
                    return defaultObj;
                }
                this.$errors.failWithoutHelp(`Unable to find value for ${variableName} plugin variable. Ensure the --var option is specified or the plugin variable has default value.`);
            }
            return fromVarOpion || (yield this.$prompter.get([schema]));
        });
    }
}
NativeScriptProjectPluginsService.NPM_SEARCH_URL = "http://npmsearch.com";
NativeScriptProjectPluginsService.HEADERS = ["NPM Packages", "NPM NativeScript Plugins", "Marketplace Plugins", "Advanced Plugins"];
NativeScriptProjectPluginsService.DEFAULT_NUMBER_OF_NPM_PACKAGES = 10;
NativeScriptProjectPluginsService.NATIVESCRIPT_LIVEPATCH_PLUGIN_ID = "nativescript-plugin-livepatch";
exports.NativeScriptProjectPluginsService = NativeScriptProjectPluginsService;
$injector.register("nativeScriptProjectPluginsService", NativeScriptProjectPluginsService);
var PluginType;
(function (PluginType) {
    PluginType[PluginType["NpmPlugin"] = 0] = "NpmPlugin";
    PluginType[PluginType["NpmNativeScriptPlugin"] = 1] = "NpmNativeScriptPlugin";
    PluginType[PluginType["MarketplacePlugin"] = 2] = "MarketplacePlugin";
    PluginType[PluginType["FeaturedPlugin"] = 3] = "FeaturedPlugin";
})(PluginType = exports.PluginType || (exports.PluginType = {}));
class NativeScriptPluginData {
    constructor(data, type, $project) {
        this.data = data;
        this.type = type;
        this.$project = $project;
        this.configurations = [];
    }
    get pluginInformation() {
        let additionalPluginData;
        if (this.data.Platforms && this.data.Platforms.length > 0) {
            additionalPluginData = [this.buildRow("Platforms", this.data.Platforms.join(", "))];
        }
        return this.composePluginInformation(additionalPluginData);
    }
    toProjectDataRecord(version) {
        return `"${this.data.Name}": "${version}"`;
    }
    buildRow(key, value) {
        return util.format("    %s: %s", key, value);
    }
    composePluginInformation(additionalPluginData) {
        let result = _.flatten([this.getBasicPluginInformation(), additionalPluginData]);
        return result;
    }
    getBasicPluginInformation() {
        let nameRow = this.buildRow("Plugin", this.data.Name);
        let versionRow = this.buildRow("Version", this.data.Version);
        let urlRow = this.buildRow("Url", this.data.Url);
        let result = [nameRow, versionRow, urlRow];
        if (this.data.Authors) {
            result.push(this.buildRow("Authors", this.data.Authors.join(", ")));
        }
        if (this.data.SupportedVersion) {
            let supportedVersion = this.buildRow("Supported Version", this.data.SupportedVersion);
            result.push(supportedVersion);
        }
        if (this.configurations && this.configurations.length > 0) {
            result.push(util.format("    Configuration: %s", this.configurations.join(", ")));
        }
        if (this.data.Variables && _.keys(this.data.Variables).length) {
            let varInfo = this.$project.getPluginVariablesInfo();
            if (varInfo && varInfo[this.data.Identifier]) {
                result.push("    Variables:");
                _.each(varInfo[this.data.Identifier], (variableValue, variableName) => {
                    result.push(`        ${variableName}: ${variableValue}`);
                });
            }
            else {
                let variables = _.keys(this.data.Variables).join(", ");
                result.push(`    Variables: ${variables}`);
            }
        }
        return result;
    }
}
exports.NativeScriptPluginData = NativeScriptPluginData;
