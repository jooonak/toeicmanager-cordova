"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const util = require("util");
const shelljs = require("shelljs");
const semver = require("semver");
const validUrl = require("valid-url");
const commonHelpers = require("../../common/helpers");
const constants_1 = require("../../common/constants");
const temp = require("temp");
temp.track();
class PluginsServiceBase {
    constructor($errors, $logger, $prompter, $fs, $project, $projectConstants, $childProcess, $httpClient, $options, $npmService, $npmPluginsService) {
        this.$errors = $errors;
        this.$logger = $logger;
        this.$prompter = $prompter;
        this.$fs = $fs;
        this.$project = $project;
        this.$projectConstants = $projectConstants;
        this.$childProcess = $childProcess;
        this.$httpClient = $httpClient;
        this.$options = $options;
        this.$npmService = $npmService;
        this.$npmPluginsService = $npmPluginsService;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve();
        });
    }
    findPlugins(keywords) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.$npmPluginsService.search(this.$project.projectDir, keywords, this.composeSearchQuery);
        });
    }
    fetch(pluginIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$project.ensureProject();
            if (!pluginIdentifier) {
                this.$errors.fail("You must specify local path, URL to a plugin repository, name or keywords of a plugin published to the NPM.");
            }
            if (this.isUrlToRepository(pluginIdentifier) || this.isLocalPath(pluginIdentifier)) {
                let options = {
                    useOriginalPluginDirectory: true
                };
                if (this.hasTgzExtension(pluginIdentifier)) {
                    pluginIdentifier = path.resolve(pluginIdentifier);
                    options.useOriginalPluginDirectory = false;
                }
                return yield this.fetchPluginCore(pluginIdentifier, null, options);
            }
            let plugin = _.find(yield this.getAvailablePlugins(), (pl) => pl.data.Identifier.toLowerCase() === pluginIdentifier || pl.data.Name.toLowerCase() === pluginIdentifier);
            let pluginUrl = plugin && plugin.data && plugin.data.Url ? plugin.data.Url : null;
            let plugins = yield (yield this.$npmPluginsService.optimizedSearch(this.$project.projectDir, [pluginIdentifier])).getAllPlugins();
            let pluginKeys = _.map(plugins, (pluginInfo) => pluginInfo.name);
            let pluginsCount = pluginKeys.length;
            if (pluginsCount === 0) {
                if (pluginUrl) {
                    try {
                        return yield this.fetchPluginCore(pluginUrl);
                    }
                    catch (error) {
                        this.$errors.failWithoutHelp(`The plugin cannot be downloaded using npm, because it has no package.json in it. You can still download it from this link: ${plugin.data.Url.grey}`);
                    }
                }
                else {
                    if (this.$fs.exists(path.resolve(pluginIdentifier))) {
                        return yield this.fetchPluginCore(pluginIdentifier);
                    }
                    else {
                        this.$errors.failWithoutHelp(`The plugin ${pluginIdentifier} was not found in npm and it is not path to existing local plugin.`);
                    }
                }
            }
            let npmPluginResult = plugins[0];
            if (pluginsCount > 1 && npmPluginResult.name !== pluginIdentifier) {
                if (commonHelpers.isInteractive()) {
                    let selectedPlugin = yield this.$prompter.promptForChoice("We found multiple plugins with your search parameters please choose which one you want to fetch.", pluginKeys);
                    return yield this.fetchPluginCore(selectedPlugin);
                }
                else {
                    this.$errors.failWithoutHelp("There are more then 1 matching plugins: " + pluginKeys.join(", ") + ".");
                }
            }
            try {
                return yield this.fetchPluginCore(npmPluginResult.name, npmPluginResult.version);
            }
            catch (err) {
                if (pluginUrl) {
                    this.$logger.trace("Error while trying to fetch plugin with id " + pluginIdentifier + " via npm. Error is: " + err.message + ".");
                    return yield this.fetchPluginCore(pluginUrl);
                }
                else {
                    this.$errors.failWithoutHelp(err.message);
                }
            }
        });
    }
    isPluginFetched(pluginName) {
        let projectPluginsDirectory = path.join(this.$project.projectDir, "plugins");
        let filterOptions = { enumerateDirectories: true, includeEmptyDirectories: false };
        if (!this.$fs.exists(projectPluginsDirectory)) {
            return false;
        }
        let fetchedPlugins = this.$fs.enumerateFilesInDirectorySync(projectPluginsDirectory, (item) => {
            let itemBaseName = path.basename(item);
            if (this.hasTgzExtension(item)) {
                itemBaseName = itemBaseName.replace(path.extname(itemBaseName), "");
                if (semver.valid(itemBaseName.substr(itemBaseName.lastIndexOf("-") + 1))) {
                    itemBaseName = itemBaseName.substring(0, itemBaseName.lastIndexOf("-"));
                }
            }
            return itemBaseName === pluginName;
        }, filterOptions);
        return !!(fetchedPlugins && fetchedPlugins.length);
    }
    hasTgzExtension(pluginidentifier) {
        let pluginIdentifierExtname = path.extname(pluginidentifier);
        return this.isLocalPath(pluginidentifier) && (pluginIdentifierExtname === ".tgz" || pluginIdentifierExtname === ".gz");
    }
    fetchPluginBasicInformation(pluginIdentifier, version, failMessageMethodName, pluginData, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let pathToInstalledPlugin = yield this.installPackageToTempDir(pluginIdentifier, version);
            this.validatePluginInformation(pathToInstalledPlugin);
            let installLocalPluginOptions = {
                actualName: pluginData && pluginData.actualName,
                isTgz: pluginData && pluginData.isTgz,
                addPluginToConfigFile: false,
                suppressMessage: pluginData && pluginData.suppressMessage,
                configFileContents: pluginData.configFileContents
            };
            if (pathToInstalledPlugin) {
                return yield this.fetchPluginBasicInformationCore(pathToInstalledPlugin, version, installLocalPluginOptions, options);
            }
            else {
                let errorMessage = ("Unable to " + failMessageMethodName + " plugin " + pluginIdentifier + ".") +
                    " Make sure this is a valid plugin name, path to existing directory or git URL.";
                this.$errors.failWithoutHelp(errorMessage);
            }
        });
    }
    installPackageToTempDir(identifier, version) {
        return __awaiter(this, void 0, void 0, function* () {
            let tempInstallDir = temp.mkdirSync("pluginInstallation");
            try {
                let packageJsonData = {
                    name: "tempPackage",
                    version: "1.0.0"
                };
                this.$fs.writeJson(path.join(tempInstallDir, this.$projectConstants.PACKAGE_JSON_NAME), packageJsonData);
                if (version) {
                    identifier = `${identifier}@${version}`;
                }
                let npmInstallOutput = yield this.$childProcess.exec(`npm install ${identifier} --production --ignore-scripts`, { cwd: tempInstallDir });
                let pathToPackage = path.join(tempInstallDir, constants_1.NODE_MODULES_DIR_NAME);
                if (this.$fs.exists(pathToPackage)) {
                    let dirs = this.$fs.readDirectory(pathToPackage).filter(dirName => dirName !== ".bin");
                    if (dirs.length === 1) {
                        let pathToPlugin = path.join(pathToPackage, _.first(dirs));
                        this.removeFetchedPluginDependencies(pathToPlugin);
                        return pathToPlugin;
                    }
                }
                let npm2OutputMatch = npmInstallOutput.match(/.*?tempPackage@1\.0\.0.*?\r?\n.*?\s+?(.*?)@.*?\s+?/m);
                if (npm2OutputMatch) {
                    let pathToPlugin = path.join(tempInstallDir, constants_1.NODE_MODULES_DIR_NAME, npm2OutputMatch[1]);
                    this.removeFetchedPluginDependencies(pathToPlugin);
                    return pathToPlugin;
                }
                let npmOutputMatchRegExp = /.*?@.*?\s+?(.*?node_modules.*?)\r?\n?$/;
                let pluginDirectory = _(npmInstallOutput)
                    .split("\n")
                    .map((row) => {
                    row = row && row.trim();
                    let matches = npmOutputMatchRegExp.exec(row);
                    return matches && matches.length ? matches[1] : undefined;
                })
                    .filter((row) => !!row)
                    .last();
                if (pluginDirectory) {
                    let pathToPlugin = path.join(tempInstallDir, pluginDirectory);
                    this.removeFetchedPluginDependencies(pathToPlugin);
                    return pathToPlugin;
                }
            }
            catch (err) {
                throw err;
            }
            return null;
        });
    }
    installLocalPlugin(pluginPath, pluginData, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let pathToPlugin = (options && options.useOriginalPluginDirectory) ? options.originalPluginDirectory : path.resolve(pluginPath);
            if (this.shouldCopyToPluginsDirectory(pathToPlugin)) {
                let copyLocalPluginData = this.getCopyLocalPluginData(pathToPlugin);
                let pathToInstall = copyLocalPluginData.destinationDirectory;
                if (!pluginData || !pluginData.suppressMessage) {
                    let actualPlugin = pluginData ? path.resolve(pluginData.actualName) : pluginPath;
                    this.$logger.printMarkdown(util.format("Copying `%s` to `%s` in order to be able to use the plugin in your project.", actualPlugin, pathToInstall));
                }
                this.$fs.ensureDirectoryExists(pathToInstall);
                shelljs.cp("-Rf", copyLocalPluginData.sourceDirectory, pathToInstall);
                pathToPlugin = pathToInstall;
            }
            return yield this.installLocalPluginCore(pathToPlugin, pluginData);
        });
    }
    getCopyLocalPluginData(pathToPlugin) {
        let lastIndexOfNodeModules = pathToPlugin.lastIndexOf(constants_1.NODE_MODULES_DIR_NAME);
        let targetPluginDirectory = lastIndexOfNodeModules !== -1 ? pathToPlugin.substring(lastIndexOfNodeModules + constants_1.NODE_MODULES_DIR_NAME.length) : path.basename(pathToPlugin);
        return {
            sourceDirectory: path.join(pathToPlugin, path.sep, "*"),
            destinationDirectory: path.join(this.$project.getProjectDir(), "plugins", targetPluginDirectory)
        };
    }
    isPluginPartOfTheProject(pathToPlugin) {
        return pathToPlugin.indexOf(this.$project.getProjectDir()) !== -1;
    }
    shouldCopyToPluginsDirectory(pluginPath) {
        return !this.isPluginPartOfTheProject(pluginPath);
    }
    getDefaultPluginVersion(plugin) {
        return plugin.pluginVersionsData.DefaultVersion;
    }
    fetchPluginCore(pluginIdentifier, version, options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = options === undefined ? { useOriginalPluginDirectory: false } : options;
            let pluginBasicInfo;
            let pluginLocalPath = path.resolve(pluginIdentifier);
            let pluginLocalPathExists = this.$fs.exists(pluginLocalPath);
            let suppressMessage = pluginLocalPathExists && (pluginLocalPath.indexOf(this.$project.getProjectDir()) === -1 || pluginLocalPath.indexOf(this.getPluginsDirName()) !== -1);
            let pluginData = {
                actualName: pluginIdentifier,
                isTgz: this.hasTgzExtension(pluginIdentifier),
                addPluginToConfigFile: false,
                suppressMessage: !suppressMessage
            };
            let pluginId = pluginIdentifier;
            if (pluginLocalPathExists) {
                pluginId = pluginLocalPath;
                options.originalPluginDirectory = pluginLocalPath;
            }
            else {
                options.useOriginalPluginDirectory = false;
            }
            pluginBasicInfo = yield this.fetchPluginBasicInformation(pluginId, version, "fetch", pluginData, options);
            return pluginBasicInfo.name;
        });
    }
    isLocalPath(pluginId) {
        return this.$fs.exists(pluginId);
    }
    isUrlToRepository(pluginId) {
        return validUrl.isUri(pluginId);
    }
    removeFetchedPluginDependencies(pathToPlugin) {
        let dependenciesDirectory = path.join(pathToPlugin, constants_1.NODE_MODULES_DIR_NAME);
        return this.$fs.deleteDirectory(dependenciesDirectory);
    }
}
exports.PluginsServiceBase = PluginsServiceBase;
