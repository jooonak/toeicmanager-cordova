"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const util = require("util");
const helpers_1 = require("../common/helpers");
const decorators_1 = require("../common/decorators");
class ScreenBuilderService {
    constructor($appScaffoldingExtensionsService, $dependencyConfigService, $errors, $fs, $injector, $logger, $prompter) {
        this.$appScaffoldingExtensionsService = $appScaffoldingExtensionsService;
        this.$dependencyConfigService = $dependencyConfigService;
        this.$errors = $errors;
        this.$fs = $fs;
        this.$injector = $injector;
        this.$logger = $logger;
        this.$prompter = $prompter;
        this.shouldUpgradeCached = null;
        this.allCommandsCache = null;
        this.scaffolder = null;
        this.screenBuilderSpecificFiles = [".yo-rc.json", ".app.json", "app.js"];
    }
    get generatorFullName() {
        return "generator-" + this.generatorName;
    }
    get generatorName() {
        return "kendo-ui-mobile";
    }
    get commandsPrefix() {
        return "add";
    }
    printDeprecationWarning() {
        this.$logger.warn(this.getDeprecationWarning());
    }
    getDeprecationWarning() {
        return "This command is deprecated and will be removed in the next official release.";
    }
    promptForUpgrade(projectPath, generatorName, screenBuilderOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let wasMigrated = !(yield this.shouldUpgrade(projectPath)), didMigrate = false;
            if (!wasMigrated) {
                this.$logger.error(ScreenBuilderService.UPGRADE_ERROR_MESSAGE_SHOWN_ON_THE_CONSOLE);
                didMigrate = yield this.$prompter.confirm('Do you want to upgrade your project now? Custom code changes might be lost.', () => false);
                if (didMigrate) {
                    let scaffolderData = yield this.createScaffolder(projectPath, generatorName, screenBuilderOptions);
                    scaffolderData.scaffolder.upgrade(scaffolderData.callback);
                    yield scaffolderData.promise;
                }
            }
            return { wasMigrated: wasMigrated, didMigrate: didMigrate };
        });
    }
    prepareAndGeneratePrompt(projectPath, generatorName, screenBuilderOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            generatorName = generatorName || this.generatorFullName;
            let migrationData = yield this.promptForUpgrade(projectPath, generatorName, screenBuilderOptions), disableCommandHelpSuggestion = !migrationData.didMigrate;
            if (migrationData.wasMigrated || migrationData.didMigrate) {
                yield (yield this.promptGenerate(projectPath, generatorName, screenBuilderOptions)).promise;
            }
            return disableCommandHelpSuggestion;
        });
    }
    allSupportedCommands(projectDir, generatorName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allCommandsCache) {
                generatorName = generatorName || this.generatorFullName;
                let scaffolder = (yield this.createScaffolder(projectDir, generatorName, { isSync: true })).scaffolder;
                let allSupportedCommands = scaffolder.listGenerators()
                    .map((command) => command.replace(new RegExp(this.generatorName + ":?"), ''))
                    .filter((command) => !!command);
                this.allCommandsCache = _.map(allSupportedCommands, (command) => util.format("%s-%s", this.commandsPrefix, command.toLowerCase()));
            }
            return this.allCommandsCache;
        });
    }
    generateAllCommands(projectDir, generatorName) {
        return __awaiter(this, void 0, void 0, function* () {
            generatorName = generatorName || this.generatorFullName;
            let commands = yield this.allSupportedCommands(projectDir, generatorName);
            _.each(commands, (command) => this.registerCommand(command, generatorName));
        });
    }
    composeScreenBuilderOptions(answers, bacisSceenBuilderOptions) {
        let screenBuilderOptions = bacisSceenBuilderOptions || {};
        if (answers) {
            screenBuilderOptions.answers = this.$fs.readJson(path.resolve(answers));
        }
        return screenBuilderOptions;
    }
    promptGenerate(projectPath, generatorName, screenBuilderOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            generatorName = generatorName || this.generatorFullName;
            let scaffolderData = yield this.createScaffolder(projectPath, generatorName, screenBuilderOptions);
            let scaffolder = scaffolderData.scaffolder;
            let type = screenBuilderOptions.type || ScreenBuilderService.DEFAULT_SCREENBUILDER_TYPE;
            type = ScreenBuilderService.PREDEFINED_SCREENBUILDER_TYPES[type] || type;
            if (type === ScreenBuilderService.DEFAULT_SCREENBUILDER_TYPE || screenBuilderOptions.answers) {
                scaffolder.promptGenerate(type, screenBuilderOptions.answers, scaffolderData.callback);
            }
            else {
                scaffolder.promptGenerate(type, scaffolderData.callback);
            }
            return scaffolderData;
        });
    }
    ensureScreenBuilderProject(projectDir) {
        this.printDeprecationWarning();
        if (!_.every(this.screenBuilderSpecificFiles, file => this.$fs.exists(path.join(projectDir, file)))) {
            this.$errors.failWithoutHelp("This command is applicable only to Screen Builder projects.");
        }
    }
    shouldUpgrade(projectPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.shouldUpgradeCached) {
                let scaffolderData = yield this.createScaffolder(projectPath, this.generatorFullName);
                scaffolderData.scaffolder.initContext({ collectMetadata: true }, scaffolderData.callback);
                this.shouldUpgradeCached = (yield scaffolderData.promise) === ScreenBuilderService.UPGRADE_ERROR_MESSAGE_SHOWN_ON_THE_CONSOLE;
            }
            return this.shouldUpgradeCached;
        });
    }
    upgrade(projectPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.shouldUpgrade(projectPath))) {
                return;
            }
            let scaffolderData = yield this.createScaffolder(this.generatorFullName, projectPath);
            scaffolderData.scaffolder.upgrade(scaffolderData.callback);
            yield scaffolderData.promise;
        });
    }
    getScaffolder(projectPath, generatorName, screenBuilderOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.scaffolder) {
                yield this.$appScaffoldingExtensionsService.prepareAppScaffolding();
                let generatorConfig = this.$dependencyConfigService.getGeneratorConfig(generatorName);
                let appScaffoldingPath = this.$appScaffoldingExtensionsService.appScaffoldingPath;
                let cliServicePath = path.join(appScaffoldingPath, "lib/cliService");
                let Scaffolder = require(cliServicePath);
                let connector = {
                    generatorsCache: appScaffoldingPath,
                    path: screenBuilderOptions && screenBuilderOptions.projectPath || path.resolve(projectPath || "."),
                    dependencies: [util.format("%s@%s", generatorName, generatorConfig.version)],
                    connect: (done) => {
                        done();
                    },
                    logger: this.$logger.trace.bind(this.$logger)
                };
                this.scaffolder = new Scaffolder(connector);
            }
            return this.scaffolder;
        });
    }
    createScaffolder(projectPath, generatorName, screenBuilderOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            screenBuilderOptions = screenBuilderOptions || {};
            let scaffolder = yield this.getScaffolder(projectPath, generatorName, screenBuilderOptions);
            if (screenBuilderOptions && screenBuilderOptions.isSync) {
                return { scaffolder: scaffolder, promise: null, callback: null };
            }
            let deferredPromise = yield helpers_1.deferPromise();
            let callback = (err, data) => {
                if (err) {
                    let error = this.getErrorsRecursive(err).join('\n');
                    this.$logger.trace(`Screen Builder error while prompting: ${err.message}`);
                    if (~ScreenBuilderService.UPGRADE_ERROR_MESSAGES.indexOf(err.message)) {
                        if (deferredPromise.isPending()) {
                            deferredPromise.resolve(ScreenBuilderService.UPGRADE_ERROR_MESSAGE_SHOWN_ON_THE_CONSOLE);
                        }
                    }
                    else {
                        if (deferredPromise.isPending()) {
                            deferredPromise.reject(new Error(error));
                        }
                    }
                }
                else {
                    if (deferredPromise.isPending()) {
                        deferredPromise.resolve(data);
                    }
                }
            };
            return { scaffolder: scaffolder, promise: deferredPromise.promise, callback: callback };
        });
    }
    getErrorsRecursive(errorObject) {
        let errorMessage = errorObject.message, childErrors = _(errorObject.errors)
            .map(errObj => this.getErrorsRecursive(errObj))
            .flatten()
            .value();
        return _.union([errorMessage], childErrors);
    }
    registerCommand(command, generatorName) {
        this.$injector.requireCommand(command, "./commands/user-status");
        this.$injector.registerCommand(command, this.createResolver(command, generatorName));
    }
    createResolver(command, generatorName) {
        return this.$injector.resolve(ScreenBuilderDynamicCommand, { command: command, generatorName: generatorName });
    }
}
ScreenBuilderService.UPGRADE_ERROR_MESSAGES = ["Your app has been build with an obsolete version of Screen Builder. Please, migrate it to latest version and retry.",
    "Your app has been created with an obsolete version of Screen Builder. Upgrade your project to the latest version and try again."];
ScreenBuilderService.UPGRADE_ERROR_MESSAGE_SHOWN_ON_THE_CONSOLE = "Your app has been created with an obsolete version of Screen Builder. You need to upgrade your project to be able to run Screen Builder-related commands.";
ScreenBuilderService.DEFAULT_SCREENBUILDER_TYPE = "application";
ScreenBuilderService.PREDEFINED_SCREENBUILDER_TYPES = {
    dataprovider: "dataProvider"
};
__decorate([
    decorators_1.cache()
], ScreenBuilderService.prototype, "printDeprecationWarning", null);
__decorate([
    decorators_1.cache()
], ScreenBuilderService.prototype, "getDeprecationWarning", null);
exports.ScreenBuilderService = ScreenBuilderService;
$injector.register("screenBuilderService", ScreenBuilderService);
class ScreenBuilderDynamicCommand {
    constructor(generatorName, command, $options, $project, $screenBuilderService) {
        this.generatorName = generatorName;
        this.command = command;
        this.$options = $options;
        this.$project = $project;
        this.$screenBuilderService = $screenBuilderService;
        this.allowedParameters = [];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$project.ensureProject();
            let projectDir = this.$project.getProjectDir();
            this.$screenBuilderService.ensureScreenBuilderProject(projectDir);
            let screenBuilderOptions = this.$screenBuilderService.composeScreenBuilderOptions(this.$options.answers, {
                type: this.command.substr(this.command.indexOf("-") + 1)
            });
            this.disableCommandHelpSuggestion = yield this.$screenBuilderService.prepareAndGeneratePrompt(projectDir, this.generatorName, screenBuilderOptions);
        });
    }
}
