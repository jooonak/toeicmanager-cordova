"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const semver = require("semver");
const helpers = require("../helpers");
class RenamedPlugin {
    constructor(version, oldName, newName) {
        this.version = version;
        this.oldName = oldName;
        this.newName = newName;
    }
}
class MigrationData {
    constructor(renamedPlugins, supportedVersions, integratedPlugins, supportedFrameworkVersions, corePluginRegex) {
        this.renamedPlugins = renamedPlugins;
        this.supportedVersions = supportedVersions;
        this.integratedPlugins = integratedPlugins;
        this.supportedFrameworkVersions = supportedFrameworkVersions;
        this.corePluginRegex = corePluginRegex;
    }
}
class CordovaMigrationService {
    constructor($cordovaResources, $errors, $fs, $logger, $mobileHelper, $project, $projectConstants, $projectPropertiesService, $prompter, $resources, $server, $serverConfiguration, $webViewService, $injector) {
        this.$cordovaResources = $cordovaResources;
        this.$errors = $errors;
        this.$fs = $fs;
        this.$logger = $logger;
        this.$mobileHelper = $mobileHelper;
        this.$project = $project;
        this.$projectConstants = $projectConstants;
        this.$projectPropertiesService = $projectPropertiesService;
        this.$prompter = $prompter;
        this.$resources = $resources;
        this.$server = $server;
        this.$serverConfiguration = $serverConfiguration;
        this.$webViewService = $webViewService;
        this.$injector = $injector;
        this.minSupportedVersion = "3.0.0";
        this.invalidMarketplacePlugins = [];
        this.cordovaMigrationFile = path.join(__dirname, "../../resources/Cordova", "cordova-migration-data.json");
    }
    get $pluginsService() {
        return this.$injector.resolve("pluginsService");
    }
    get migrationData() {
        if (!this._migrationData) {
            this._migrationData = this.$fs.readJson(this.cordovaMigrationFile);
        }
        return this._migrationData;
    }
    get $resourceDownloader() {
        if (!this._resourceDownloader) {
            this._resourceDownloader = this.$injector.resolve("resourceDownloader");
        }
        return this._resourceDownloader;
    }
    getCordovaJsonData() {
        return this.$fs.readJson(this.cordovaJsonFilePath);
    }
    getDisplayNameForVersion(version) {
        let supportedFrameworks = this.getSupportedFrameworks();
        let framework = _.find(supportedFrameworks, (fw) => fw.version === version);
        if (framework) {
            return framework.displayName;
        }
        this.$logger.error(`Version ${version} in not supported.`);
        return null;
    }
    getSupportedFrameworks() {
        return this.migrationData.supportedFrameworkVersions;
    }
    getSupportedVersions() {
        return this.migrationData.supportedVersions;
    }
    pluginsForVersion(version) {
        return this.migrationData.integratedPlugins[version] || [];
    }
    migratePlugins(plugins, fromVersion, toVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            let isUpgrade = helpers.versionCompare(fromVersion, toVersion) < 0;
            let smallerVersion = isUpgrade ? fromVersion : toVersion;
            let biggerVersion = isUpgrade ? toVersion : fromVersion;
            let renames = _.filter(this.migrationData.renamedPlugins, (renamedPlugin) => {
                return helpers.versionCompare(smallerVersion, renamedPlugin.version) <= 0 && helpers.versionCompare(renamedPlugin.version, biggerVersion) <= 0;
            }).sort((a, b) => helpers.versionCompare(a.version, b.version) * (isUpgrade ? 1 : -1));
            let transitions = _.map(renames, rename => isUpgrade ? { from: rename.oldName, to: rename.newName } : { from: rename.newName, to: rename.oldName });
            plugins = this.applyTransitions(plugins, transitions);
            let supportedPlugins = this.pluginsForVersion(toVersion);
            plugins = _.filter(plugins, plugin => _.includes(supportedPlugins, plugin) || (_.includes(plugin, '@') && !_.includes(this.invalidMarketplacePlugins, plugin)));
            let cordovaJsonData = this.getCordovaJsonData();
            let sourceSupportedPlugins = this.pluginsForVersion(fromVersion);
            let sourceSupportedPluginsRenamed = this.applyTransitions(sourceSupportedPlugins, transitions);
            let defaultEnabledPluginsIncludeRegex = new RegExp(cordovaJsonData.defaultEnabledPluginsIncludeRegex);
            let defaultEnabledPluginsExcludeRegex = new RegExp(cordovaJsonData.defaultEnabledPluginsExcludeRegex);
            let newEnabledPlugins = _(supportedPlugins)
                .filter(p => p.match(defaultEnabledPluginsIncludeRegex) && !p.match(defaultEnabledPluginsExcludeRegex))
                .difference(sourceSupportedPluginsRenamed)
                .value();
            return _.union(plugins, newEnabledPlugins);
        });
    }
    downloadMigrationData() {
        return __awaiter(this, void 0, void 0, function* () {
            let json = yield this.$server.cordova.getMigrationData();
            let renamedPlugins = _.map(json.RenamedPlugins, (plugin) => new RenamedPlugin(this.parseMscorlibVersion(plugin.Version), plugin.OldName, plugin.NewName));
            let supportedVersions = _.map(json.SupportedVersions, plugin => this.parseMscorlibVersion(plugin));
            let cliSupportedVersions = _.filter(supportedVersions, (version) => helpers.versionCompare(version, this.minSupportedVersion) >= 0);
            let integratedPlugins = {};
            _.each(cliSupportedVersions, version => {
                integratedPlugins[version] = json.IntegratedPlugins[version];
            });
            let supportedFrameworkVersion = _(json.SupportedFrameworkVersions)
                .map((fv) => { return { displayName: fv.DisplayName, version: this.parseMscorlibVersion(fv.Version) }; })
                .filter(fv => _.includes(cliSupportedVersions, fv.version))
                .value();
            this._migrationData = new MigrationData(renamedPlugins, cliSupportedVersions, integratedPlugins, supportedFrameworkVersion, json.CorePluginRegex);
            this.$fs.writeJson(this.cordovaMigrationFile, this._migrationData);
            yield this.downloadMigrationConfigFile();
        });
    }
    downloadMigrationConfigFile(targetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let cordovaJsonPath = `${yield this.$serverConfiguration.resourcesPath()}/cordova/cordova.json`;
            yield this.$resourceDownloader.downloadResourceFromServer(cordovaJsonPath, targetPath || this.cordovaJsonFilePath);
        });
    }
    onWPSdkVersionChanging(newVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (newVersion === this.$project.projectData["WPSdk"]) {
                return;
            }
            let validWPSdks = yield this.getSupportedWPFrameworks();
            if (!_.includes(validWPSdks, newVersion)) {
                this.$errors.failWithoutHelp("The selected version %s is not supported. Supported versions are %s", newVersion, validWPSdks.join(", "));
            }
            this.$logger.info("Migrating to WPSdk version %s", newVersion);
            if (helpers.versionCompare(newVersion, "8.0") > 0) {
                if (helpers.versionCompare(this.$project.projectData.FrameworkVersion, "4.0.0") < 0) {
                    let cordovaVersions = this.getSupportedFrameworks();
                    let selectedFramework = _.findLast(cordovaVersions, cv => cv.displayName.indexOf(this.$projectConstants.EXPERIMENTAL_TAG) === -1);
                    if (helpers.versionCompare(selectedFramework.version, "4.0.0") < 0) {
                        selectedFramework = _.findLast(cordovaVersions, cv => cv.displayName.indexOf(this.$projectConstants.EXPERIMENTAL_TAG) !== -1 && helpers.versionCompare("4.0.0", cv.version) <= 0);
                    }
                    let promptStr = `You cannot build with the Windows Phone ${newVersion} SDK with the currently selected target version of Apache Cordova. Do you want to switch to ${selectedFramework.displayName}?`;
                    let shouldUpdateFramework = yield this.$prompter.confirm(promptStr);
                    if (shouldUpdateFramework) {
                        yield this.onFrameworkVersionChanging(selectedFramework.version);
                        this.$project.projectData.FrameworkVersion = selectedFramework.version;
                    }
                    else {
                        this.$errors.failWithoutHelp("Unable to set Windows Phone %s as the target SDK. Migrate to Apache Cordova 4.0.0 or later and try again.", newVersion);
                    }
                }
            }
        });
    }
    onFrameworkVersionChanging(newVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (newVersion === this.$project.projectData.FrameworkVersion) {
                return;
            }
            let versionDisplayName = this.getDisplayNameForVersion(newVersion);
            this.$project.ensureAllPlatformAssets();
            if (this.$project.projectData.WPSdk && helpers.versionCompare(this.$project.projectData.WPSdk, "8.0") > 0 && helpers.versionCompare(newVersion, "3.7.0") < 0) {
                let shouldUpdateWPSdk = yield this.$prompter.confirm(`You cannot build with the Windows Phone ${this.$project.projectData.WPSdk} SDK with the currently selected target version of Apache Cordova. Do you want to switch to Windows Phone 8.0 SDK?`);
                if (shouldUpdateWPSdk) {
                    yield this.onWPSdkVersionChanging("8.0");
                    this.$project.projectData.WPSdk = "8.0";
                }
                else {
                    this.$errors.failWithoutHelp("Unable to set %s as the target Apache Cordova version. Set the target Windows Phone SDK to 8.0 and try again.", newVersion);
                }
            }
            this.$logger.info("Migrating to Cordova version %s", versionDisplayName);
            let oldVersion = this.$project.projectData.FrameworkVersion;
            let availablePlugins = yield this.$pluginsService.getAvailablePlugins();
            yield this.migrateWebView(oldVersion, newVersion);
            let pluginsToFilter = _(this.$project.configurations)
                .map(configuration => this.$project.getProperty("CorePlugins", configuration))
                .union()
                .flatten()
                .uniq()
                .value();
            let filteredPlugins = yield Promise.all(_.map(pluginsToFilter, (plugin) => __awaiter(this, void 0, void 0, function* () {
                let pluginBasicInformation = yield this.$pluginsService.getPluginBasicInformation(plugin);
                return _.includes(plugin, '@') && !_.some(availablePlugins, pl => pl.data.Identifier.toLowerCase() === pluginBasicInformation.name.toLowerCase() && pl.data.Version === pluginBasicInformation.version) ? plugin : null;
            })));
            this.invalidMarketplacePlugins = _.filter(filteredPlugins);
            if (this.invalidMarketplacePlugins.length > 0) {
                yield this.promptUserForInvalidPluginsAction(this.invalidMarketplacePlugins, newVersion);
            }
            let cordovaJsonData = this.getCordovaJsonData();
            if (semver.gte(newVersion, cordovaJsonData.forceHardwareAccelerationAfter)) {
                this.$project.projectData.AndroidHardwareAcceleration = "true";
                this.$project.saveProject();
            }
            yield Promise.all(_.map(this.invalidMarketplacePlugins, (plugin) => __awaiter(this, void 0, void 0, function* () {
                let name = (yield this.$pluginsService.getPluginBasicInformation(plugin)).name;
                yield this.$pluginsService.removePlugin(name);
            })));
            yield Promise.all(_.map(this.$project.configurations, (configuration) => __awaiter(this, void 0, void 0, function* () {
                let oldPluginsList = this.$project.getProperty("CorePlugins", configuration);
                let newPluginsList = yield this.migratePlugins(oldPluginsList, oldVersion, newVersion);
                this.$logger.trace("Migrated core plugins to: ", helpers.formatListOfNames(newPluginsList, "and"));
                this.$project.setProperty("CorePlugins", newPluginsList, configuration);
            })));
            this.migrateCordovaJsFiles(newVersion);
            this.$logger.info("Successfully migrated to version %s", versionDisplayName);
        });
    }
    getSupportedPlugins() {
        let version;
        if (this.$project.projectData) {
            version = this.$project.projectData.FrameworkVersion;
        }
        else {
            let selectedFramework = _.findLast(this.getSupportedFrameworks(), (sv) => sv.displayName.indexOf(this.$projectConstants.EXPERIMENTAL_TAG) === -1);
            version = selectedFramework.version;
        }
        return this.pluginsForVersion(version);
    }
    get cordovaJsonFilePath() {
        return path.join(this.$resources.resolvePath(CordovaMigrationService.CORDOVA_FOLDER_NAME), CordovaMigrationService.CORDOVA_JSON_FILE_NAME);
    }
    migrateCordovaJsFiles(newVersion) {
        let backedUpFiles = [], backupSuffix = ".backup";
        try {
            _.each(this.$mobileHelper.platformNames, (platform) => {
                this.$logger.trace("Replacing cordova.js file for %s platform ", platform);
                let cordovaJsFileName = path.join(this.$project.getProjectDir(), `cordova.${platform}.js`.toLowerCase());
                let cordovaJsSourceFilePath = this.$cordovaResources.buildCordovaJsFilePath(newVersion, platform);
                this.$fs.copyFile(cordovaJsFileName, cordovaJsFileName + backupSuffix);
                backedUpFiles.push(cordovaJsFileName);
                this.$fs.copyFile(cordovaJsSourceFilePath, cordovaJsFileName);
            });
        }
        catch (error) {
            _.each(backedUpFiles, file => {
                this.$logger.trace("Reverting %s", file);
                this.$fs.copyFile(file + backupSuffix, file);
            });
            this.$errors.failWithoutHelp(error.message);
        }
        finally {
            _.each(backedUpFiles, file => {
                this.$fs.deleteFile(file + backupSuffix);
            });
        }
    }
    promptUserForInvalidPluginsAction(plugins, toVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            let multipleInvalidPlugins = plugins.length > 1, remove = multipleInvalidPlugins ? `Remove those plugins from all configurations` : `Remove this plugin from all configurations`, cancel = 'Cancel Cordova migration', pluginsString = multipleInvalidPlugins ? `plugins ${plugins.join(', ')} are` : `plugin ${plugins.join(', ')} is`, choice = yield this.$prompter.promptForChoice(`The ${pluginsString} not supported for Cordova version ${toVersion}. What do you want to do?`, [remove, cancel]);
            if (choice === cancel) {
                this.$errors.failWithoutHelp("Cordova migration interrupted");
            }
        });
    }
    getSupportedWPFrameworks() {
        return __awaiter(this, void 0, void 0, function* () {
            let validValues = [];
            let projectSchema = yield this.$project.getProjectSchema();
            if (projectSchema) {
                validValues = yield this.$projectPropertiesService.getValidValuesForProperty(projectSchema["WPSdk"]);
            }
            return validValues;
        });
    }
    parseMscorlibVersion(json) {
        return [json._Major, json._Minor, json._Build].join('.');
    }
    applyTransitions(plugins, transitions) {
        return _.map(plugins, plugin => {
            _.each(transitions, transition => {
                if (transition.from === plugin) {
                    plugin = transition.to;
                }
            });
            return plugin;
        });
    }
    migrateWebView(oldFrameworkVersion, newFrameworkVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentWebViewName = yield this.$webViewService.getCurrentWebViewName(this.$projectConstants.IOS_PLATFORM_NAME);
            let currentWebView = this.$webViewService.getWebView(this.$projectConstants.IOS_PLATFORM_NAME, currentWebViewName, oldFrameworkVersion);
            let newWebView = this.$webViewService.getWebView(this.$projectConstants.IOS_PLATFORM_NAME, currentWebViewName, newFrameworkVersion);
            if (newWebView.pluginIdentifier !== currentWebView.pluginIdentifier) {
                if (currentWebView.pluginIdentifier) {
                    yield this.$pluginsService.removePlugin(currentWebView.pluginIdentifier);
                }
                yield this.$webViewService.enableWebView(this.$projectConstants.IOS_PLATFORM_NAME, currentWebViewName, newFrameworkVersion);
            }
        });
    }
}
CordovaMigrationService.CORDOVA_JSON_FILE_NAME = "cordova.json";
CordovaMigrationService.CORDOVA_FOLDER_NAME = "Cordova";
exports.CordovaMigrationService = CordovaMigrationService;
$injector.register("cordovaMigrationService", CordovaMigrationService);
