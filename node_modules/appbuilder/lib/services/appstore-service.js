"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const constants = require("../common/constants");
class AppStoreService {
    constructor($logger, $errors, $server, $project, $buildService) {
        this.$logger = $logger;
        this.$errors = $errors;
        this.$server = $server;
        this.$project = $project;
        this.$buildService = $buildService;
    }
    upload(userName, password, application) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$logger.info("Checking that iTunes Connect application is ready for upload.");
            let apps = yield this.$server.itmstransporter.getApplicationsReadyForUpload(userName, password);
            let theApp = _.find(apps, (app) => app.Application === application);
            if (!theApp) {
                this.$errors.fail("App '%s' does not exist or is not ready for upload.", application);
            }
            this.$logger.info("Building package.");
            let buildResult = yield this.$buildService.build({
                platform: "iOS",
                projectConfiguration: this.$project.getProjectConfiguration(constants.Configurations.Release),
                buildConfiguration: constants.Configurations.Release,
                provisionTypes: [constants.ProvisionType.AppStore]
            });
            buildResult = _.filter(buildResult, (def) => !def.disposition || def.disposition === "BuildResult");
            if (!buildResult[0] || !buildResult[0].solutionPath) {
                this.$errors.fail({ formatStr: "Build failed.", suppressCommandHelp: true });
            }
            this.$logger.info("Uploading package to iTunes Connect. This may take several minutes.");
            let solutionPath = buildResult[0].solutionPath;
            let projectPath = solutionPath.substr(solutionPath.indexOf("/") + 1);
            let projectData = this.$project.projectData;
            yield this.$server.itmstransporter.uploadApplicationFromUri(projectData.ProjectName, projectData.ProjectName, theApp.AppleID, projectPath, userName, password);
            this.$logger.info("Upload complete.");
        });
    }
    getApplicationsReadyForUpload(userName, password) {
        return __awaiter(this, void 0, void 0, function* () {
            let apps = yield this.$server.itmstransporter.getApplicationsReadyForUpload(userName, password);
            apps = _.sortBy(apps, (app) => app.Application);
            return apps;
        });
    }
}
exports.AppStoreService = AppStoreService;
$injector.register("appStoreService", AppStoreService);
