"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const constants = require("../../common/constants");
const os_1 = require("os");
class LiveSyncService {
    constructor($devicesService, $errors, $project, $logger, $mobileHelper, $options, $injector) {
        this.$devicesService = $devicesService;
        this.$errors = $errors;
        this.$project = $project;
        this.$logger = $logger;
        this.$mobileHelper = $mobileHelper;
        this.$options = $options;
        this.$injector = $injector;
        this.excludedProjectDirsAndFiles = ["app_resources", "plugins", ".*.tmp", ".ab"];
        this.deviceConfigurationInfos = [];
    }
    livesync(platform) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$project.ensureProject();
            yield this.$devicesService.initialize({ platform: platform, deviceId: this.$options.device });
            platform = platform || this.$devicesService.platform;
            if (!this.$mobileHelper.getPlatformCapabilities(platform).companion && this.$options.companion) {
                this.$errors.failWithoutHelp("The AppBuilder Companion app is not available on %s devices.", platform);
            }
            if (!this.$devicesService.hasDevices) {
                this.$errors.failWithoutHelp(constants.ERROR_NO_DEVICES);
            }
            if (!this.$project.capabilities.livesync && !this.$options.companion) {
                this.$errors.failWithoutHelp("Use $ appbuilder livesync cloud to sync your application to Telerik Nativescript Companion App. You will be able to LiveSync %s based applications in a future release of the Telerik AppBuilder CLI.", this.$project.projectData.Framework);
            }
            if (!this.$project.capabilities.livesyncCompanion && this.$options.companion) {
                this.$errors.failWithoutHelp("You will be able to LiveSync %s based applications to the Companion app in a future release of the Telerik AppBuilder CLI.", this.$project.projectData.Framework);
            }
            let projectDir = this.$project.getProjectDir();
            let livesyncData = {
                platform: platform,
                appIdentifier: yield this.$project.getAppIdentifierForPlatform(platform),
                projectFilesPath: projectDir,
                syncWorkingDirectory: projectDir,
                excludedProjectDirsAndFiles: this.excludedProjectDirsAndFiles,
                additionalConfigurations: this.$project.projectInformation.configurations
            };
            this.deviceConfigurationInfos = [];
            let configurations = this.$project.getConfigurationsSpecifiedByUser();
            let $liveSyncServiceBase = this.$injector.resolve("$liveSyncServiceBase");
            if (!configurations.length) {
                yield this.fillDeviceConfigurationInfos(livesyncData.appIdentifier);
                let deviceConfigurations = _.reduce(this.deviceConfigurationInfos, (result, dci) => result + `${os_1.EOL}device: ${dci.applicationIdentifier} has "${dci.configuration}" configuration`, "");
                if (deviceConfigurations && _.uniqBy(this.deviceConfigurationInfos, dci => dci.configuration).length !== 1) {
                    this.$errors.failWithoutHelp("Cannot LiveSync because application is deployed with different configurations across the devices.", deviceConfigurations);
                }
                livesyncData.configuration = this.deviceConfigurationInfos && this.deviceConfigurationInfos[0] && this.deviceConfigurationInfos[0].configuration;
                if (livesyncData.configuration) {
                    this.$options.config = [livesyncData.configuration];
                }
                yield $liveSyncServiceBase.sync([livesyncData], this.$project.projectDir, {
                    configuration: livesyncData.configuration,
                    additionalConfigurations: livesyncData.additionalConfigurations
                });
            }
            else {
                Promise.all(configurations.map((configuration) => __awaiter(this, void 0, void 0, function* () {
                    livesyncData.configuration = configuration;
                    livesyncData.appIdentifier = this.$project.projectInformation.configurationSpecificData[configuration.toLowerCase()].AppIdentifier;
                    yield this.fillDeviceConfigurationInfos(livesyncData.appIdentifier);
                    livesyncData.canExecute = (device) => {
                        let deviceConfigurationInfo = _.find(this.deviceConfigurationInfos, dci => dci.deviceIdentifier === device.deviceInfo.identifier);
                        if (deviceConfigurationInfo && deviceConfigurationInfo.configuration && deviceConfigurationInfo.configuration.toLowerCase() !== configuration.toLowerCase() && !this.$options.companion) {
                            this.$logger.warn(`Cannot LiveSync to device with identifier ${device.deviceInfo.identifier}. You are trying to synchronize changes for the ${configuration} configuration but the device expects changes for the ${deviceConfigurationInfo.configuration} configuration. Change the target configuration for the LiveSync operation or re-build and re-deploy your app in another configuration.`);
                            return false;
                        }
                        return true;
                    };
                    yield $liveSyncServiceBase.sync([livesyncData], this.$project.projectDir, {
                        configuration: livesyncData.configuration,
                        additionalConfigurations: livesyncData.additionalConfigurations
                    });
                })));
            }
        });
    }
    fillDeviceConfigurationInfos(appIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.$devicesService.execute((device) => __awaiter(this, void 0, void 0, function* () {
                let configInfo = yield device.getApplicationInfo(appIdentifier);
                if (configInfo) {
                    this.deviceConfigurationInfos.push(configInfo);
                }
            }));
        });
    }
}
exports.LiveSyncService = LiveSyncService;
$injector.register("liveSyncService", LiveSyncService);
