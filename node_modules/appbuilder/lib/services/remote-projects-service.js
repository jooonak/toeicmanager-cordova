"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const helpers = require("../helpers");
const temp = require("temp");
class RemoteProjectService {
    constructor($server, $userDataStore, $serviceProxy, $serviceProxyBase, $errors, $project, $projectConstants, $fs, $logger) {
        this.$server = $server;
        this.$userDataStore = $userDataStore;
        this.$serviceProxy = $serviceProxy;
        this.$serviceProxyBase = $serviceProxyBase;
        this.$errors = $errors;
        this.$project = $project;
        this.$projectConstants = $projectConstants;
        this.$fs = $fs;
        this.$logger = $logger;
        this.clientProjectsPerSolution = {};
        this._isMigrationEnabledForUser = null;
    }
    getAvailableAppsAndSolutions() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.clientSolutions || !this.clientSolutions.length) {
                let apps = (yield this.getIsMigrationEnabledForUser()) ? yield this.getApps() : [];
                let solutions = yield this.getSolutions();
                this.clientSolutions = solutions.concat(apps);
            }
            return this.clientSolutions;
        });
    }
    getProjectName(solutionId, projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            let clientProjects = yield this.getProjectsForSolution(solutionId);
            let result = helpers.findByNameOrIndex(projectId, clientProjects, (clientProject) => clientProject.Name);
            if (!result) {
                this.$errors.failWithoutHelp("Could not find project named '%s' inside '%s' solution or was not given a valid index. List available solutions with 'cloud list' command", projectId, solutionId);
            }
            return result.Name;
        });
    }
    getProjectProperties(solutionId, projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            let projectName = yield this.getProjectName(solutionId, projectId);
            let properties = (yield this.getProjectData(solutionId, projectName))["Properties"];
            properties.ProjectName = projectName;
            return properties;
        });
    }
    getProjectsForSolution(appId) {
        return __awaiter(this, void 0, void 0, function* () {
            let app = yield this.getApp(appId);
            if (!(this.clientProjectsPerSolution[app.id] && this.clientProjectsPerSolution[app.id].length > 0)) {
                this.clientProjectsPerSolution[app.id] = _.sortBy((yield this.getSolutionDataCore(app)).solutionData.Items, project => project.Name);
            }
            return this.clientProjectsPerSolution[app.id];
        });
    }
    exportProject(remoteSolutionName, remoteProjectName) {
        return __awaiter(this, void 0, void 0, function* () {
            let app = yield this.getApp(remoteSolutionName);
            let slnName = app.isApp ? app.id : app.name;
            let projectDir = yield this.getExportDir(app.name, (unzipStream) => this.$server.appsProjects.exportProject(slnName, remoteProjectName, false, unzipStream), { discardSolutionSpaceHeader: app.isApp });
            yield this.createProjectFile(projectDir, slnName, remoteProjectName);
            this.$logger.info("%s has been successfully exported to %s", remoteProjectName, projectDir);
        });
    }
    exportSolution(remoteSolutionName) {
        return __awaiter(this, void 0, void 0, function* () {
            let app = yield this.getApp(remoteSolutionName);
            let slnName = app.isApp ? app.id : app.name;
            let solutionDir = yield this.getExportDir(app.name, (unzipStream) => this.$server.apps.exportApplication(slnName, false, unzipStream), { discardSolutionSpaceHeader: app.isApp });
            let projectsDirectories = this.$fs.readDirectory(solutionDir);
            projectsDirectories.forEach((projectName) => __awaiter(this, void 0, void 0, function* () { return yield this.createProjectFile(path.join(solutionDir, projectName), remoteSolutionName, projectName); }));
            this.$logger.info("%s has been successfully exported to %s", slnName, solutionDir);
        });
    }
    getSolutionData(solutionIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let app = yield this.getApp(solutionIdentifier);
            return yield this.getSolutionDataCore(app);
        });
    }
    getIsMigrationEnabledForUser() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isMigrationEnabledForUser === null) {
                let features = yield this.$server.tap.getFeatures(yield this.getUserTenantId(), "tap");
                this._isMigrationEnabledForUser = features && features.length && _.includes(features, RemoteProjectService.APP_FEATURE_TOGGLE_NAME);
            }
            return this._isMigrationEnabledForUser;
        });
    }
    getSolutionDataCore(app) {
        return __awaiter(this, void 0, void 0, function* () {
            let name = app.isApp ? app.id : app.name;
            const solutionData = yield this.$serviceProxy.makeTapServiceCall(() => this.$server.apps.getApplication(name), { discardSolutionSpaceHeader: app.isApp });
            return {
                solutionData,
                solutionName: app.colorizedDisplayName
            };
        });
    }
    getProjectData(solutionName, projectName) {
        return __awaiter(this, void 0, void 0, function* () {
            return _.find(yield this.getProjectsForSolution(solutionName), pr => pr.Name === projectName);
        });
    }
    getExportDir(dirName, tapServiceCall, solutionSpaceHeaderOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let exportDir = path.join(this.$project.getNewProjectDir(), dirName);
            if (this.$fs.exists(exportDir)) {
                this.$errors.fail("The folder %s already exists!", exportDir);
            }
            temp.track();
            let solutionZipFilePath = temp.path({ prefix: "appbuilder-cli-", suffix: '.zip' });
            let unzipStream = this.$fs.createWriteStream(solutionZipFilePath);
            yield this.$serviceProxy.makeTapServiceCall(() => __awaiter(this, void 0, void 0, function* () { return yield tapServiceCall.apply(null, [unzipStream]); }), solutionSpaceHeaderOptions);
            yield this.$fs.unzip(solutionZipFilePath, exportDir);
            return exportDir;
        });
    }
    createProjectFile(projectDir, remoteSolutionName, remoteProjectName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let projectFile = path.join(projectDir, this.$projectConstants.PROJECT_FILE);
                if (!this.$fs.exists(projectFile)) {
                    let properties = yield this.getProjectProperties(remoteSolutionName, remoteProjectName);
                    yield this.$project.createProjectFile(projectDir, properties);
                }
            }
            catch (e) {
                this.$logger.warn(`Couldn't create project file: ${e.message}`);
                this.$logger.trace(e);
            }
        });
    }
    getApps() {
        return __awaiter(this, void 0, void 0, function* () {
            let tenantId = yield this.getUserTenantId();
            let existingClientApps = yield this.$serviceProxyBase.call('', 'GET', ['api', 'accounts', tenantId, 'apps'].join('/'), 'application/json', null, null);
            return _.sortBy(existingClientApps, (clientSolution) => clientSolution.name)
                .map(app => {
                app.displayName = app.name;
                app.isApp = true;
                app.colorizedDisplayName = app.displayName;
                return app;
            });
        });
    }
    getSolutions() {
        return __awaiter(this, void 0, void 0, function* () {
            let existingClientSolutions = yield this.$serviceProxy.makeTapServiceCall(() => this.$server.tap.getExistingClientSolutions());
            return _.sortBy(existingClientSolutions, (clientSolution) => clientSolution.name)
                .map(sln => {
                return {
                    accountId: sln.accountId,
                    id: sln.id,
                    type: null,
                    settings: null,
                    name: sln.name,
                    description: sln.description,
                    displayName: sln.name + (this.getIsMigrationEnabledForUser ? RemoteProjectService.NOT_MIGRATED_IDENTIFER : ""),
                    colorizedDisplayName: sln.name + (this.getIsMigrationEnabledForUser ? `\x1B[31;1m${RemoteProjectService.NOT_MIGRATED_IDENTIFER}\x1B[0m` : ""),
                    isApp: false
                };
            });
        });
    }
    getApp(key) {
        return __awaiter(this, void 0, void 0, function* () {
            let availableAppsAndSolutions = yield this.getAvailableAppsAndSolutions();
            let matchingApp = _.find(availableAppsAndSolutions, app => key === app.colorizedDisplayName)
                || _.find(availableAppsAndSolutions, app => key === app.displayName)
                || _.find(availableAppsAndSolutions, app => key === app.id)
                || _.find(availableAppsAndSolutions, app => key === app.name)
                || availableAppsAndSolutions[+key - 1];
            if (!matchingApp) {
                this.$errors.failWithoutHelp(`Unable to find app with identifier ${key}.`);
            }
            return matchingApp;
        });
    }
    getUserTenantId() {
        return __awaiter(this, void 0, void 0, function* () {
            let user = yield this.$userDataStore.getUser();
            return user.tenant.id;
        });
    }
}
RemoteProjectService.NOT_MIGRATED_IDENTIFER = " (NOT MIGRATED)";
RemoteProjectService.APP_FEATURE_TOGGLE_NAME = "projects-to-app";
exports.RemoteProjectService = RemoteProjectService;
$injector.register("remoteProjectService", RemoteProjectService);
