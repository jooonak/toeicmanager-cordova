"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const constants = require("../common/constants");
const os_1 = require("os");
const helpers = require("../helpers");
let Table = require("cli-table");
class AppManagerService {
    constructor($config, $server, $errors, $logger, $project, $loginManager, $opener, $buildService, $progressIndicator, $mobileHelper, $devicePlatformsConstants, $options, $injector) {
        this.$config = $config;
        this.$server = $server;
        this.$errors = $errors;
        this.$logger = $logger;
        this.$project = $project;
        this.$loginManager = $loginManager;
        this.$opener = $opener;
        this.$buildService = $buildService;
        this.$progressIndicator = $progressIndicator;
        this.$mobileHelper = $mobileHelper;
        this.$devicePlatformsConstants = $devicePlatformsConstants;
        this.$options = $options;
        this.$injector = $injector;
    }
    upload(platform) {
        return __awaiter(this, void 0, void 0, function* () {
            let mobilePlatform = this.$mobileHelper.validatePlatformName(platform);
            yield this.$project.ensureProject();
            yield this.$loginManager.ensureLoggedIn();
            this.$logger.info("Accessing Telerik AppManager.");
            yield this.$server.tam.verifyStoreCreated();
            this.$logger.info("Building package.");
            let buildResult = yield this.$buildService.build({
                platform: mobilePlatform,
                buildConfiguration: constants.Configurations.Release,
                projectConfiguration: this.$project.getProjectConfiguration(constants.Configurations.Release),
                provisionTypes: [constants.ProvisionType.Development, constants.ProvisionType.Enterprise, constants.ProvisionType.AdHoc],
                showWp8SigningMessage: false,
                buildForTAM: true,
                downloadFiles: this.$options.download
            });
            buildResult = _.filter(buildResult, (def) => !def.disposition || def.disposition === "BuildResult");
            if (!buildResult[0] || !buildResult[0].solutionPath) {
                this.$errors.fail({ formatStr: "Build failed.", suppressCommandHelp: true });
            }
            this.$logger.info("Uploading package to Telerik AppManager.");
            let projectName = this.$project.projectData.ProjectName;
            let solutionPath = buildResult[0].solutionPath;
            let projectPath = solutionPath.substr(solutionPath.indexOf("/") + 1);
            let publishSettings = {
                IsPublished: this.$options.publish,
                IsPublic: this.$options.public,
                NotifyByPush: this.$options.sendPush,
                NotifyByEmail: this.$options.sendEmail,
                Groups: []
            };
            if (this.$options.group) {
                publishSettings.Groups = yield this.findGroups(this.$options.group);
            }
            if (!this.$options.publish && this.$options.public) {
                this.$logger.warn("You have not set the --publish switch. Your app will become publicly available after you publish it manually in Telerik AppManager.");
            }
            if (!this.$options.publish && this.$options.sendEmail) {
                this.$logger.warn("You have not set the --publish switch. Your users will not receive an email.");
            }
            if (!this.$options.publish && this.$options.sendPush) {
                this.$logger.warn("You have not set the --publish switch. Your users will not receive a push notification.");
            }
            let uploadedAppData = mobilePlatform.toLowerCase() === this.$devicePlatformsConstants.WP8.toLowerCase() ?
                yield this.$server.tam.uploadApplication(projectName, projectName, projectPath, publishSettings) :
                yield this.$server.tam.uploadApplicationFromUri(projectName, projectName, projectPath, publishSettings);
            this.$logger.info("Successfully uploaded package.");
            if (this.$options.publish && this.$options.public) {
                this.$logger.info("Your app has been published successfully and is now available to download and install from: %s", uploadedAppData.InstallUrl);
            }
            this.openAppManagerStore();
        });
    }
    getGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$loginManager.ensureLoggedIn();
            this.$logger.info("Accessing Telerik AppManager.");
            this.$logger.info("Retrieving distribution groups from Telerik AppManager.");
            let groups = yield this.$server.tam.getGroups();
            if (!groups.length) {
                this.$logger.info("Cannot find distribution groups.");
                return;
            }
            groups = _.sortBy(groups, group => group.Name.toLowerCase());
            let table = new Table({
                head: ["Index", "Name"],
                chars: { 'mid': '', 'left-mid': '', 'mid-mid': '', 'right-mid': '' }
            });
            _.forEach(groups, (group, index) => {
                table.push([(index + 1).toString(), group.Name]);
            });
            this.$logger.out(table.toString());
        });
    }
    openAppManagerStore() {
        let tamUrl = `${this.$config.AB_SERVER_PROTO}://${this.$config.AB_SERVER}/appbuilder/Services/tam`;
        this.$logger.info("Go to %s to manage your apps.", tamUrl);
        if (!this.$options.skipUi) {
            this.$opener.open(tamUrl);
        }
    }
    publishLivePatch(platforms) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$project.ensureProject();
            yield this.$loginManager.ensureLoggedIn();
            platforms = _.map(platforms, platform => this.$mobileHelper.normalizePlatformName(platform));
            let cachedOptionsRelease = this.$options.release;
            this.$options.release = true;
            yield this.configureLivePatchPlugin();
            this.$logger.warn("If you have not published an AppManager LiveSync-enabled version of this app before, you will not be able to distribute an AppManager LiveSync update for it.");
            this.$logger.info("To learn how to create a new version enabled for AppManager LiveSync, run `$ appbuilder help appmanager livesync`");
            yield this.$project.importProject();
            this.$logger.printInfoMessageOnSameLine("Publishing patch for " + platforms.join(", ") + "...");
            let patchData = { Platforms: platforms, IsMandatory: this.$options.mandatory };
            let patchUpload = this.$server.tam.uploadPatch(this.$project.projectData.ProjectName, this.$project.projectData.ProjectName, patchData);
            yield this.$progressIndicator.showProgressIndicator(patchUpload, 2000);
            this.$options.release = cachedOptionsRelease;
            this.openAppManagerStore();
        });
    }
    configureLivePatchPlugin() {
        return __awaiter(this, void 0, void 0, function* () {
            let $pluginsService = this.$injector.resolve("pluginsService");
            let plugins = $pluginsService.getInstalledPlugins();
            let isNativeScript = this.$project.projectData.Framework === constants.TARGET_FRAMEWORK_IDENTIFIERS.NativeScript;
            let livePatchPluginId = isNativeScript ? AppManagerService.NATIVESCRIPT_LIVEPATCH_PLUGIN_ID : AppManagerService.CORDOVA_LIVEPATCH_PLUGIN_ID;
            if (!_.some(plugins, plugin => plugin && plugin.data && plugin.data.Identifier === livePatchPluginId)) {
                this.$logger.warn("The AppManager LiveSync plugin is not enabled for your project. Enabling it now for the release build configuration...");
                yield $pluginsService.addPlugin(livePatchPluginId);
                this.$logger.info("AppManager LiveSync is now enabled for the release build configuration.");
            }
        });
    }
    findGroups(identityStrings) {
        return __awaiter(this, void 0, void 0, function* () {
            let availableGroups = yield this.$server.tam.getGroups();
            if (!availableGroups.length) {
                this.$errors.failWithoutHelp("Cannot find distribution groups.");
            }
            return _.map(identityStrings, identityStr => {
                let group = helpers.findByNameOrIndex(identityStr, availableGroups, _group => _group.Name);
                if (!group) {
                    this.$errors.failWithoutHelp("Cannot find group that matches the provided <Group ID>: '%s'.To list the available groups, run $ appbuilder appmanager groups", identityStr, os_1.EOL);
                }
                return group.Id;
            });
        });
    }
}
AppManagerService.CORDOVA_LIVEPATCH_PLUGIN_ID = "com.telerik.LivePatch";
AppManagerService.NATIVESCRIPT_LIVEPATCH_PLUGIN_ID = "nativescript-plugin-livepatch";
$injector.register("appManagerService", AppManagerService);
