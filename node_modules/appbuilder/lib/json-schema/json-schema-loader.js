"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const temp = require("temp");
const jsonSchemaResolverPath = require("./json-schema-resolver");
class JsonSchemaLoader {
    constructor($config, $fs, $errors, $httpClient, $injector, $resources) {
        this.$config = $config;
        this.$fs = $fs;
        this.$errors = $errors;
        this.$httpClient = $httpClient;
        this.$injector = $injector;
        this.$resources = $resources;
        this.schemasFolderPath = null;
        this.schemas = null;
        this.loadedSchemas = null;
        this.prepareSchemas();
    }
    downloadSchemas() {
        return __awaiter(this, void 0, void 0, function* () {
            temp.track();
            this.$fs.deleteDirectory(this.schemasFolderPath);
            this.$fs.createDirectory(this.schemasFolderPath);
            let filePath = temp.path({ suffix: ".zip" });
            let file = this.$fs.createWriteStream(filePath);
            let fileEnd = this.$fs.futureFromEvent(file, "finish");
            let schemasEndpoint = `http://${this.$config.AB_SERVER}/appbuilder/Resources/Files/Schemas.zip`;
            yield this.$httpClient.httpRequest({ url: schemasEndpoint, pipeTo: file });
            yield fileEnd;
            yield this.$fs.unzip(filePath, this.schemasFolderPath);
        });
    }
    prepareSchemas() {
        this.schemasFolderPath = this.$resources.resolvePath("json-schemas");
        this.schemas = Object.create(null);
        this.loadedSchemas = Object.create(null);
        this.loadSchemas();
        let schemaResolver = this.$injector.resolve(jsonSchemaResolverPath.JsonSchemaResolver, { schemas: this.loadedSchemas });
        this.$injector.register("jsonSchemaResolver", schemaResolver);
    }
    loadSchemas() {
        if (this.$fs.exists(this.schemasFolderPath)) {
            let fileNames = this.$fs.readDirectory(this.schemasFolderPath);
            _.each(fileNames, (fileName) => {
                if (path.extname(fileName) === ".json") {
                    let fullFilePath = path.join(this.schemasFolderPath, fileName);
                    let schema = this.$fs.readJson(fullFilePath);
                    this.schemas[schema.id] = schema;
                }
            });
            let schemas = _.values(this.schemas);
            _.each(schemas, (schema) => this.loadSchema(schema));
        }
    }
    isSchemaLoaded(schemaId) {
        let schemaIds = _.keys(this.loadedSchemas);
        return _.includes(schemaIds, schemaId);
    }
    loadSchema(schema) {
        let id = schema.id;
        let extendsProperty = schema.extends;
        if (!this.isSchemaLoaded(id)) {
            if (extendsProperty && extendsProperty.length > 0) {
                _.each(extendsProperty, (ext) => {
                    let schemaRef = ext.$ref;
                    let extSchema = this.findSchema(schemaRef);
                    if (!extSchema) {
                        this.$errors.fail("Schema %s not found.", schemaRef);
                    }
                    this.loadSchema(extSchema);
                });
            }
            this.loadedSchemas[schema.id] = schema;
        }
    }
    findSchema(schemaId) {
        return this.schemas[schemaId];
    }
}
exports.JsonSchemaLoader = JsonSchemaLoader;
$injector.register("jsonSchemaLoader", JsonSchemaLoader);
