"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const util = require("util");
const decorators_1 = require("./../common/decorators");
let jsv = require("JSV").JSV;
class JsonSchemaValidator {
    constructor($errors, $frameworkProjectResolver, $fs, $jsonSchemaConstants, $jsonSchemaLoader, $injector, $logger, $mobileHelper, $resources) {
        this.$errors = $errors;
        this.$frameworkProjectResolver = $frameworkProjectResolver;
        this.$fs = $fs;
        this.$jsonSchemaConstants = $jsonSchemaConstants;
        this.$jsonSchemaLoader = $jsonSchemaLoader;
        this.$injector = $injector;
        this.$logger = $logger;
        this.$mobileHelper = $mobileHelper;
        this.$resources = $resources;
        this.environment = null;
        this.environment = jsv.createEnvironment(JsonSchemaValidator.ENVIRONMENT_ID);
        this.environment.setDefaultSchemaURI(JsonSchemaValidator.DEFAULT_SCHEMA_URI);
        this._validPropertiesCache = Object.create(null);
    }
    get $jsonSchemaResolver() {
        this.$jsonSchemaLoader.prepareSchemas();
        return this.$injector.resolve("jsonSchemaResolver");
    }
    getValidProperties(framework) {
        let key = util.format("%s-%s", framework);
        if (!this._validPropertiesCache[key]) {
            this._validPropertiesCache[key] = Object.create(null);
            let schema = this.tryResolveValidationSchema(framework);
            let availableProperties = _.keys(schema);
            _.each(availableProperties, (propertyName) => {
                this._validPropertiesCache[key][propertyName.toLowerCase()] = propertyName;
            });
        }
        return this._validPropertiesCache[key];
    }
    validateWithBuildSchema(data, platformName) {
        let buildSchemaName = this.getBuildSchemaName(platformName);
        this.validate(data, { validationSchemaName: buildSchemaName, usePredefinedErrors: false });
    }
    isValid(data) {
        let errors = this.getValidationErrors(data);
        return _.keys(errors).length !== 0;
    }
    tryResolveValidationSchema(framework) {
        let schema = this.tryResolveValidationSchemaCore(framework);
        let result = schema.properties;
        if (schema.extends) {
            _.each(_.keys(schema.extends.properties), (key) => {
                if (!result[key]) {
                    result[key] = schema.extends.properties[key];
                }
            });
        }
        let projectPropertiesFilePath = this.$resources.resolvePath(util.format("project-properties-%s.json", framework.toLowerCase()));
        if (this.$fs.exists(projectPropertiesFilePath)) {
            let fileContent = this.$fs.readJson(projectPropertiesFilePath);
            let additionalProperties = _.keys(fileContent);
            _.each(additionalProperties, (propertyName) => {
                _.each(_.keys(fileContent[propertyName]), (key) => {
                    result[propertyName][key] = fileContent[propertyName][key];
                });
            });
        }
        return result;
    }
    getPropertyType(framework, propertyName) {
        let schema = this.tryResolveValidationSchema(framework);
        let propertyType = schema[propertyName].type;
        return propertyType;
    }
    validatePropertyUsingBuildSchema(propertyName, propertyValue) {
        let invalidPlatforms = Object.create(null);
        let properties = Object.create(null);
        properties[propertyName] = propertyValue;
        _.each(this.$mobileHelper.platformNames, platformName => {
            let validationErrors = this.getBuildSchemaValidationErrors(properties, platformName);
            if (_.keys(validationErrors).length !== 0 && validationErrors[propertyName]) {
                invalidPlatforms[platformName] = validationErrors[propertyName];
            }
            ;
        });
        if (_.keys(invalidPlatforms).length === this.$mobileHelper.platformNames.length) {
            this.$errors.failWithoutHelp("The validation of provided %s property failed with following errors:\n %s", propertyName, _.values(invalidPlatforms).join("\n"));
        }
        _.each(invalidPlatforms, (error, platformName) => this.$logger.warn("The provided %s property is not valid for %s platform. %s", propertyName, platformName, error));
    }
    getBuildSchemaValidationErrors(data, platformName) {
        let buildSchemaName = this.getBuildSchemaName(platformName);
        return this.getValidationErrors(data, { validationSchemaName: buildSchemaName, usePredefinedErrors: false });
    }
    getBuildSchemaName(platformName) {
        return util.format("%s%s", JsonSchemaValidator.BUILD_SCHEMA_ID_PREFIX, platformName);
    }
    validate(data, opts) {
        let validationErrors = this.getValidationErrors(data, opts);
        if (_.keys(validationErrors).length !== 0) {
            let output = _.values(validationErrors).join("\n");
            this.$errors.fail("Schema validation failed with following errors: \n %s", output);
        }
    }
    getValidationErrors(data, opts) {
        opts = opts || {};
        let validationSchema = this.tryResolveValidationSchemaCore(data.Framework, opts.validationSchemaName);
        let schema = this.environment.createSchema(validationSchema);
        let validationResult = this.environment.validate(data, schema);
        let errors = validationResult.errors;
        let result = Object.create(null);
        _.each(errors, (error) => {
            let schemaUri = error.schemaUri;
            let schemaUriParts = schemaUri.split("/");
            let propertyName = schemaUriParts[schemaUriParts.length - 1];
            if (error.message === JsonSchemaValidator.INSTANCE_IS_NOT_A_REQUIRED_TYPE_ERROR_MESSAGE) {
                error.details = util.format("Expected %s but got %s", error.details, data[propertyName]);
            }
            let errorMessage = util.format("Property %s: %s. %s", propertyName, error.message, error.details);
            this.$logger.trace("JSV error: %s", errorMessage);
            let property = this.tryResolveValidationSchemaCore(undefined, opts.validationSchemaName).properties[propertyName];
            let errMsg = (property && property.errorMessage) ? property.errorMessage : errorMessage;
            result[propertyName] = (opts.usePredefinedErrors === false ? undefined :
                JsonSchemaValidator.PREDEFINED_ERRORS[propertyName]) || errMsg;
        });
        return result;
    }
    tryResolveValidationSchemaCore(framework, validationSchemaName) {
        validationSchemaName = validationSchemaName || this.getValidationSchemaName(framework);
        let schema = this.$jsonSchemaResolver.getSchema(validationSchemaName);
        if (!schema) {
            this.$errors.fail("Unable to resolve validation schema.");
        }
        return schema;
    }
    getValidationSchemaName(framework) {
        if (!framework) {
            return this.$jsonSchemaConstants.BASE_VALIDATION_SCHEMA_ID;
        }
        let frameworkProject = this.$frameworkProjectResolver.resolve(framework);
        let validationSchemaName = frameworkProject.getValidationSchemaId();
        if (!validationSchemaName) {
            return this.$jsonSchemaConstants.BASE_VALIDATION_SCHEMA_ID;
        }
        return validationSchemaName;
    }
}
JsonSchemaValidator.ENVIRONMENT_ID = "json-schema-draft-03";
JsonSchemaValidator.DEFAULT_SCHEMA_URI = "http://json-schema.org/draft-03/schema#";
JsonSchemaValidator.INSTANCE_IS_NOT_A_REQUIRED_TYPE_ERROR_MESSAGE = "Instance is not a required type";
JsonSchemaValidator.BUILD_SCHEMA_ID_PREFIX = "Build-";
JsonSchemaValidator.PREDEFINED_ERRORS = {
    AppIdentifier: "The application identifier must consist of at least three alphanumeric strings separated by a dot. The alphanumeric strings must start with a letter."
};
__decorate([
    decorators_1.cache()
], JsonSchemaValidator.prototype, "$jsonSchemaResolver", null);
exports.JsonSchemaValidator = JsonSchemaValidator;
$injector.register("jsonSchemaValidator", JsonSchemaValidator);
