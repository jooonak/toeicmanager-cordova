"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const util = require("util");
const helpers = require("./helpers");
class ServiceProxyBase {
    constructor($httpClient, $userDataStore, $logger, $config, $staticConfig, $errors, $npmService) {
        this.$httpClient = $httpClient;
        this.$userDataStore = $userDataStore;
        this.$logger = $logger;
        this.$config = $config;
        this.$staticConfig = $staticConfig;
        this.$errors = $errors;
        this.$npmService = $npmService;
        this.hasVerifiedLatestVersion = false;
        this.shouldAuthenticate = true;
    }
    call(name, method, path, accept, bodyValues, resultStream, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureUpToDate();
            headers = headers || Object.create(null);
            let cookies;
            if (this.shouldAuthenticate) {
                cookies = yield this.$userDataStore.getCookies();
                if (cookies) {
                    let cookieValues = _.map(_.toPairs(cookies), (pair) => util.format("%s=%s", pair[0], pair[1]));
                    headers.Cookie = cookieValues.join("; ");
                }
            }
            if (accept) {
                headers.Accept = accept;
            }
            let requestOpts = {
                proto: this.$config.AB_SERVER_PROTO,
                host: this.$config.AB_SERVER,
                path: `/${path}`,
                method: method,
                headers: headers,
                pipeTo: resultStream
            };
            if (bodyValues) {
                if (bodyValues.length > 1) {
                    throw new Error("TODO: CustomFormData not implemented");
                }
                let theBody = bodyValues[0];
                requestOpts.body = theBody.value;
                requestOpts.headers["Content-Type"] = theBody.contentType;
            }
            let response;
            try {
                response = yield this.$httpClient.httpRequest(requestOpts);
            }
            catch (err) {
                if (err.response && err.response.statusCode === 401) {
                    yield this.$userDataStore.clearLoginData();
                }
                else if (err.response && err.response.statusCode === 402) {
                    this.$errors.fail({ formatStr: "%s", suppressCommandHelp: true }, JSON.parse(err.body).Message);
                }
                throw err;
            }
            this.$logger.debug("%s (%s %s) returned %d", name, method, path, response.response.statusCode);
            let newCookies = response.headers["set-cookie"];
            if (newCookies) {
                this.$userDataStore.parseAndSetCookies(newCookies, cookies);
            }
            let resultValue = accept === "application/json" ? JSON.parse(response.body) : response.body;
            return resultValue;
        });
    }
    setShouldAuthenticate(shouldAuthenticate) {
        this.shouldAuthenticate = shouldAuthenticate;
    }
    ensureUpToDate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.$config.ON_PREM || this.hasVerifiedLatestVersion) {
                return;
            }
            this.hasVerifiedLatestVersion = true;
            let latestVersion;
            try {
                latestVersion = yield this.getInformationFromRegistry();
            }
            catch (error) {
                this.$logger.warn("Failed to retrieve AppBuilder version from npm. Make sure you are running latest version of AppBuilder CLI.");
                this.$logger.trace(`Error is: ${error.message}`);
            }
            if (latestVersion && helpers.versionCompare(latestVersion, this.$staticConfig.version) > 0) {
                this.$errors.fail({ formatStr: "You are running an outdated version of the Telerik AppBuilder CLI. To run this command, you need to update to the latest version of the Telerik AppBuilder CLI. To update now, run 'npm install -g appbuilder'.", suppressCommandHelp: true });
            }
        });
    }
    getInformationFromRegistry() {
        return __awaiter(this, void 0, void 0, function* () {
            let packageJson = yield this.$npmService.getPackageJsonFromNpmRegistry(this.$staticConfig.CLIENT_NAME.toLowerCase());
            if (!packageJson) {
                throw new Error("Unable to get information from registry.");
            }
            return packageJson.version;
        });
    }
}
exports.ServiceProxyBase = ServiceProxyBase;
$injector.register("serviceProxyBase", ServiceProxyBase);
class AppBuilderServiceProxy extends ServiceProxyBase {
    constructor($httpClient, $userDataStore, $logger, $config, $staticConfig, $errors, $npmService) {
        super($httpClient, $userDataStore, $logger, $config, $staticConfig, $errors, $npmService);
        this.$httpClient = $httpClient;
        this.$userDataStore = $userDataStore;
        this.$logger = $logger;
        this.$config = $config;
        this.$staticConfig = $staticConfig;
        this.$errors = $errors;
        this.useSolutionSpaceNameHeader = true;
    }
    makeTapServiceCall(call, solutionSpaceHeaderOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let user = yield this.$userDataStore.getUser();
                this.solutionSpaceName = user.tenant.id;
                if (solutionSpaceHeaderOptions && solutionSpaceHeaderOptions.discardSolutionSpaceHeader) {
                    return yield this.callWithoutSolutionSpaceHeader(call);
                }
                else {
                    return yield call();
                }
            }
            finally {
                this.solutionSpaceName = null;
            }
        });
    }
    callWithoutSolutionSpaceHeader(action) {
        return __awaiter(this, void 0, void 0, function* () {
            let cachedUseSolutionSpaceNameValue = this.useSolutionSpaceNameHeader;
            this.useSolutionSpaceNameHeader = false;
            let result;
            try {
                result = yield action();
            }
            finally {
                this.useSolutionSpaceNameHeader = cachedUseSolutionSpaceNameValue;
            }
            return result;
        });
    }
    call(name, method, path, accept, bodyValues, resultStream, headers) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            path = `appbuilder/${path}`;
            headers = headers || Object.create(null);
            if (this.useSolutionSpaceNameHeader) {
                headers["X-Icenium-SolutionSpace"] = this.solutionSpaceName || this.$staticConfig.SOLUTION_SPACE_NAME;
            }
            return yield _super("call").call(this, name, method, path, accept, bodyValues, resultStream, headers);
        });
    }
}
exports.AppBuilderServiceProxy = AppBuilderServiceProxy;
$injector.register("serviceProxy", AppBuilderServiceProxy);
