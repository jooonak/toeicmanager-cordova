"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const code_entity_1 = require("../common/codeGeneration/code-entity");
const ts_type_system_helpers_1 = require("./ts-type-system-helpers");
const code_printer_1 = require("../common/codeGeneration/code-printer");
var ParamTypes;
(function (ParamTypes) {
    ParamTypes[ParamTypes["Path"] = 0] = "Path";
    ParamTypes[ParamTypes["Query"] = 1] = "Query";
    ParamTypes[ParamTypes["Body"] = 2] = "Body";
    ParamTypes[ParamTypes["Form"] = 3] = "Form";
})(ParamTypes || (ParamTypes = {}));
class ServiceContractGenerator {
    constructor($serviceContractProvider) {
        this.$serviceContractProvider = $serviceContractProvider;
        this.tsTypeSystemHelpers = new ts_type_system_helpers_1.TSTypeSystemHelpers();
        this.pendingModels = {};
    }
    generate() {
        return __awaiter(this, void 0, void 0, function* () {
            let swagger = yield this.$serviceContractProvider.getApi();
            let interfacesFile = new code_entity_1.Block();
            let implementationsFile = new code_entity_1.Block();
            implementationsFile.writeLine("// automatically generated code; do not edit manually!");
            implementationsFile.writeLine("//");
            implementationsFile.writeLine("\"use strict\";");
            implementationsFile.writeLine("");
            implementationsFile.writeLine("import querystring = require('querystring');");
            implementationsFile.writeLine("");
            interfacesFile.writeLine("//");
            interfacesFile.writeLine("// automatically generated code; do not edit manually!");
            interfacesFile.writeLine("//");
            let serverModuleName = "Server";
            let serverModuleDeclaration = new code_entity_1.Block("declare module " + serverModuleName);
            serverModuleDeclaration.toString();
            let serverClass = new code_entity_1.Block("export class ServiceContainer implements Server.IServer");
            let serverInterface = new code_entity_1.Block("interface IServer");
            serverClass.writeLine("constructor(private $injector: IInjector) { }");
            for (let i = 0; i < swagger.apis.length; ++i) {
                const apiPath = swagger.apis[i];
                let swaggerService = yield this.$serviceContractProvider.getApi(apiPath.path);
                let models = this.generateModels(swaggerService.models);
                serverModuleDeclaration.addBlocks(models);
                let service = this.generateService(swaggerService, serverModuleName);
                _.each(_.keys(this.pendingModels), (modelName) => {
                    let model = this.pendingModels[modelName];
                    let modelBlockAdded = _.some(serverModuleDeclaration.codeEntities, ce => ce.opener === model.opener);
                    if (model && !modelBlockAdded) {
                        serverModuleDeclaration.addBlock(model);
                    }
                });
                serverModuleDeclaration.addBlock(service.serviceInterface);
                implementationsFile.addBlock(service.serviceImplementation);
                let serviceName = swaggerService.resourcePath.substr(1);
                let name = this.getNameWithoutSlash(serviceName);
                serverInterface.writeLine(`${name}: Server.I${this.toPascalCase(name)}ServiceContract;`);
                serverClass.writeLine(`public ${name}: Server.I${this.toPascalCase(name)}ServiceContract = this.$injector.resolve(${this.toPascalCase(name)}Service);`);
            }
            ;
            serverModuleDeclaration.addBlock(serverInterface);
            interfacesFile.addBlock(serverModuleDeclaration);
            implementationsFile.addBlock(serverClass);
            implementationsFile.writeLine("$injector.register('server', ServiceContainer);");
            let codePrinter = new code_printer_1.CodePrinter();
            return {
                interfaceFile: codePrinter.composeBlock(interfacesFile),
                implementationFile: codePrinter.composeBlock(implementationsFile)
            };
        });
    }
    generateModels(models) {
        let modelsBlocks = [];
        _.each(models, (model) => {
            if (model.id.indexOf("`") < 0) {
                let typeName = this.tsTypeSystemHelpers.translate(model.id);
                if (!this.tsTypeSystemHelpers.isModel(typeName)) {
                    this.visitModel(model);
                    if (this.tsTypeSystemHelpers.isModel(typeName)) {
                        modelsBlocks.push(this.generateModel(model));
                    }
                }
            }
        });
        return modelsBlocks;
    }
    getNameWithoutSlash(name) {
        let result = name;
        let index;
        do {
            index = result.indexOf("/");
            if (~index) {
                result = result.substring(0, index) + result[index + 1].toUpperCase() + result.substr(index + 2);
            }
        } while (~index);
        return result;
    }
    generateModel(model) {
        let name = this.getNameWithoutSlash(model.id);
        let modelBlock = new code_entity_1.Block(`interface ${name}`);
        let properties = _.keys(model.properties);
        _.each(properties, (propertyName) => {
            let typeName = this.getModelPropertyTypeName(model.properties[propertyName]);
            if (!this.tsTypeSystemHelpers.isBuiltIn(typeName)) {
                typeName = `Server.${typeName}`;
            }
            modelBlock.writeLine(`${propertyName.replace(" ", "")}: ${typeName};`);
        });
        return modelBlock;
    }
    visitModel(model) {
        if (!this.tsTypeSystemHelpers.isGeneric(model.id)) {
            let modelName = this.tsTypeSystemHelpers.translate(model.id);
            this.tsTypeSystemHelpers.addModel(modelName);
        }
        _.each(model.properties, (property) => this.visitModelProperty(property));
    }
    visitModelProperty(property) {
        if (property.allowableValues) {
            this.tsTypeSystemHelpers.addModel(property.allowableValues.valueType);
            this.ensureEnumAdded(property.allowableValues);
        }
    }
    getModelPropertyTypeName(property) {
        let typeName;
        if (property.items) {
            typeName = property.items.$ref + "[]";
        }
        else {
            typeName = this.tsTypeSystemHelpers.translate(property.type);
        }
        return typeName;
    }
    ensureEnumAdded(allowableValues) {
        let typeName = this.tsTypeSystemHelpers.translate(allowableValues.valueType);
        if (!this.pendingModels[typeName]) {
            let enumBlock = new code_entity_1.Block(`const enum ${typeName}`);
            _.each(allowableValues.values, (value) => enumBlock.writeLine(`${value},`));
            this.pendingModels[typeName] = enumBlock;
        }
    }
    generateService(swaggerService, serverModuleName) {
        let swaggerServiceContractName = this.getSwaggerServiceContractName(swaggerService);
        let serviceInterface = new code_entity_1.Block(`interface ${swaggerServiceContractName}`);
        let serviceImplementation = new code_entity_1.Block(`export class ${this.getSwaggerServiceName(swaggerService)} implements ${serverModuleName}.${swaggerServiceContractName}`);
        serviceImplementation.addBlock(new code_entity_1.Block(`constructor(private $serviceProxy: ${serverModuleName}.IServiceProxy)`));
        let map = Object.create(null);
        _.each(swaggerService.apis, (api) => {
            _.each(api.operations, (operation) => {
                if (!this.hasFormParamType(operation)) {
                    if (!map[operation.nickname]) {
                        map[operation.nickname] = [];
                    }
                    let generatedOperation = this.generateOperation(operation, swaggerService.basePath, api.path);
                    map[operation.nickname].push(generatedOperation);
                }
            });
        });
        let values = _.values(map);
        _.each(values, (endpoints) => {
            let index = 0;
            _.each(endpoints, (endpoint) => {
                if (index === 0) {
                    serviceInterface.addLine(endpoint.endpointInterface);
                    serviceImplementation.addBlock(endpoint.endpointImplementation);
                }
                else {
                    let implementationOpener = `public ${endpoint.operationContractName + index}(${endpoint.parameters.join(", ")}): Promise<${endpoint.callResultType}>`;
                    let interfaceOpener = `${endpoint.operationContractName + index}(${endpoint.parameters.join(", ")}): Promise<${endpoint.callResultType}>;`;
                    let implementationBlock = new code_entity_1.Block(implementationOpener);
                    implementationBlock.writeLine(_.map(endpoint.endpointImplementation.codeEntities, (codeEntity) => codeEntity.content).join("\n"));
                    serviceInterface.addLine(code_entity_1.Line.create(interfaceOpener));
                    serviceImplementation.addBlock(implementationBlock);
                }
                index++;
            });
        });
        return { serviceInterface: serviceInterface, serviceImplementation: serviceImplementation };
    }
    getSwaggerServiceContractName(swaggerService) {
        let swaggerServiceName = this.getSwaggerServiceClassName(swaggerService);
        let name = this.getNameWithoutSlash(swaggerServiceName);
        return `I${name}ServiceContract`;
    }
    getSwaggerServiceName(swaggerService) {
        let swaggerServiceName = this.getSwaggerServiceClassName(swaggerService);
        let name = this.getNameWithoutSlash(swaggerServiceName);
        return `${name}Service`;
    }
    getSwaggerServiceClassName(swaggerService) {
        let swaggerServiceName = swaggerService.resourcePath.substr(1);
        return this.toPascalCase(swaggerServiceName);
    }
    toPascalCase(name) {
        return name[0].toUpperCase() + name.substr(1);
    }
    toCamelCase(name) {
        return name[0].toLowerCase() + name.substr(1);
    }
    quote(s) {
        return "'" + s + "'";
    }
    escapeKeyword(name) {
        if (name === "package") {
            return name + "_";
        }
        return name;
    }
    compare(a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        return 0;
    }
    hasFormParamType(operation) {
        return !!_.find(operation.parameters, (parameter) => this.isParameterOfType(parameter, ParamTypes.Form));
    }
    generateOperation(operation, basePath, path) {
        let operationContractName = this.getOperationContractName(operation);
        let parameters = [];
        let enumPathParameters = {};
        operation.parameters.sort((parameter, otherParameter) => {
            let parameterType = this.getParameterType(parameter);
            let otherParameterType = this.getParameterType(otherParameter);
            if (parameterType < otherParameterType) {
                return -1;
            }
            else if (parameterType > otherParameterType) {
                return 1;
            }
            else if (parameterType === ParamTypes.Path) {
                return this.compare(path.indexOf(parameter.name), path.indexOf(otherParameter.name));
            }
            else {
                return parameter.name.localeCompare(otherParameter.name);
            }
        });
        let pathParams = this.getSwaggerParamsByType(operation, ParamTypes.Path);
        _.each(pathParams, (parameter) => {
            if (parameter.allowableValues !== undefined && parameter.dataType === "string") {
                this.tsTypeSystemHelpers.addModel(parameter.allowableValues.valueType);
                this.ensureEnumAdded(parameter.allowableValues);
                enumPathParameters[parameter.name] = "<any>";
            }
        });
        let paramsMap = Object.create(null);
        _.each(operation.parameters, (parameter) => {
            let tsTypeName = this.tsTypeSystemHelpers.translate(parameter.dataType);
            if (this.tsTypeSystemHelpers.isStream(tsTypeName)) {
                tsTypeName = this.tsTypeSystemHelpers.getReadableStreamTypeName();
            }
            else if (parameter.allowableValues) {
                this.tsTypeSystemHelpers.addModel(parameter.allowableValues.valueType);
                this.ensureEnumAdded(parameter.allowableValues);
                tsTypeName = this.tsTypeSystemHelpers.translate(parameter.allowableValues.valueType);
            }
            if (!this.tsTypeSystemHelpers.isBuiltIn(tsTypeName)) {
                tsTypeName = "Server." + tsTypeName;
            }
            parameter.name = this.escapeKeyword(parameter.name);
            parameters.push(`${parameter.name}: ${tsTypeName}`);
            paramsMap[parameter.name] = tsTypeName;
        });
        let numberOfClosingBrackets = 0;
        let responseType = this.tsTypeSystemHelpers.translate(operation.responseClass)
            .split(/[<>]/)
            .filter(e => e)
            .map(rt => this.tsTypeSystemHelpers.isBuiltIn(rt) ? rt : `Server.${rt}`)
            .reduce((prev, current) => { ++numberOfClosingBrackets; return `${prev}<${current}`; }) + _.repeat(">", numberOfClosingBrackets);
        let httpCallParameters = [this.quote(operation.nickname), this.quote(operation.httpMethod)];
        let httpCallPath = this.generateHttpCallPath(operation, basePath, path, enumPathParameters);
        httpCallParameters.push(httpCallPath);
        let accepts = this.getAccepts(operation);
        httpCallParameters.push(accepts ? this.quote(accepts) : "null");
        let bodyParams = this.generateBodyParams(operation);
        httpCallParameters.push(bodyParams);
        if (this.tsTypeSystemHelpers.isStream(responseType)) {
            parameters.push("$resultStream: " + this.tsTypeSystemHelpers.getWritableStreamTypeName());
            httpCallParameters.push("$resultStream");
        }
        else {
            httpCallParameters.push("null");
        }
        let callResultType = this.tsTypeSystemHelpers.isStream(responseType) ? "void" : responseType;
        let generatedContract = code_entity_1.Line.create(`${operationContractName}(${parameters.join(", ")}): Promise<${callResultType}>;`);
        let generatedOperation = new code_entity_1.Block(`public ${operationContractName}(${parameters.join(", ")}): Promise<${callResultType}>`);
        generatedOperation.writeLine(`return this.$serviceProxy.call<${callResultType}>(${httpCallParameters.join(", ")});`);
        return {
            operationContractName: operationContractName,
            endpointInterface: generatedContract,
            endpointImplementation: generatedOperation,
            parameters: parameters,
            callResultType: callResultType
        };
    }
    getOperationContractName(operation) {
        return this.toCamelCase(operation.nickname);
    }
    getSwaggerParamsByType(operation, paramType) {
        return _.filter(operation.parameters, (parameter) => {
            return this.isParameterOfType(parameter, paramType);
        });
    }
    isParameterOfType(parameter, paramType) {
        switch (paramType) {
            case ParamTypes.Path:
                return parameter.paramType === "path";
            case ParamTypes.Query:
                return parameter.paramType === "query";
            case ParamTypes.Body:
                return parameter.paramType === "body";
            case ParamTypes.Form:
                return parameter.paramType === "form";
            default:
                return false;
        }
    }
    getParameterType(parameter) {
        if (this.isParameterOfType(parameter, ParamTypes.Path)) {
            return ParamTypes.Path;
        }
        else if (this.isParameterOfType(parameter, ParamTypes.Query)) {
            return ParamTypes.Query;
        }
        else if (this.isParameterOfType(parameter, ParamTypes.Body)) {
            return ParamTypes.Body;
        }
        else if (this.isParameterOfType(parameter, ParamTypes.Form)) {
            return ParamTypes.Form;
        }
        return null;
    }
    generateHttpCallPath(operation, basePath, path, enumPathParameters) {
        let components = _.filter(path.split("/"), (component) => !!component && !!component.trim());
        let pathComponents = _.map(components, (pathComponent) => {
            let matchParam = /{(.+)}/.exec(pathComponent);
            if (matchParam) {
                let param = matchParam[1];
                if (enumPathParameters[param]) {
                    param = "(" + enumPathParameters[param] + param + ")";
                }
                return `encodeURI(${param}.replace(/${"\\\\"}/g, '/'))`;
            }
            return this.quote(pathComponent);
        });
        let fullPath = [];
        _.each(basePath.split("/"), (part) => {
            if (part) {
                fullPath.push(this.quote(part));
            }
        });
        fullPath = fullPath.concat(pathComponents);
        let callPath = `[${fullPath.join(", ")}].join('/')`;
        let queryParams = this.getSwaggerParamsByType(operation, ParamTypes.Query);
        if (queryParams.length > 0) {
            let queryParamMap = _.map(queryParams, (param) => `'${param.name}': ${param.name}`).join(", ");
            callPath += ` + '?' + querystring.stringify({ ${queryParamMap} })`;
        }
        return callPath;
    }
    getAccepts(operation) {
        if (this.tsTypeSystemHelpers.isStream(operation.responseClass)) {
            return "application/octet-stream";
        }
        else if (this.tsTypeSystemHelpers.translate(operation.responseClass) === "void") {
            return null;
        }
        return "application/json";
    }
    generateBodyParams(operation) {
        let bodyParams = this.getSwaggerParamsByType(operation, ParamTypes.Body);
        let result = [];
        _.each(bodyParams, (bodyParam) => {
            let contentType = this.getContentType(bodyParam.dataType);
            let paramValue = bodyParam.name;
            if (contentType === "application/json") {
                paramValue = `JSON.stringify(${bodyParam.name})`;
            }
            result.push(`{ name: ${this.quote(bodyParam.name)}, value: ${paramValue}, contentType: ${this.quote(contentType)} }`);
        });
        if (result.length === 0) {
            return "null";
        }
        return "[" + result.toString() + "]";
    }
    getContentType(typeName) {
        if (this.tsTypeSystemHelpers.isStream(typeName)) {
            return "application/octet-stream";
        }
        return "application/json";
    }
}
exports.ServiceContractGenerator = ServiceContractGenerator;
$injector.register("serviceContractGenerator", ServiceContractGenerator);
