"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const os_1 = require("os");
const path = require("path");
const util = require("util");
const commonHelpers = require("./common/helpers");
const constants_1 = require("./common/constants");
const project_base_1 = require("./common/appbuilder/project/project-base");
const helpers = require("./helpers");
const constants_2 = require("./common/constants");
class Project extends project_base_1.ProjectBase {
    constructor($config, $frameworkProjectResolver, $ionicProjectTransformator, $jsonSchemaValidator, $loginManager, $multipartUploadService, $progressIndicator, $projectFilesManager, $projectPropertiesService, $server, $templatesService, $prompter, $cordovaProjectCapabilities, $errors, $fs, $logger, $nativeScriptProjectCapabilities, $options, $projectConstants, $staticConfig) {
        super($cordovaProjectCapabilities, $errors, $fs, $logger, $nativeScriptProjectCapabilities, $options, $projectConstants, $staticConfig);
        this.$config = $config;
        this.$frameworkProjectResolver = $frameworkProjectResolver;
        this.$ionicProjectTransformator = $ionicProjectTransformator;
        this.$jsonSchemaValidator = $jsonSchemaValidator;
        this.$loginManager = $loginManager;
        this.$multipartUploadService = $multipartUploadService;
        this.$progressIndicator = $progressIndicator;
        this.$projectFilesManager = $projectFilesManager;
        this.$projectPropertiesService = $projectPropertiesService;
        this.$server = $server;
        this.$templatesService = $templatesService;
        this.$prompter = $prompter;
        this.$cordovaProjectCapabilities = $cordovaProjectCapabilities;
        this.$errors = $errors;
        this.$fs = $fs;
        this.$logger = $logger;
        this.$nativeScriptProjectCapabilities = $nativeScriptProjectCapabilities;
        this.$options = $options;
        this.$projectConstants = $projectConstants;
        this.$staticConfig = $staticConfig;
        this.cachedProjectDir = "";
        if (this.projectData && this.projectData["TemplateAppName"]) {
            this.$errors.failWithoutHelp("This hybrid project targets Apache Cordova 2.x. " +
                "The AppBuilder CLI lets you target only Apache Cordova 3.0.0 or later. " +
                "To develop your projects with Apache Cordova 2.x, run the AppBuilder Windows client or the in-browser client.");
        }
        if (this.projectData && this.projectData.Framework) {
            this.frameworkProject = this.$frameworkProjectResolver.resolve(this.projectData.Framework);
        }
    }
    get projectDir() {
        return this.getProjectDir();
    }
    get capabilities() {
        return this.frameworkProject.capabilities;
    }
    getLiveSyncUrl() {
        return this.frameworkProject.liveSyncUrl;
    }
    get projectConfigFiles() {
        return this.frameworkProject.configFiles;
    }
    get projectData() {
        if (!this._projectData) {
            const projectDir = this.getProjectDir();
            if (projectDir) {
                const debugProjectFile = path.join(projectDir, this.$projectConstants.DEBUG_PROJECT_FILE_NAME);
                if (this.$options.debug && !this.$fs.exists(debugProjectFile)) {
                    this.$fs.writeJson(debugProjectFile, {});
                }
                const releaseProjectFile = path.join(projectDir, this.$projectConstants.RELEASE_PROJECT_FILE_NAME);
                if (this.$options.release && !this.$fs.exists(releaseProjectFile)) {
                    this.$fs.writeJson(releaseProjectFile, {});
                }
            }
            this.readProjectData();
        }
        return this._projectData;
    }
    set projectData(projectData) {
        this._projectData = projectData;
    }
    getShouldSaveProject() {
        this.frameworkProject = this.$frameworkProjectResolver.resolve(this.projectData.Framework);
        return this.$projectPropertiesService.completeProjectProperties(this.projectData, this.frameworkProject) || super.getShouldSaveProject();
    }
    getPluginVariablesInfo(configuration) {
        return this.frameworkProject.getPluginVariablesInfo(this.projectInformation, this.getProjectDir(), configuration);
    }
    getProjectTargets() {
        let projectDir = this.getProjectDir();
        let projectTargets = this.frameworkProject.getProjectTargets(projectDir);
        return projectTargets;
    }
    getConfigFileContent(template) {
        let configFile = _.find(this.projectConfigFiles, _configFile => _configFile.template === template);
        if (configFile) {
            try {
                let configFileContent = this.$fs.readText(configFile.filepath);
                return configFileContent;
            }
            catch (e) {
                this.$logger.trace(`Error while trying to read file: ${configFile.filepath}. Error is: {e.message}.`);
                return null;
            }
        }
        return null;
    }
    configurationFilesString() {
        if (!this.frameworkProject) {
            let result = [];
            _.each(_.values(constants_2.TARGET_FRAMEWORK_IDENTIFIERS), (framework) => {
                let frameworkProject = this.$frameworkProjectResolver.resolve(framework);
                let configFiles = frameworkProject.configFiles;
                if (configFiles && configFiles.length > 0) {
                    let title = util.format("Configuration files for %s projects:", framework);
                    result.push(title);
                    result.push(this.configurationFilesStringCore(configFiles));
                }
            });
            return result.join("\n");
        }
        return this.configurationFilesStringCore(this.frameworkProject.configFiles);
    }
    configurationFilesStringCore(configFiles) {
        return _.map(configFiles, (file) => {
            return util.format("        %s - %s", file.template, file.helpText);
        }).join("\n");
    }
    get configurations() {
        let configurations = [];
        if (this.$options.debug) {
            configurations.push(this.$projectConstants.DEBUG_CONFIGURATION_NAME);
        }
        if (this.$options.release) {
            configurations.push(this.$projectConstants.RELEASE_CONFIGURATION_NAME);
        }
        if (configurations.length === 0) {
            configurations.push(this.$projectConstants.DEBUG_CONFIGURATION_NAME);
            configurations.push(this.$projectConstants.RELEASE_CONFIGURATION_NAME);
        }
        return configurations;
    }
    getBuildConfiguration() {
        return this.$options.release ? constants_1.Configurations.Release : constants_1.Configurations.Debug;
    }
    getProperty(propertyName, configuration) {
        return this.frameworkProject.getProperty(propertyName, configuration, this.projectInformation);
    }
    setProperty(propertyName, value, configuration) {
        if (this.hasBuildConfigurations) {
            let configData = this.configurationSpecificData[configuration.toLowerCase()];
            if (!configData) {
                configData = Object.create(null);
                this.configurationSpecificData[configuration] = configData;
            }
            configData[propertyName] = value;
        }
        else {
            this.projectData[propertyName] = value;
        }
    }
    getProjectDir() {
        if (this.cachedProjectDir) {
            return this.cachedProjectDir;
        }
        this.cachedProjectDir = null;
        let projectDir = path.resolve(this.$options.path || ".");
        while (true) {
            this.$logger.trace("Looking for project in '%s'", projectDir);
            if (this.$fs.exists(path.join(projectDir, this.$staticConfig.PROJECT_FILE_NAME))) {
                this.$logger.debug("Project directory is '%s'.", projectDir);
                this.cachedProjectDir = projectDir;
                break;
            }
            let dir = path.dirname(projectDir);
            if (dir === projectDir) {
                this.$logger.debug("No project found at or above '%s'.", path.resolve("."));
                break;
            }
            projectDir = dir;
        }
        return this.cachedProjectDir;
    }
    appResourcesPath() {
        return path.join(this.getProjectDir(), this.frameworkProject.relativeAppResourcesPath);
    }
    createTemplateFolder(projectDir) {
        this.$fs.createDirectory(projectDir);
        let projectDirFiles = this.$fs.readDirectory(projectDir);
        if (projectDirFiles.length !== 0) {
            this.$errors.fail("The specified directory '%s' must be empty to create a new project.", projectDir);
        }
    }
    createProjectFile(projectDir, properties) {
        return __awaiter(this, void 0, void 0, function* () {
            properties = properties || {};
            this.$fs.createDirectory(projectDir);
            this.cachedProjectDir = projectDir;
            this.projectData = properties;
            this.frameworkProject = this.$frameworkProjectResolver.resolve(this.projectData.Framework);
            this.$projectPropertiesService.completeProjectProperties(this.projectData, this.frameworkProject);
            this.validateProjectData(this.projectData);
            this.saveProject(projectDir);
        });
    }
    createNewProject(projectName, framework, template) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!projectName) {
                this.$errors.fail("No project name specified.");
            }
            let projectDir = this.getNewProjectDir();
            this.frameworkProject = this.$frameworkProjectResolver.resolve(framework);
            return this.createFromTemplate(projectName, projectDir, template);
        });
    }
    get projectFilePatterns() {
        return [`*${this.$projectConstants.PROJECT_FILE}`, `*${this.$projectConstants.PROJECT_IGNORE_FILE}`];
    }
    isIonicProject(projectDir) {
        let result = false;
        let oldIonicProjectFile = path.join(projectDir, "ionic.project");
        let newIonicProjectFile = path.join(projectDir, "ionic.config.json");
        let ionicProject = this.$fs.exists(oldIonicProjectFile) ? oldIonicProjectFile : newIonicProjectFile;
        let packageJson = path.join(projectDir, "package.json");
        let hasIonicProject = this.$fs.exists(ionicProject);
        let hasPackageJson = this.$fs.exists(packageJson);
        if (hasIonicProject && hasPackageJson) {
            try {
                let content = this.$fs.readJson(ionicProject);
                result = _.has(content, "name") && _.has(content, "app_id");
            }
            catch (e) {
            }
        }
        return result;
    }
    initializeProjectFromExistingFiles(framework, projectDir, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            const prompt = "CAUTION: This operation will modify your Ionic-based project to make it compatible with AppBuilder and cannot be undone. To avoid losing any work, make sure that you have a backup or that the project is under source control.";
            projectDir = projectDir || this.getNewProjectDir();
            if (!this.$fs.exists(projectDir)) {
                this.$errors.failWithoutHelp(`The specified folder '${projectDir}' does not exist!`);
            }
            let ionicProject = this.isIonicProject(projectDir);
            let createBackupOfIonicProject = false;
            if (ionicProject && !this.$options.force) {
                this.$logger.warn(prompt);
                createBackupOfIonicProject = yield this.$prompter.confirm("Do you want to create backup folder?", () => true);
            }
            let projectFile = path.join(projectDir, this.$staticConfig.PROJECT_FILE_NAME);
            if (this.$fs.exists(projectFile)) {
                this.$errors.failWithoutHelp("The specified folder is already an AppBuilder command line project!");
            }
            this.frameworkProject = this.$frameworkProjectResolver.resolve(framework);
            let blankTemplateFile = this.frameworkProject.getTemplateFilename("Blank");
            yield this.$fs.unzip(path.join(this.$templatesService.projectTemplatesDir, blankTemplateFile), projectDir, { overwriteExisitingFiles: false }, this.projectFilePatterns.concat(this.frameworkProject.projectSpecificFiles));
            yield this.createProjectFileFromExistingProject(projectDir, appName);
            if (ionicProject) {
                yield this.$ionicProjectTransformator.transformToAppBuilderProject(createBackupOfIonicProject);
            }
            this.$logger.info("Successfully initialized %s project.", framework);
        });
    }
    createProjectFileFromExistingProject(projectDir, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            appName = appName || path.basename(projectDir);
            let properties = yield this.getProjectPropertiesFromExistingProject(projectDir, appName);
            this.projectData = this.alterPropertiesForNewProject(properties, appName);
            try {
                this.validateProjectData(this.projectData);
                this.saveProject(projectDir);
            }
            catch (e) {
                this.$errors.fail("There was an error while initialising the project: " + os_1.EOL + e);
            }
        });
    }
    getNewProjectDir() {
        return this.$options.path || process.cwd();
    }
    ensureProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.projectData) {
                this.$errors.fail("No project found at or above '%s' and neither was a --path specified.", process.cwd());
            }
            yield this.frameworkProject.ensureProject(this.projectDir);
        });
    }
    ensureCordovaProject() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureProject();
            if (this.projectData.Framework !== constants_2.TARGET_FRAMEWORK_IDENTIFIERS.Cordova) {
                this.$errors.fail("This command is applicable only to Cordova projects.");
            }
        });
    }
    enumerateProjectFiles(additionalExcludedProjectDirsAndFiles) {
        let projectDir = this.getProjectDir();
        let filter = (filePath, stat) => {
            let isSubprojectDir = stat.isDirectory() && this.$fs.exists(path.join(filePath, this.$projectConstants.PROJECT_FILE));
            return isSubprojectDir;
        };
        let projectFiles = this.$projectFilesManager.getProjectFiles(projectDir, additionalExcludedProjectDirsAndFiles, filter);
        return projectFiles;
    }
    getTempDir(extraSubdir) {
        let dir = path.join(this.getProjectDir(), ".ab");
        this.$fs.createDirectory(dir);
        if (extraSubdir) {
            dir = path.join(dir, extraSubdir);
            this.$fs.createDirectory(dir);
        }
        return dir;
    }
    getConfigurationsSpecifiedByUser() {
        let validConfigurations = this.getAllConfigurationsNames(), userConfigurations = _.map(this.$options.config, c => c.toLowerCase());
        if (this.$options.config && this.$options.config.length && !_.intersection(validConfigurations, userConfigurations).length) {
            this.$errors.failWithoutHelp("Operation cannot be completed because configurations %s are invalid.", this.$options.config);
        }
        return userConfigurations.filter(c => {
            let configName = c.toLowerCase();
            if (~validConfigurations.indexOf(configName)) {
                return true;
            }
            this.$logger.warn("Configuration %s is invalid", c);
            return false;
        });
    }
    getAllConfigurationsNames() {
        return _.keys(this.configurationSpecificData);
    }
    getProjectConfiguration(defaultConfiguration) {
        let result = this.getConfigurationsSpecifiedByUser()[0];
        if (!result && defaultConfiguration) {
            result = _.some(this.getAllConfigurationsNames(), conf => conf.toLowerCase() === defaultConfiguration.toLowerCase()) ? defaultConfiguration : null;
        }
        return result || _.first(this.getAllConfigurationsNames().sort()) || constants_1.Configurations.Debug;
    }
    updateProjectProperty(mode, propertyName, propertyValues, configurations) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = yield this.validateUpdatePropertyInfo(propertyName, propertyValues, configurations), normalizedPropertyName = data.normalizedPropertyName, projectConfigurations = data.projectConfigurations;
            if (normalizedPropertyName === this.$projectConstants.CORE_PLUGINS_PROPERTY_NAME) {
                yield this.$projectPropertiesService.updateCorePlugins(this.projectData, this.configurationSpecificData, mode, propertyValues, projectConfigurations);
            }
            else {
                if (projectConfigurations.length) {
                    yield Promise.all(_.map(projectConfigurations, configuration => {
                        this.$projectPropertiesService.updateProjectProperty(this.projectData, this.configurationSpecificData[configuration], mode, normalizedPropertyName, propertyValues);
                    }));
                }
                else {
                    yield this.$projectPropertiesService.updateProjectProperty(this.projectData, undefined, mode, normalizedPropertyName, propertyValues);
                    yield Promise.all(_.map(this.configurationSpecificData, configData => this.$projectPropertiesService.updateProjectProperty(configData, undefined, mode, normalizedPropertyName, propertyValues)));
                }
            }
        });
    }
    updateProjectPropertyAndSave(mode, propertyName, propertyValues, configurations) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = yield this.validateUpdatePropertyInfo(propertyName, propertyValues, configurations), normalizedPropertyName = data.normalizedPropertyName, projectConfigurations = data.projectConfigurations;
            yield this.updateProjectProperty(mode, normalizedPropertyName, propertyValues, projectConfigurations);
            this.saveProject(this.getProjectDir(), this.getAllConfigurationsNames());
            projectConfigurations.forEach((configuration) => __awaiter(this, void 0, void 0, function* () {
                yield this.printProjectProperty(normalizedPropertyName, configuration);
            }));
            if (!projectConfigurations || !projectConfigurations.length) {
                yield this.printProjectProperty(normalizedPropertyName);
            }
        });
    }
    printProjectProperty(property, configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.projectData) {
                let schema = yield this.getProjectSchema();
                let mergedProjectData = Object.create(null);
                _.extend(mergedProjectData, this.projectData);
                if (configuration) {
                    _.extend(mergedProjectData, this.configurationSpecificData[configuration]);
                }
                if (property) {
                    let normalizedPropertyName = this.$projectPropertiesService.normalizePropertyName(property, mergedProjectData);
                    if (this.$options.validValue) {
                        let prop = schema[normalizedPropertyName];
                        yield this.printValidValuesOfProperty(prop);
                    }
                    else {
                        if (_.has(mergedProjectData, normalizedPropertyName)) {
                            let additionalMessage = configuration ? ` for configuration ${configuration}` : "";
                            this.$logger.write(`The value of ${normalizedPropertyName}${additionalMessage} is: `);
                            this.$logger.out(mergedProjectData[normalizedPropertyName]);
                        }
                        else if (this.hasConfigurationSpecificDataForProperty(normalizedPropertyName)) {
                            this.printConfigurationSpecificDataForProperty(normalizedPropertyName);
                        }
                        else {
                            this.$errors.fail("Unrecognized project property '%s'", property);
                        }
                    }
                }
                else {
                    if (this.$options.validValue) {
                        let propKeys = _.keys(schema);
                        let sortedProperties = _.sortBy(propKeys, (propertyName) => propertyName.toUpperCase());
                        yield Promise.all(_.map(sortedProperties, propKey => {
                            let prop = schema[propKey];
                            this.$logger.info("  " + propKey);
                            return this.printValidValuesOfProperty(prop);
                        }));
                    }
                    else {
                        let propKeys = _.keys(mergedProjectData);
                        let sortedProperties = _.sortBy(propKeys, (propertyName) => propertyName.toUpperCase());
                        _.each(sortedProperties, (propertyName) => this.$logger.out(propertyName + ": " + mergedProjectData[propertyName]));
                        this.printConfigurationSpecificData(configuration);
                    }
                }
            }
            else {
                if (property) {
                    let targetFrameworkIdentifiers = _.values(constants_2.TARGET_FRAMEWORK_IDENTIFIERS);
                    _.each(targetFrameworkIdentifiers, (targetFrameworkIdentifier) => __awaiter(this, void 0, void 0, function* () {
                        let projectSchema = this.$jsonSchemaValidator.tryResolveValidationSchema(targetFrameworkIdentifier);
                        let currentProp = _.find(_.keys(projectSchema), key => key === property);
                        if (currentProp) {
                            this.$logger.out("  Project type %s:", targetFrameworkIdentifier);
                            yield this.printValidValuesOfProperty(projectSchema[currentProp]);
                        }
                    }));
                }
                else {
                    yield this.$logger.out(this.$projectPropertiesService.getPropertiesForAllSupportedProjects());
                }
            }
        });
    }
    checkSdkVersions(platform) {
        this.frameworkProject.checkSdkVersions(platform, this.projectData);
    }
    printValidValuesOfProperty(property) {
        return __awaiter(this, void 0, void 0, function* () {
            if (property.description) {
                this.$logger.info("%s%s", Project.INDENTATION, property.description);
            }
            if (property.pattern) {
                this.$logger.trace("%sDesired pattern is: %s", Project.INDENTATION, property.pattern);
            }
            let validValues = yield this.$projectPropertiesService.getValidValuesForProperty(property);
            if (validValues) {
                this.$logger.out("%sValid values:", Project.INDENTATION);
                _.forEach(validValues, value => {
                    this.$logger.out("%s  %s", Project.INDENTATION, value);
                });
            }
        });
    }
    hasConfigurationSpecificDataForProperty(normalizedPropertyName) {
        let properties = _(this.configurationSpecificData)
            .values()
            .map(val => _.keys(val))
            .flatten()
            .value();
        return _.some(properties, prop => prop === normalizedPropertyName);
    }
    getPropertyValueAsArray(property, indentation) {
        if (typeof property === "string" || property instanceof Array) {
            return [property];
        }
        return [_.map(property, (value, key) => {
                let delimiter = typeof value === "string" || value instanceof Array ? " " : '\n';
                return util.format('%s%s:%s%s', indentation, key, delimiter, this.getPropertyValueAsArray(value, indentation + '   ').join('\n'));
            })];
    }
    getConfigurationSpecificDataForProperty(normalizedPropertyName, configuration) {
        let numberOfConfigs = configuration ? 1 : this.getAllConfigurationsNames().length;
        let configsDataForProperty = configuration ?
            this.getPropertyValueAsArray(this.configurationSpecificData[configuration][normalizedPropertyName], '') :
            _(this.configurationSpecificData)
                .values()
                .map((config) => _.flatten(this.getPropertyValueAsArray(config[normalizedPropertyName], '')))
                .value();
        let sharedValues = _.intersection.apply(null, configsDataForProperty);
        let valuesInAllConfigs = _.map(sharedValues, value => helpers.fill(value, numberOfConfigs));
        let configSpecificValues = _.map(configsDataForProperty, config => _.difference(config, sharedValues));
        let maxLength = _(configSpecificValues)
            .map(value => value.length)
            .max();
        _.range(maxLength)
            .map(valueIndex => _.map(configSpecificValues, config => config[valueIndex] || ""))
            .forEach(propertyValues => valuesInAllConfigs.push(propertyValues));
        return valuesInAllConfigs;
    }
    printConfigurationSpecificData(configuration) {
        let properties;
        if (configuration) {
            properties = _.keys(this.configurationSpecificData[configuration]);
        }
        else {
            properties = _(this.configurationSpecificData)
                .values()
                .map(_properties => _.keys(_properties))
                .flatten()
                .uniq()
                .value();
        }
        if (properties.length > 0) {
            this.$logger.out("%sConfiguration specific properties: ", os_1.EOL);
            _.forEach(properties, property => this.printConfigurationSpecificDataForProperty(property, configuration));
        }
    }
    printConfigurationSpecificDataForProperty(property, configuration) {
        let data = this.getConfigurationSpecificDataForProperty(property, configuration);
        if (data && data.length) {
            let headers = configuration ? [configuration] : this.getAllConfigurationsNames();
            let table = commonHelpers.createTable(headers, data);
            this.$logger.out("%s:%s%s", property, os_1.EOL, table.toString());
        }
    }
    validateProjectProperty(property, args, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!property) {
                this.$errors.fail("Please specify a property name.");
            }
            let validProperties = this.$jsonSchemaValidator.getValidProperties(this.projectData.Framework, this.projectData.FrameworkVersion);
            if (_.includes(validProperties, property)) {
                let normalizedPropertyName = this.$projectPropertiesService.normalizePropertyName(property, this.projectData);
                let isArray = this.$jsonSchemaValidator.getPropertyType(this.projectData.Framework, normalizedPropertyName) === "array";
                if (!isArray) {
                    if (!args || args.length === 0) {
                        this.$errors.fail("Property %s requires a single value.", property);
                    }
                    if (args.length !== 1) {
                        this.$errors.fail("Property '%s' is not a collection of flags. Specify only a single property value.", property);
                    }
                    if (mode === "add" || mode === "del") {
                        this.$errors.fail("Property '%s' is not a collection of flags. Use prop-set to set a property value.", property);
                    }
                }
                return true;
            }
            this.$errors.fail("Invalid property name '%s'.", property);
        });
    }
    getProjectSchema() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._projectSchema) {
                this._projectSchema = this.frameworkProject.getProjectFileSchema();
            }
            return this._projectSchema;
        });
    }
    adjustBuildProperties(buildProperties) {
        return this.frameworkProject.adjustBuildProperties(buildProperties, this.projectInformation);
    }
    get requiredAndroidApiLevel() {
        return this.frameworkProject.requiredAndroidApiLevel;
    }
    ensureAllPlatformAssets() {
        let projectDir = this.getProjectDir();
        this.frameworkProject.ensureAllPlatformAssets(projectDir, this.projectData.FrameworkVersion);
    }
    validateProjectData(properties) {
        this.$jsonSchemaValidator.validate(properties);
        if (this.capabilities.build) {
            this.$jsonSchemaValidator.validatePropertyUsingBuildSchema(this.$projectConstants.APPIDENTIFIER_PROPERTY_NAME, properties.AppIdentifier);
        }
    }
    saveProject(projectDir, configurations) {
        let configs = (configurations && configurations.length > 0) ? configurations : this.configurations;
        projectDir = projectDir || this.getProjectDir();
        this.$fs.writeJson(path.join(projectDir, this.$staticConfig.PROJECT_FILE_NAME), this.projectData);
        _.each(configs, (configuration) => {
            let configFilePath = path.join(projectDir, util.format(".%s%s", configuration, this.$projectConstants.PROJECT_FILE));
            if (this.$fs.exists(configFilePath) && this.configurationSpecificData[configuration]) {
                let configurationSpecificKeys = _.reduce(this.configurationSpecificData[configuration], (result, value, key) => _.isEqual(value, this.projectData[key]) ? result : result.concat(key), []);
                this.$fs.writeJson(configFilePath, _.pick(this.configurationSpecificData[configuration], configurationSpecificKeys));
            }
        });
    }
    zipProject() {
        return __awaiter(this, void 0, void 0, function* () {
            let tempDir = this.getTempDir();
            let projectZipFile = path.join(tempDir, "Build.zip");
            this.$fs.deleteFile(projectZipFile);
            let projectDir = this.getProjectDir();
            let files = this.enumerateProjectFiles();
            yield this.$fs.zipFiles(projectZipFile, files, p => this.getProjectRelativePath(p, projectDir));
            return projectZipFile;
        });
    }
    importProject() {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureProject();
            yield this.$loginManager.ensureLoggedIn();
            let projectZipFile = yield this.zipProject();
            let fileSize = this.$fs.getFileSize(projectZipFile);
            this.$logger.debug("zipping completed, result file size: %s", fileSize.toString());
            let projectName = this.projectData.ProjectName;
            let bucketKey = util.format("%s_%s", projectName, path.basename(projectZipFile));
            this.$logger.printInfoMessageOnSameLine("Uploading...");
            if (fileSize > Project.CHUNK_UPLOAD_MIN_FILE_SIZE) {
                this.$logger.trace("Start uploading file by chunks.");
                yield this.$progressIndicator.showProgressIndicator(this.$multipartUploadService.uploadFileByChunks(projectZipFile, bucketKey), 2000, { surpressTrailingNewLine: true });
                yield this.$progressIndicator.showProgressIndicator(this.$server.projects.importLocalProject(projectName, projectName, bucketKey, true), 2000);
            }
            else {
                yield this.$progressIndicator.showProgressIndicator(this.$server.projects.importProject(projectName, projectName, true, yield this.$fs.createReadStream(projectZipFile)), 2000);
            }
            this.$logger.trace("Project imported");
        });
    }
    validate() {
        if (this.$staticConfig.triggerJsonSchemaValidation) {
            this.$jsonSchemaValidator.validate(this.projectData);
        }
    }
    saveProjectIfNeeded() {
        if (this.getShouldSaveProject() && this.$config.AUTO_UPGRADE_PROJECT_FILE) {
            this.saveProject(this.projectDir);
        }
    }
    getProjectRelativePath(fullPath, projectDir) {
        projectDir = path.join(projectDir, path.sep);
        if (!_.startsWith(fullPath, projectDir)) {
            throw new Error("File is not part of the project.");
        }
        return fullPath.substring(projectDir.length);
    }
    createFromTemplate(appname, projectDir, template) {
        return __awaiter(this, void 0, void 0, function* () {
            let templatesDir = this.$templatesService.projectTemplatesDir;
            let selectedTemplate = template || this.frameworkProject.defaultProjectTemplate;
            template = Project.UI_TEMPLATE_NAMES[selectedTemplate.toLowerCase()] || selectedTemplate;
            let templateFileName = path.join(templatesDir, this.frameworkProject.getTemplateFilename(template));
            this.$logger.trace("Using template '%s'", templateFileName);
            if (this.$fs.exists(templateFileName)) {
                projectDir = this.$options.path ? projectDir : path.join(projectDir, appname);
                this.$logger.trace("Creating template folder '%s'", projectDir);
                this.createTemplateFolder(projectDir);
                try {
                    this.$logger.trace("Extracting template from '%s'", templateFileName);
                    yield this.$fs.unzip(templateFileName, projectDir, { caseSensitive: false });
                    this.$logger.trace("Reading template project properties.");
                    let properties = this.$projectPropertiesService.getProjectProperties(path.join(projectDir, this.$projectConstants.PROJECT_FILE), true, this.frameworkProject);
                    properties = this.alterPropertiesForNewProject(properties, appname);
                    this.$logger.trace(properties);
                    this.$logger.trace("Saving project file.");
                    yield this.createProjectFile(projectDir, properties);
                    this.$logger.trace("Removing unnecessary files from template.");
                    this.removeExtraFiles(projectDir);
                    this.$fs.createDirectory(path.join(projectDir, "hooks"));
                    this.$logger.info("Project '%s' has been successfully created in '%s'.", appname, projectDir);
                }
                catch (ex) {
                    this.$fs.deleteDirectory(projectDir);
                    throw ex;
                }
                yield this.frameworkProject.ensureProject(this.projectDir);
            }
            else {
                let templates = this.frameworkProject.getProjectTemplatesString();
                this.$errors.failWithoutHelp(`The specified template ${this.$options.template} does not exist. You can use any of the following templates:${os_1.EOL}${templates}`);
            }
        });
    }
    alterPropertiesForNewProject(properties, projectName) {
        properties.ProjectGuid = commonHelpers.createGUID();
        properties.ProjectName = projectName;
        this.frameworkProject.alterPropertiesForNewProject(properties, projectName);
        return properties;
    }
    removeExtraFiles(projectDir) {
        this.$fs.deleteFile(path.join(projectDir, "mobile.vstemplate"));
    }
    getProjectPropertiesFromExistingProject(projectDir, appname) {
        return __awaiter(this, void 0, void 0, function* () {
            let projectFile = _.find(this.$fs.readDirectory(projectDir), file => {
                let extension = path.extname(file);
                return extension === ".proj" || extension === ".iceproj" || file === this.$projectConstants.PROJECT_FILE;
            });
            if (projectFile) {
                let isJsonProjectFile = projectFile === this.$projectConstants.PROJECT_FILE;
                return this.$projectPropertiesService.getProjectProperties(path.join(projectDir, projectFile), isJsonProjectFile, this.frameworkProject);
            }
            this.$logger.warn("No AppBuilder project file found in folder. Creating project with default settings!");
            return null;
        });
    }
    validateUpdatePropertyInfo(propertyName, propertyValues, configurations) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureProject();
            let projectConfigurations = (configurations && configurations.length) ? configurations : this.getConfigurationsSpecifiedByUser(), normalizedPropertyName = this.$projectPropertiesService.normalizePropertyName(propertyName, this.projectData);
            if (normalizedPropertyName === this.$projectConstants.APPIDENTIFIER_PROPERTY_NAME) {
                this.$jsonSchemaValidator.validatePropertyUsingBuildSchema(normalizedPropertyName, propertyValues[0]);
            }
            return { normalizedPropertyName, projectConfigurations };
        });
    }
}
Project.CHUNK_UPLOAD_MIN_FILE_SIZE = 1024 * 1024 * 50;
Project.INDENTATION = "     ";
Project.UI_TEMPLATE_NAMES = {
    "kendoui.blank": "KendoUI.Empty",
    "javascript.blank": "Blank"
};
exports.Project = Project;
$injector.register("project", Project);
