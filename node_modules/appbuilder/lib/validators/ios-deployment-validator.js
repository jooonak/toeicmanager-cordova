"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const ValidationResult = require("../common/validators/validation-result");
const BaseValidators = require("./base-validators");
const helpers = require("../helpers");
const util = require("util");
class IOSDeploymentValidator extends BaseValidators.BaseAsyncValidator {
    constructor(appIdentifier, deviceIdentifier, $identityManager, $x509, $injector) {
        super($injector);
        this.appIdentifier = appIdentifier;
        this.deviceIdentifier = deviceIdentifier;
        this.$identityManager = $identityManager;
        this.$x509 = $x509;
    }
    validate(model) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!model.provisionOption) {
                return new ValidationResult.ValidationResult(IOSDeploymentValidator.NOT_SPECIFIED_PROVISION_ERROR_MESSAGE);
            }
            if (!model.certificateOption) {
                return new ValidationResult.ValidationResult(IOSDeploymentValidator.NOT_SPECIFIED_CERTIFICATE_ERROR_MESSAGE);
            }
            let provision = yield this.$identityManager.findProvision(model.provisionOption);
            let provisionValidationResult = this.validateProvision(provision);
            if (!provisionValidationResult.isSuccessful) {
                return provisionValidationResult;
            }
            let certificate = yield this.$identityManager.findCertificate(model.certificateOption);
            let certificateValidationResult = yield this.validateCertificate(certificate, provision);
            if (!certificateValidationResult.isSuccessful) {
                return certificateValidationResult;
            }
            return new ValidationResult.ValidationResult(null);
        });
    }
    validateProvision(provision) {
        if (!provision) {
            return new ValidationResult.ValidationResult(IOSDeploymentValidator.NOT_FOUND_PROVISION_ERROR_MESSAGE);
        }
        if (Date.parse(provision.ExpirationDate) < new Date().getTime()) {
            return new ValidationResult.ValidationResult(IOSDeploymentValidator.EXPIRED_PROVISON_ERROR_MESSAGE);
        }
        if (provision.ApplicationIdentifier !== "*") {
            let provisionIdentifierPattern = new RegExp(this.getRegexPattern(provision.ApplicationIdentifier));
            if (!provisionIdentifierPattern.test(this.appIdentifier)) {
                return new ValidationResult.ValidationResult(IOSDeploymentValidator.APPLICATION_IDENTIFIER_MISMATCH);
            }
        }
        if (this.deviceIdentifier) {
            let isInProvisionedDevices = provision.ProvisionedDevices && _.includes(provision.ProvisionedDevices, this.deviceIdentifier);
            if (!isInProvisionedDevices) {
                return new ValidationResult.ValidationResult(util.format("The device with identifier '%s' is not included in provisioned devices for given provision. Use `$ appbuilder provision -v` to list all devices included in provision", this.deviceIdentifier));
            }
        }
        return new ValidationResult.ValidationResult(null);
    }
    validateCertificate(certificate, provision) {
        if (!certificate) {
            return new ValidationResult.ValidationResult(IOSDeploymentValidator.NOT_FOUND_CERTIFICATE_ERROR_MESSAGE);
        }
        if (!this.$identityManager.isCertificateCompatibleWithProvision(certificate, provision)) {
            return new ValidationResult.ValidationResult("Certificate is not included in provision's certificates");
        }
        if (this.isCertificateExpired(certificate.Certificate)) {
            return new ValidationResult.ValidationResult(IOSDeploymentValidator.EXPIRED_CERTIFICATE_ERROR_MESSAGE);
        }
        return new ValidationResult.ValidationResult(null);
    }
    isCertificateExpired(certificate) {
        let cert = this.$x509.load(certificate);
        return cert.expiresOn <= new Date();
    }
    getRegexPattern(appIdentifier) {
        let starPlaceholder = "<!StarPlaceholder!>";
        let escapedIdentifier = this.escape(helpers.stringReplaceAll(appIdentifier, "*", starPlaceholder));
        let replacedIdentifier = helpers.stringReplaceAll(escapedIdentifier, starPlaceholder, ".*");
        return "^" + replacedIdentifier + "$";
    }
    escape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
}
IOSDeploymentValidator.NOT_SPECIFIED_PROVISION_ERROR_MESSAGE = "Please specify the provisioning profile (with option --provision) that should be used when building the project.";
IOSDeploymentValidator.NOT_FOUND_PROVISION_ERROR_MESSAGE = "Could not find provision by specified index or name. List registered provisions with 'provision' command";
IOSDeploymentValidator.EXPIRED_PROVISON_ERROR_MESSAGE = "Provisioning profile is expired.";
IOSDeploymentValidator.APPLICATION_IDENTIFIER_MISMATCH = "The application identifier must match the bundle identifier in the provisioning profile.";
IOSDeploymentValidator.NOT_SPECIFIED_CERTIFICATE_ERROR_MESSAGE = "Please specify the certificate (with option --certificate) that should be used when building the project.";
IOSDeploymentValidator.NOT_FOUND_CERTIFICATE_ERROR_MESSAGE = "Could not find certificate by specified index or name. List registered certificates  with 'certificate' command";
IOSDeploymentValidator.EXPIRED_CERTIFICATE_ERROR_MESSAGE = "Certificate is expired.";
exports.IOSDeploymentValidator = IOSDeploymentValidator;
$injector.register("iOSDeploymentValidator", IOSDeploymentValidator);
