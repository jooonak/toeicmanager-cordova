"use strict";
const validator = require("validator");
const commonHelpers = require("../common/helpers");
const helpers = require("../helpers");
const ValidationResult = require("../common/validators/validation-result");
const BaseValidators = require("./base-validators");
const util = require("util");
class SelfSignedIdentityValidator extends BaseValidators.BaseValidator {
    constructor($x509, $injector) {
        super($injector);
        this.$x509 = $x509;
    }
    validate(identityModel) {
        let validationResult = BaseValidators.Helpers.validate([
            () => this.validateName(identityModel.Name),
            () => this.validateEmail(identityModel.Email),
            () => this.validateCountry(identityModel.Country),
            () => this.validateForGooglePlayPublishing(identityModel.ForGooglePlayPublishing),
            () => this.validateStartDate(identityModel.StartDate),
            () => this.validateEndDate(identityModel.ForGooglePlayPublishing, identityModel.StartDate, identityModel.EndDate)
        ]);
        return validationResult;
    }
    validateCertificate(forGooglePlayPublishing, certificatePem) {
        let cert = this.$x509.load(certificatePem);
        return this.validateStartDate(cert.issuedOn.toString()).isSuccessful
            && this.validateEndDate(forGooglePlayPublishing.toString(), cert.issuedOn.toString(), cert.expiresOn.toString()).isSuccessful;
    }
    validateProperty(identityModel, propertyName) {
        switch (propertyName) {
            case "Name":
                return this.validateName(identityModel.Name);
            case "Email":
                return this.validateEmail(identityModel.Email);
            case "Country":
                return this.validateCountry(identityModel.Country);
            case "ForGooglePlayPublishing":
                return this.validateForGooglePlayPublishing(identityModel.ForGooglePlayPublishing);
            case "StartDate":
                return this.validateStartDate(identityModel.StartDate);
            case "EndDate":
                return this.validateEndDate(identityModel.ForGooglePlayPublishing, identityModel.StartDate, identityModel.EndDate);
            default:
                return ValidationResult.ValidationResult.Successful;
        }
    }
    validateName(name) {
        if (commonHelpers.isNullOrWhitespace(name)) {
            return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.EMPTY_FIELD_ERROR_MESSAGE_PATTERN, "Name"));
        }
        return ValidationResult.ValidationResult.Successful;
    }
    validateEmail(email) {
        if (commonHelpers.isNullOrWhitespace(email)) {
            return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.EMPTY_FIELD_ERROR_MESSAGE_PATTERN, "Email"));
        }
        if (!validator.isEmail(email)) {
            return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.INVALID_FIELD_ERROR_MESSAGE_PATTERN, "Email"));
        }
        return ValidationResult.ValidationResult.Successful;
    }
    validateCountry(country) {
        if (commonHelpers.isNullOrWhitespace(country)) {
            return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.EMPTY_FIELD_ERROR_MESSAGE_PATTERN, "Country"));
        }
        if (_.includes(helpers.getCountries(), country)) {
            return ValidationResult.ValidationResult.Successful;
        }
        else {
            return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.INVALID_FIELD_ERROR_MESSAGE_PATTERN, "Country"));
        }
    }
    validateForGooglePlayPublishing(forGooglePlayPublishing) {
        if (commonHelpers.isNullOrWhitespace(forGooglePlayPublishing)) {
            return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.EMPTY_FIELD_ERROR_MESSAGE_PATTERN, "For Google Play Publishing"));
        }
        if (forGooglePlayPublishing.toLowerCase() === "true" || forGooglePlayPublishing.toLowerCase() === "false") {
            return ValidationResult.ValidationResult.Successful;
        }
        return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.INVALID_FIELD_ERROR_MESSAGE_PATTERN, "For Google Play Publishing"));
    }
    validateStartDate(startDate) {
        let validationResult = this.validateDate(startDate, "StartDate");
        return validationResult;
    }
    validateEndDate(forGooglePlayPublishing, startDate, endDate) {
        let parsedStartDate = new Date(startDate);
        let parsedEndDate;
        let validationResult = this.validateDate(endDate, "EndDate");
        if (!validationResult.isSuccessful) {
            return validationResult;
        }
        parsedEndDate = new Date(endDate);
        validationResult = this.validateExpiration(forGooglePlayPublishing, parsedStartDate, parsedEndDate);
        return validationResult;
    }
    validateDate(date, fieldName) {
        if (commonHelpers.isNullOrWhitespace(date)) {
            return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.EMPTY_FIELD_ERROR_MESSAGE_PATTERN, fieldName));
        }
        if (!validator.isDate(date)) {
            return new ValidationResult.ValidationResult(util.format(SelfSignedIdentityValidator.INVALID_FIELD_ERROR_MESSAGE_PATTERN, fieldName));
        }
        return ValidationResult.ValidationResult.Successful;
    }
    validateExpiration(forGooglePlayPublishing, startDate, endDate) {
        if (startDate > endDate) {
            return new ValidationResult.ValidationResult(SelfSignedIdentityValidator.NEGATIVE_EXPIRATION_ERROR_MESSAGE);
        }
        if (forGooglePlayPublishing.toLowerCase() === "true" &&
            endDate < SelfSignedIdentityValidator.GOOGLE_PLAY_IDENTITY_MIN_EXPIRATION_DATE) {
            return new ValidationResult.ValidationResult(SelfSignedIdentityValidator.INVALID_GOOGLE_PLAY_IDENTITY_EXPIRATION_DATE_ERROR_MESSAGE);
        }
        return ValidationResult.ValidationResult.Successful;
    }
}
SelfSignedIdentityValidator.DATE_FORMAT = "YYYY-MM-DD";
SelfSignedIdentityValidator.GOOGLE_PLAY_IDENTITY_MIN_EXPIRATION_DATE = new Date(2033, 9, 23, 0, 0, 0, 0);
SelfSignedIdentityValidator.EMPTY_FIELD_ERROR_MESSAGE_PATTERN = "%s is required";
SelfSignedIdentityValidator.INVALID_FIELD_ERROR_MESSAGE_PATTERN = "%s is invalid";
SelfSignedIdentityValidator.NEGATIVE_EXPIRATION_ERROR_MESSAGE = "The expiration date must be before the creation date";
SelfSignedIdentityValidator.INVALID_GOOGLE_PLAY_IDENTITY_EXPIRATION_DATE_ERROR_MESSAGE = util.format("The expiration date of google play identity must be after %s", SelfSignedIdentityValidator.GOOGLE_PLAY_IDENTITY_MIN_EXPIRATION_DATE);
exports.SelfSignedIdentityValidator = SelfSignedIdentityValidator;
$injector.register("selfSignedIdentityValidator", SelfSignedIdentityValidator);
